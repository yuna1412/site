"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/gsap/CSSRulePlugin.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/CSSRulePlugin.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CSSRulePlugin\": function() { return /* binding */ CSSRulePlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ CSSRulePlugin; }\n/* harmony export */ });\n/*!\n * CSSRulePlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    CSSPlugin,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _checkRegister = function _checkRegister() {\n  if (!_coreInitted) {\n    _initCore();\n\n    if (!CSSPlugin) {\n      console.warn(\"Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)\");\n    }\n  }\n\n  return _coreInitted;\n},\n    _initCore = function _initCore(core) {\n  gsap = core || _getGSAP();\n\n  if (_windowExists()) {\n    _win = window;\n    _doc = document;\n  }\n\n  if (gsap) {\n    CSSPlugin = gsap.plugins.css;\n\n    if (CSSPlugin) {\n      _coreInitted = 1;\n    }\n  }\n};\n\nvar CSSRulePlugin = {\n  version: \"3.11.2\",\n  name: \"cssRule\",\n  init: function init(target, value, tween, index, targets) {\n    if (!_checkRegister() || typeof target.cssText === \"undefined\") {\n      return false;\n    }\n\n    var div = target._gsProxy = target._gsProxy || _doc.createElement(\"div\");\n\n    this.ss = target;\n    this.style = div.style;\n    div.style.cssText = target.cssText;\n    CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt,\n        style = data.style,\n        ss = data.ss,\n        i;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    i = style.length;\n\n    while (--i > -1) {\n      ss[style[i]] = style[style[i]];\n    }\n  },\n  getRule: function getRule(selector) {\n    _checkRegister();\n\n    var ruleProp = _doc.all ? \"rules\" : \"cssRules\",\n        styleSheets = _doc.styleSheets,\n        i = styleSheets.length,\n        pseudo = selector.charAt(0) === \":\",\n        j,\n        curSS,\n        cs,\n        a;\n    selector = (pseudo ? \"\" : \",\") + selector.split(\"::\").join(\":\").toLowerCase() + \",\"; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.\n\n    if (pseudo) {\n      a = [];\n    }\n\n    while (i--) {\n      //Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.\n      try {\n        curSS = styleSheets[i][ruleProp];\n\n        if (!curSS) {\n          continue;\n        }\n\n        j = curSS.length;\n      } catch (e) {\n        console.warn(e);\n        continue;\n      }\n\n      while (--j > -1) {\n        cs = curSS[j];\n\n        if (cs.selectorText && (\",\" + cs.selectorText.split(\"::\").join(\":\").toLowerCase() + \",\").indexOf(selector) !== -1) {\n          //note: IE adds an extra \":\" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.\n          if (pseudo) {\n            a.push(cs.style);\n          } else {\n            return cs.style;\n          }\n        }\n      }\n    }\n\n    return a;\n  },\n  register: _initCore\n};\n_getGSAP() && gsap.registerPlugin(CSSRulePlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NSdWxlUGx1Z2luLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7O0FBRXpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUnVsZVBsdWdpbi5qcz9iNDU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ1NTUnVsZVBsdWdpbiAzLjExLjJcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIENTU1BsdWdpbixcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9jaGVja1JlZ2lzdGVyID0gZnVuY3Rpb24gX2NoZWNrUmVnaXN0ZXIoKSB7XG4gIGlmICghX2NvcmVJbml0dGVkKSB7XG4gICAgX2luaXRDb3JlKCk7XG5cbiAgICBpZiAoIUNTU1BsdWdpbikge1xuICAgICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luLCBDU1NSdWxlUGx1Z2luKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvcmVJbml0dGVkO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChfd2luZG93RXhpc3RzKCkpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgfVxuXG4gIGlmIChnc2FwKSB7XG4gICAgQ1NTUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmNzcztcblxuICAgIGlmIChDU1NQbHVnaW4pIHtcbiAgICAgIF9jb3JlSW5pdHRlZCA9IDE7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgdmFyIENTU1J1bGVQbHVnaW4gPSB7XG4gIHZlcnNpb246IFwiMy4xMS4yXCIsXG4gIG5hbWU6IFwiY3NzUnVsZVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIGlmICghX2NoZWNrUmVnaXN0ZXIoKSB8fCB0eXBlb2YgdGFyZ2V0LmNzc1RleHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZGl2ID0gdGFyZ2V0Ll9nc1Byb3h5ID0gdGFyZ2V0Ll9nc1Byb3h5IHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIHRoaXMuc3MgPSB0YXJnZXQ7XG4gICAgdGhpcy5zdHlsZSA9IGRpdi5zdHlsZTtcbiAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IHRhcmdldC5jc3NUZXh0O1xuICAgIENTU1BsdWdpbi5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGRpdiwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cyk7IC8vd2UganVzdCBvZmZsb2FkIGFsbCB0aGUgd29yayB0byB0aGUgcmVndWxhciBDU1NQbHVnaW4gYW5kIHRoZW4gY29weSB0aGUgY3NzVGV4dCBiYWNrIG92ZXIgdG8gdGhlIHJ1bGUgaW4gdGhlIHJlbmRlcigpIG1ldGhvZC4gVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBhbGwgb2YgdGhlIHVwZGF0ZXMgdG8gQ1NTUGx1Z2luIGF1dG9tYXRpY2FsbHkgZmxvdyB0aHJvdWdoIHRvIENTU1J1bGVQbHVnaW4gaW5zdGVhZCBvZiBoYXZpbmcgdG8gbWFpbnRhaW4gYm90aFxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICBzdHlsZSA9IGRhdGEuc3R5bGUsXG4gICAgICAgIHNzID0gZGF0YS5zcyxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIGkgPSBzdHlsZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgIHNzW3N0eWxlW2ldXSA9IHN0eWxlW3N0eWxlW2ldXTtcbiAgICB9XG4gIH0sXG4gIGdldFJ1bGU6IGZ1bmN0aW9uIGdldFJ1bGUoc2VsZWN0b3IpIHtcbiAgICBfY2hlY2tSZWdpc3RlcigpO1xuXG4gICAgdmFyIHJ1bGVQcm9wID0gX2RvYy5hbGwgPyBcInJ1bGVzXCIgOiBcImNzc1J1bGVzXCIsXG4gICAgICAgIHN0eWxlU2hlZXRzID0gX2RvYy5zdHlsZVNoZWV0cyxcbiAgICAgICAgaSA9IHN0eWxlU2hlZXRzLmxlbmd0aCxcbiAgICAgICAgcHNldWRvID0gc2VsZWN0b3IuY2hhckF0KDApID09PSBcIjpcIixcbiAgICAgICAgaixcbiAgICAgICAgY3VyU1MsXG4gICAgICAgIGNzLFxuICAgICAgICBhO1xuICAgIHNlbGVjdG9yID0gKHBzZXVkbyA/IFwiXCIgOiBcIixcIikgKyBzZWxlY3Rvci5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpLnRvTG93ZXJDYXNlKCkgKyBcIixcIjsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgcmVwb3J0IHRhZyBuYW1lIHNlbGVjdG9ycyBhcyB1cHBlciBjYXNlLCBzbyB3ZSBqdXN0IGNoYW5nZSBldmVyeXRoaW5nIHRvIGxvd2VyY2FzZS5cblxuICAgIGlmIChwc2V1ZG8pIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAvL0ZpcmVmb3ggbWF5IHRocm93IGluc2VjdXJlIG9wZXJhdGlvbiBlcnJvcnMgd2hlbiBjc3MgaXMgbG9hZGVkIGZyb20gb3RoZXIgZG9tYWlucywgc28gdHJ5L2NhdGNoLlxuICAgICAgdHJ5IHtcbiAgICAgICAgY3VyU1MgPSBzdHlsZVNoZWV0c1tpXVtydWxlUHJvcF07XG5cbiAgICAgICAgaWYgKCFjdXJTUykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaiA9IGN1clNTLmxlbmd0aDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKC0taiA+IC0xKSB7XG4gICAgICAgIGNzID0gY3VyU1Nbal07XG5cbiAgICAgICAgaWYgKGNzLnNlbGVjdG9yVGV4dCAmJiAoXCIsXCIgKyBjcy5zZWxlY3RvclRleHQuc3BsaXQoXCI6OlwiKS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpICsgXCIsXCIpLmluZGV4T2Yoc2VsZWN0b3IpICE9PSAtMSkge1xuICAgICAgICAgIC8vbm90ZTogSUUgYWRkcyBhbiBleHRyYSBcIjpcIiB0byBwc2V1ZG8gc2VsZWN0b3JzLCBzbyAubXlDbGFzczphZnRlciBiZWNvbWVzIC5teUNsYXNzOjphZnRlciwgc28gd2UgbmVlZCB0byBzdHJpcCB0aGUgZXh0cmEgb25lIG91dC5cbiAgICAgICAgICBpZiAocHNldWRvKSB7XG4gICAgICAgICAgICBhLnB1c2goY3Muc3R5bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3Muc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHJlZ2lzdGVyOiBfaW5pdENvcmVcbn07XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUnVsZVBsdWdpbik7XG5leHBvcnQgeyBDU1NSdWxlUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/CSSRulePlugin.js\n"));

/***/ }),

/***/ "./node_modules/gsap/CustomEase.js":
/*!*****************************************!*\
  !*** ./node_modules/gsap/CustomEase.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CustomEase\": function() { return /* binding */ CustomEase; },\n/* harmony export */   \"default\": function() { return /* binding */ CustomEase; }\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ \"./node_modules/gsap/utils/paths.js\");\n/*!\n * CustomEase 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar gsap,\n    _coreInitted,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (gsap) {\n    gsap.registerEase(\"_CE\", CustomEase.create);\n    _coreInitted = 1;\n  } else {\n    console.warn(\"Please gsap.registerPlugin(CustomEase)\");\n  }\n},\n    _bigNum = 1e20,\n    _round = function _round(value) {\n  return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;\n},\n    _bonusValidated = 1,\n    //<name>CustomEase</name>\n_numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_needsParsingExp = /[cLlsSaAhHvVtTqQ]/g,\n    _findMinimum = function _findMinimum(values) {\n  var l = values.length,\n      min = _bigNum,\n      i;\n\n  for (i = 1; i < l; i += 6) {\n    +values[i] < min && (min = +values[i]);\n  }\n\n  return min;\n},\n    //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.\n_normalize = function _normalize(values, height, originY) {\n  if (!originY && originY !== 0) {\n    originY = Math.max(+values[values.length - 1], +values[1]);\n  }\n\n  var tx = +values[0] * -1,\n      ty = -originY,\n      l = values.length,\n      sx = 1 / (+values[l - 2] + tx),\n      sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty),\n      i;\n\n  if (sy) {\n    //typically y ends at 1 (so that the end values are reached)\n    sy = 1 / sy;\n  } else {\n    //in case the ease returns to its beginning value, scale everything proportionally\n    sy = -sx;\n  }\n\n  for (i = 0; i < l; i += 2) {\n    values[i] = (+values[i] + tx) * sx;\n    values[i + 1] = (+values[i + 1] + ty) * sy;\n  }\n},\n    //note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js\n_bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n  var x12 = (x1 + x2) / 2,\n      y12 = (y1 + y2) / 2,\n      x23 = (x2 + x3) / 2,\n      y23 = (y2 + y3) / 2,\n      x34 = (x3 + x4) / 2,\n      y34 = (y3 + y4) / 2,\n      x123 = (x12 + x23) / 2,\n      y123 = (y12 + y23) / 2,\n      x234 = (x23 + x34) / 2,\n      y234 = (y23 + y34) / 2,\n      x1234 = (x123 + x234) / 2,\n      y1234 = (y123 + y234) / 2,\n      dx = x4 - x1,\n      dy = y4 - y1,\n      d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),\n      d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),\n      length;\n\n  if (!points) {\n    points = [{\n      x: x1,\n      y: y1\n    }, {\n      x: x4,\n      y: y4\n    }];\n    index = 1;\n  }\n\n  points.splice(index || points.length - 1, 0, {\n    x: x1234,\n    y: y1234\n  });\n\n  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n    length = points.length;\n\n    _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n\n    _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));\n  }\n\n  return points;\n};\n\nvar CustomEase = /*#__PURE__*/function () {\n  function CustomEase(id, data, config) {\n    _coreInitted || _initCore();\n    this.id = id;\n    _bonusValidated && this.setData(data, config);\n  }\n\n  var _proto = CustomEase.prototype;\n\n  _proto.setData = function setData(data, config) {\n    config = config || {};\n    data = data || \"0,0,1,1\";\n    var values = data.match(_numExp),\n        closest = 1,\n        points = [],\n        lookup = [],\n        precision = config.precision || 1,\n        fast = precision <= 1,\n        l,\n        a1,\n        a2,\n        i,\n        inc,\n        j,\n        point,\n        prevPoint,\n        p;\n    this.data = data;\n\n    if (_needsParsingExp.test(data) || ~data.indexOf(\"M\") && data.indexOf(\"C\") < 0) {\n      values = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(data)[0];\n    }\n\n    l = values.length;\n\n    if (l === 4) {\n      values.unshift(0, 0);\n      values.push(1, 1);\n      l = 8;\n    } else if ((l - 2) % 6) {\n      throw \"Invalid CustomEase\";\n    }\n\n    if (+values[0] !== 0 || +values[l - 2] !== 1) {\n      _normalize(values, config.height, config.originY);\n    }\n\n    this.segment = values;\n\n    for (i = 2; i < l; i += 6) {\n      a1 = {\n        x: +values[i - 2],\n        y: +values[i - 1]\n      };\n      a2 = {\n        x: +values[i + 4],\n        y: +values[i + 5]\n      };\n      points.push(a1, a2);\n\n      _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);\n    }\n\n    l = points.length;\n\n    for (i = 0; i < l; i++) {\n      point = points[i];\n      prevPoint = points[i - 1] || point;\n\n      if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {\n        //if a point goes BACKWARD in time or is a duplicate, just drop it. Also it shouldn't go past 1 on the x axis, as could happen in a string like \"M0,0 C0,0 0.12,0.68 0.18,0.788 0.195,0.845 0.308,1 0.32,1 0.403,1.005 0.398,1 0.5,1 0.602,1 0.816,1.005 0.9,1 0.91,1 0.948,0.69 0.962,0.615 1.003,0.376 1,0 1,0\".\n        prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)\n\n        prevPoint.cy = point.y - prevPoint.y;\n        prevPoint.n = point;\n        prevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)\n\n        if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {\n          //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.\n          fast = 0;\n        }\n\n        if (prevPoint.cx < closest) {\n          if (!prevPoint.cx) {\n            prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)\n\n            if (i === l - 1) {\n              //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.\n              prevPoint.x -= 0.001;\n              closest = Math.min(closest, 0.001);\n              fast = 0;\n            }\n          } else {\n            closest = prevPoint.cx;\n          }\n        }\n      } else {\n        points.splice(i--, 1);\n        l--;\n      }\n    }\n\n    l = 1 / closest + 1 | 0;\n    inc = 1 / l;\n    j = 0;\n    point = points[0];\n\n    if (fast) {\n      for (i = 0; i < l; i++) {\n        //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).\n        p = i * inc;\n\n        if (point.nx < p) {\n          point = points[++j];\n        }\n\n        a1 = point.y + (p - point.x) / point.cx * point.cy;\n        lookup[i] = {\n          x: p,\n          cx: inc,\n          y: a1,\n          cy: 0,\n          nx: 9\n        };\n\n        if (i) {\n          lookup[i - 1].cy = a1 - lookup[i - 1].y;\n        }\n      }\n\n      lookup[l - 1].cy = points[points.length - 1].y - a1;\n    } else {\n      //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.\n      for (i = 0; i < l; i++) {\n        //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]\n        if (point.nx < i * inc) {\n          point = points[++j];\n        }\n\n        lookup[i] = point;\n      }\n\n      if (j < points.length - 1) {\n        lookup[i - 1] = points[points.length - 2];\n      }\n    } //this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.\n\n\n    this.ease = function (p) {\n      var point = lookup[p * l | 0] || lookup[l - 1];\n\n      if (point.nx < p) {\n        point = point.n;\n      }\n\n      return point.y + (p - point.x) / point.cx * point.cy;\n    };\n\n    this.ease.custom = this;\n    this.id && gsap && gsap.registerEase(this.id, this.ease);\n    return this;\n  };\n\n  _proto.getSVGData = function getSVGData(config) {\n    return CustomEase.getSVGData(this, config);\n  };\n\n  CustomEase.create = function create(id, data, config) {\n    return new CustomEase(id, data, config).ease;\n  };\n\n  CustomEase.register = function register(core) {\n    gsap = core;\n\n    _initCore();\n  };\n\n  CustomEase.get = function get(id) {\n    return gsap.parseEase(id);\n  };\n\n  CustomEase.getSVGData = function getSVGData(ease, config) {\n    config = config || {};\n    var width = config.width || 100,\n        height = config.height || 100,\n        x = config.x || 0,\n        y = (config.y || 0) + height,\n        e = gsap.utils.toArray(config.path)[0],\n        a,\n        slope,\n        i,\n        inc,\n        tx,\n        ty,\n        precision,\n        threshold,\n        prevX,\n        prevY;\n\n    if (config.invert) {\n      height = -height;\n      y = 0;\n    }\n\n    if (typeof ease === \"string\") {\n      ease = gsap.parseEase(ease);\n    }\n\n    if (ease.custom) {\n      ease = ease.custom;\n    }\n\n    if (ease instanceof CustomEase) {\n      a = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)([ease.segment], width, 0, 0, -height, x, y));\n    } else {\n      a = [x, y];\n      precision = Math.max(5, (config.precision || 1) * 200);\n      inc = 1 / precision;\n      precision += 2;\n      threshold = 5 / precision;\n      prevX = _round(x + inc * width);\n      prevY = _round(y + ease(inc) * -height);\n      slope = (prevY - y) / (prevX - x);\n\n      for (i = 2; i < precision; i++) {\n        tx = _round(x + i * inc * width);\n        ty = _round(y + ease(i * inc) * -height);\n\n        if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {\n          //only add points when the slope changes beyond the threshold\n          a.push(prevX, prevY);\n          slope = (ty - prevY) / (tx - prevX);\n        }\n\n        prevX = tx;\n        prevY = ty;\n      }\n\n      a = \"M\" + a.join(\",\");\n    }\n\n    e && e.setAttribute(\"d\", a);\n    return a;\n  };\n\n  return CustomEase;\n}();\n_getGSAP() && gsap.registerPlugin(CustomEase);\nCustomEase.version = \"3.11.2\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9DdXN0b21FYXNlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnRUFBZTtBQUM5Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTs7O0FBR2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsZ0VBQWUsQ0FBQyxpRUFBZ0I7QUFDMUMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL0N1c3RvbUVhc2UuanM/YjA4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEN1c3RvbUVhc2UgMy4xMS4yXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgc3RyaW5nVG9SYXdQYXRoLCByYXdQYXRoVG9TdHJpbmcsIHRyYW5zZm9ybVJhd1BhdGggfSBmcm9tIFwiLi91dGlscy9wYXRocy5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKGdzYXApIHtcbiAgICBnc2FwLnJlZ2lzdGVyRWFzZShcIl9DRVwiLCBDdXN0b21FYXNlLmNyZWF0ZSk7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihDdXN0b21FYXNlKVwiKTtcbiAgfVxufSxcbiAgICBfYmlnTnVtID0gMWUyMCxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIH5+KHZhbHVlICogMTAwMCArICh2YWx1ZSA8IDAgPyAtLjUgOiAuNSkpIC8gMTAwMDtcbn0sXG4gICAgX2JvbnVzVmFsaWRhdGVkID0gMSxcbiAgICAvLzxuYW1lPkN1c3RvbUVhc2U8L25hbWU+XG5fbnVtRXhwID0gL1stKz1cXC5dKlxcZCtbXFwuZVxcLVxcK10qXFxkKltlXFwtXFwrXSpcXGQqL2dpLFxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5fbmVlZHNQYXJzaW5nRXhwID0gL1tjTGxzU2FBaEh2VnRUcVFdL2csXG4gICAgX2ZpbmRNaW5pbXVtID0gZnVuY3Rpb24gX2ZpbmRNaW5pbXVtKHZhbHVlcykge1xuICB2YXIgbCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgbDsgaSArPSA2KSB7XG4gICAgK3ZhbHVlc1tpXSA8IG1pbiAmJiAobWluID0gK3ZhbHVlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufSxcbiAgICAvL3Rha2VzIGFsbCB0aGUgcG9pbnRzIGFuZCB0cmFuc2xhdGVzL3NjYWxlcyB0aGVtIHNvIHRoYXQgdGhlIHggc3RhcnRzIGF0IDAgYW5kIGVuZHMgYXQgMS5cbl9ub3JtYWxpemUgPSBmdW5jdGlvbiBfbm9ybWFsaXplKHZhbHVlcywgaGVpZ2h0LCBvcmlnaW5ZKSB7XG4gIGlmICghb3JpZ2luWSAmJiBvcmlnaW5ZICE9PSAwKSB7XG4gICAgb3JpZ2luWSA9IE1hdGgubWF4KCt2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLCArdmFsdWVzWzFdKTtcbiAgfVxuXG4gIHZhciB0eCA9ICt2YWx1ZXNbMF0gKiAtMSxcbiAgICAgIHR5ID0gLW9yaWdpblksXG4gICAgICBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHN4ID0gMSAvICgrdmFsdWVzW2wgLSAyXSArIHR4KSxcbiAgICAgIHN5ID0gLWhlaWdodCB8fCAoTWF0aC5hYnMoK3ZhbHVlc1tsIC0gMV0gLSArdmFsdWVzWzFdKSA8IDAuMDEgKiAoK3ZhbHVlc1tsIC0gMl0gLSArdmFsdWVzWzBdKSA/IF9maW5kTWluaW11bSh2YWx1ZXMpICsgdHkgOiArdmFsdWVzW2wgLSAxXSArIHR5KSxcbiAgICAgIGk7XG5cbiAgaWYgKHN5KSB7XG4gICAgLy90eXBpY2FsbHkgeSBlbmRzIGF0IDEgKHNvIHRoYXQgdGhlIGVuZCB2YWx1ZXMgYXJlIHJlYWNoZWQpXG4gICAgc3kgPSAxIC8gc3k7XG4gIH0gZWxzZSB7XG4gICAgLy9pbiBjYXNlIHRoZSBlYXNlIHJldHVybnMgdG8gaXRzIGJlZ2lubmluZyB2YWx1ZSwgc2NhbGUgZXZlcnl0aGluZyBwcm9wb3J0aW9uYWxseVxuICAgIHN5ID0gLXN4O1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhbHVlc1tpXSA9ICgrdmFsdWVzW2ldICsgdHgpICogc3g7XG4gICAgdmFsdWVzW2kgKyAxXSA9ICgrdmFsdWVzW2kgKyAxXSArIHR5KSAqIHN5O1xuICB9XG59LFxuICAgIC8vbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBwb2ludCBvYmplY3RzIGxpa2Uge3gsIHl9IHJhdGhlciB0aGFuIHdvcmtpbmcgd2l0aCBzZWdtZW50cyB3aGljaCBhcmUgYXJyYXlzIHdpdGggYWx0ZXJuYXRpbmcgeCwgeSB2YWx1ZXMgYXMgaW4gdGhlIHNpbWlsYXIgZnVuY3Rpb24gaW4gcGF0aHMuanNcbl9iZXppZXJUb1BvaW50cyA9IGZ1bmN0aW9uIF9iZXppZXJUb1BvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCkge1xuICB2YXIgeDEyID0gKHgxICsgeDIpIC8gMixcbiAgICAgIHkxMiA9ICh5MSArIHkyKSAvIDIsXG4gICAgICB4MjMgPSAoeDIgKyB4MykgLyAyLFxuICAgICAgeTIzID0gKHkyICsgeTMpIC8gMixcbiAgICAgIHgzNCA9ICh4MyArIHg0KSAvIDIsXG4gICAgICB5MzQgPSAoeTMgKyB5NCkgLyAyLFxuICAgICAgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMixcbiAgICAgIHkxMjMgPSAoeTEyICsgeTIzKSAvIDIsXG4gICAgICB4MjM0ID0gKHgyMyArIHgzNCkgLyAyLFxuICAgICAgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMixcbiAgICAgIHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDIsXG4gICAgICB5MTIzNCA9ICh5MTIzICsgeTIzNCkgLyAyLFxuICAgICAgZHggPSB4NCAtIHgxLFxuICAgICAgZHkgPSB5NCAtIHkxLFxuICAgICAgZDIgPSBNYXRoLmFicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KSxcbiAgICAgIGQzID0gTWF0aC5hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeCksXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKCFwb2ludHMpIHtcbiAgICBwb2ludHMgPSBbe1xuICAgICAgeDogeDEsXG4gICAgICB5OiB5MVxuICAgIH0sIHtcbiAgICAgIHg6IHg0LFxuICAgICAgeTogeTRcbiAgICB9XTtcbiAgICBpbmRleCA9IDE7XG4gIH1cblxuICBwb2ludHMuc3BsaWNlKGluZGV4IHx8IHBvaW50cy5sZW5ndGggLSAxLCAwLCB7XG4gICAgeDogeDEyMzQsXG4gICAgeTogeTEyMzRcbiAgfSk7XG5cbiAgaWYgKChkMiArIGQzKSAqIChkMiArIGQzKSA+IHRocmVzaG9sZCAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgX2JlemllclRvUG9pbnRzKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KTtcblxuICAgIF9iZXppZXJUb1BvaW50cyh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCArIDEgKyAocG9pbnRzLmxlbmd0aCAtIGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbmV4cG9ydCB2YXIgQ3VzdG9tRWFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbUVhc2UoaWQsIGRhdGEsIGNvbmZpZykge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgX2JvbnVzVmFsaWRhdGVkICYmIHRoaXMuc2V0RGF0YShkYXRhLCBjb25maWcpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEN1c3RvbUVhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShkYXRhLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgZGF0YSA9IGRhdGEgfHwgXCIwLDAsMSwxXCI7XG4gICAgdmFyIHZhbHVlcyA9IGRhdGEubWF0Y2goX251bUV4cCksXG4gICAgICAgIGNsb3Nlc3QgPSAxLFxuICAgICAgICBwb2ludHMgPSBbXSxcbiAgICAgICAgbG9va3VwID0gW10sXG4gICAgICAgIHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb24gfHwgMSxcbiAgICAgICAgZmFzdCA9IHByZWNpc2lvbiA8PSAxLFxuICAgICAgICBsLFxuICAgICAgICBhMSxcbiAgICAgICAgYTIsXG4gICAgICAgIGksXG4gICAgICAgIGluYyxcbiAgICAgICAgaixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHByZXZQb2ludCxcbiAgICAgICAgcDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKF9uZWVkc1BhcnNpbmdFeHAudGVzdChkYXRhKSB8fCB+ZGF0YS5pbmRleE9mKFwiTVwiKSAmJiBkYXRhLmluZGV4T2YoXCJDXCIpIDwgMCkge1xuICAgICAgdmFsdWVzID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpWzBdO1xuICAgIH1cblxuICAgIGwgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgaWYgKGwgPT09IDQpIHtcbiAgICAgIHZhbHVlcy51bnNoaWZ0KDAsIDApO1xuICAgICAgdmFsdWVzLnB1c2goMSwgMSk7XG4gICAgICBsID0gODtcbiAgICB9IGVsc2UgaWYgKChsIC0gMikgJSA2KSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgQ3VzdG9tRWFzZVwiO1xuICAgIH1cblxuICAgIGlmICgrdmFsdWVzWzBdICE9PSAwIHx8ICt2YWx1ZXNbbCAtIDJdICE9PSAxKSB7XG4gICAgICBfbm9ybWFsaXplKHZhbHVlcywgY29uZmlnLmhlaWdodCwgY29uZmlnLm9yaWdpblkpO1xuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudCA9IHZhbHVlcztcblxuICAgIGZvciAoaSA9IDI7IGkgPCBsOyBpICs9IDYpIHtcbiAgICAgIGExID0ge1xuICAgICAgICB4OiArdmFsdWVzW2kgLSAyXSxcbiAgICAgICAgeTogK3ZhbHVlc1tpIC0gMV1cbiAgICAgIH07XG4gICAgICBhMiA9IHtcbiAgICAgICAgeDogK3ZhbHVlc1tpICsgNF0sXG4gICAgICAgIHk6ICt2YWx1ZXNbaSArIDVdXG4gICAgICB9O1xuICAgICAgcG9pbnRzLnB1c2goYTEsIGEyKTtcblxuICAgICAgX2JlemllclRvUG9pbnRzKGExLngsIGExLnksICt2YWx1ZXNbaV0sICt2YWx1ZXNbaSArIDFdLCArdmFsdWVzW2kgKyAyXSwgK3ZhbHVlc1tpICsgM10sIGEyLngsIGEyLnksIDEgLyAocHJlY2lzaW9uICogMjAwMDAwKSwgcG9pbnRzLCBwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV0gfHwgcG9pbnQ7XG5cbiAgICAgIGlmICgocG9pbnQueCA+IHByZXZQb2ludC54IHx8IHByZXZQb2ludC55ICE9PSBwb2ludC55ICYmIHByZXZQb2ludC54ID09PSBwb2ludC54IHx8IHBvaW50ID09PSBwcmV2UG9pbnQpICYmIHBvaW50LnggPD0gMSkge1xuICAgICAgICAvL2lmIGEgcG9pbnQgZ29lcyBCQUNLV0FSRCBpbiB0aW1lIG9yIGlzIGEgZHVwbGljYXRlLCBqdXN0IGRyb3AgaXQuIEFsc28gaXQgc2hvdWxkbid0IGdvIHBhc3QgMSBvbiB0aGUgeCBheGlzLCBhcyBjb3VsZCBoYXBwZW4gaW4gYSBzdHJpbmcgbGlrZSBcIk0wLDAgQzAsMCAwLjEyLDAuNjggMC4xOCwwLjc4OCAwLjE5NSwwLjg0NSAwLjMwOCwxIDAuMzIsMSAwLjQwMywxLjAwNSAwLjM5OCwxIDAuNSwxIDAuNjAyLDEgMC44MTYsMS4wMDUgMC45LDEgMC45MSwxIDAuOTQ4LDAuNjkgMC45NjIsMC42MTUgMS4wMDMsMC4zNzYgMSwwIDEsMFwiLlxuICAgICAgICBwcmV2UG9pbnQuY3ggPSBwb2ludC54IC0gcHJldlBvaW50Lng7IC8vY2hhbmdlIGluIHggYmV0d2VlbiB0aGlzIHBvaW50IGFuZCB0aGUgbmV4dCBwb2ludCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXG4gICAgICAgIHByZXZQb2ludC5jeSA9IHBvaW50LnkgLSBwcmV2UG9pbnQueTtcbiAgICAgICAgcHJldlBvaW50Lm4gPSBwb2ludDtcbiAgICAgICAgcHJldlBvaW50Lm54ID0gcG9pbnQueDsgLy9uZXh0IHBvaW50J3MgeCB2YWx1ZSAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBtYWtpbmcgbG9va3VwcyBmYXN0ZXIgaW4gZ2V0UmF0aW8oKSkuIFJlbWVtYmVyLCB0aGUgbG9va3VwIHdpbGwgYWx3YXlzIGxhbmQgb24gYSBzcG90IHdoZXJlIGl0J3MgZWl0aGVyIHRoaXMgcG9pbnQgb3IgdGhlIHZlcnkgbmV4dCBvbmUgKG5ldmVyIGJleW9uZCB0aGF0KVxuXG4gICAgICAgIGlmIChmYXN0ICYmIGkgPiAxICYmIE1hdGguYWJzKHByZXZQb2ludC5jeSAvIHByZXZQb2ludC5jeCAtIHBvaW50c1tpIC0gMl0uY3kgLyBwb2ludHNbaSAtIDJdLmN4KSA+IDIpIHtcbiAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSBzdWRkZW4gY2hhbmdlIGluIGRpcmVjdGlvbiwgcHJpb3JpdGl6ZSBhY2N1cmFjeSBvdmVyIHNwZWVkLiBMaWtlIGEgYm91bmNlIGVhc2UgLSB5b3UgZG9uJ3Qgd2FudCB0byByaXNrIHRoZSBzYW1wbGluZyBjaHVua3MgbGFuZGluZyBvbiBlYWNoIHNpZGUgb2YgdGhlIGJvdW5jZSBhbmNob3IgYW5kIGhhdmluZyBpdCBjbGlwcGVkIG9mZi5cbiAgICAgICAgICBmYXN0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2UG9pbnQuY3ggPCBjbG9zZXN0KSB7XG4gICAgICAgICAgaWYgKCFwcmV2UG9pbnQuY3gpIHtcbiAgICAgICAgICAgIHByZXZQb2ludC5jeCA9IDAuMDAxOyAvL2F2b2lkcyBtYXRoIHByb2JsZW1zIGluIGdldFJhdGlvKCkgKGRpdmlkaW5nIGJ5IHplcm8pXG5cbiAgICAgICAgICAgIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgdGhlIGZpbmFsIHNlZ21lbnQgZ29lcyB2ZXJ0aWNhbCBSSUdIVCBhdCB0aGUgZW5kLCBtYWtlIHN1cmUgd2UgZW5kIGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAgIHByZXZQb2ludC54IC09IDAuMDAxO1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gTWF0aC5taW4oY2xvc2VzdCwgMC4wMDEpO1xuICAgICAgICAgICAgICBmYXN0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VzdCA9IHByZXZQb2ludC5jeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgbC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGwgPSAxIC8gY2xvc2VzdCArIDEgfCAwO1xuICAgIGluYyA9IDEgLyBsO1xuICAgIGogPSAwO1xuICAgIHBvaW50ID0gcG9pbnRzWzBdO1xuXG4gICAgaWYgKGZhc3QpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy9mb3IgZmFzdGVzdCBsb29rdXBzLCB3ZSBqdXN0IHNhbXBsZSBhbG9uZyB0aGUgcGF0aCBhdCBlcXVhbCB4ICh0aW1lKSBkaXN0YW5jZS4gVXNlcyBtb3JlIG1lbW9yeSBhbmQgaXMgc2xpZ2h0bHkgbGVzcyBhY2N1cmF0ZSBmb3IgYW5jaG9ycyB0aGF0IGRvbid0IGxhbmQgb24gdGhlIHNhbXBsaW5nIHBvaW50cywgYnV0IGZvciB0aGUgdmFzdCBtYWpvcml0eSBvZiBlYXNlcyBpdCdzIGV4Y2VsbGVudCAoYW5kIGZhc3QpLlxuICAgICAgICBwID0gaSAqIGluYztcblxuICAgICAgICBpZiAocG9pbnQubnggPCBwKSB7XG4gICAgICAgICAgcG9pbnQgPSBwb2ludHNbKytqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGExID0gcG9pbnQueSArIChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCAqIHBvaW50LmN5O1xuICAgICAgICBsb29rdXBbaV0gPSB7XG4gICAgICAgICAgeDogcCxcbiAgICAgICAgICBjeDogaW5jLFxuICAgICAgICAgIHk6IGExLFxuICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgIG54OiA5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBsb29rdXBbaSAtIDFdLmN5ID0gYTEgLSBsb29rdXBbaSAtIDFdLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbG9va3VwW2wgLSAxXS5jeSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0ueSAtIGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RoaXMgb3B0aW9uIGlzIG1vcmUgYWNjdXJhdGUsIGVuc3VyaW5nIHRoYXQgRVZFUlkgYW5jaG9yIGlzIGhpdCBwZXJmZWN0bHkuIENsaXBwaW5nIGFjcm9zcyBhIGJvdW5jZSwgZm9yIGV4YW1wbGUsIHdvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy9idWlsZCBhIGxvb2t1cCB0YWJsZSBiYXNlZCBvbiB0aGUgc21hbGxlc3QgZGlzdGFuY2Ugc28gdGhhdCB3ZSBjYW4gaW5zdGFudGx5IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHBvaW50ICh3ZWxsLCBpdCdsbCBlaXRoZXIgYmUgdGhhdCBwb2ludCBvciB0aGUgdmVyeSBuZXh0IG9uZSkuIFdlJ2xsIGxvb2sgdXAgYmFzZWQgb24gdGhlIGxpbmVhciBwcm9ncmVzcy4gU28gaXQncyBpdCdzIDAuNSBhbmQgdGhlIGxvb2t1cCB0YWJsZSBoYXMgMTAwIGVsZW1lbnRzLCBpdCdkIGJlIGxpa2UgbG9va3VwW01hdGguZmxvb3IoMC41ICogMTAwKV1cbiAgICAgICAgaWYgKHBvaW50Lm54IDwgaSAqIGluYykge1xuICAgICAgICAgIHBvaW50ID0gcG9pbnRzWysral07XG4gICAgICAgIH1cblxuICAgICAgICBsb29rdXBbaV0gPSBwb2ludDtcbiAgICAgIH1cblxuICAgICAgaWYgKGogPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBsb29rdXBbaSAtIDFdID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgIH1cbiAgICB9IC8vdGhpcy5fY2FsY0VuZCA9IChwb2ludHNbcG9pbnRzLmxlbmd0aC0xXS55ICE9PSAxIHx8IHBvaW50c1swXS55ICE9PSAwKTsgLy9lbnN1cmVzIHRoYXQgd2UgZG9uJ3QgcnVuIGludG8gZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiBBcyBsb25nIGFzIHdlJ3JlIHN0YXJ0aW5nIGF0IDAgYW5kIGVuZGluZyBhdCAxLCB0ZWxsIEdTQVAgdG8gc2tpcCB0aGUgZmluYWwgY2FsY3VsYXRpb24gYW5kIHVzZSAwLzEgYXMgdGhlIGZhY3Rvci5cblxuXG4gICAgdGhpcy5lYXNlID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIHZhciBwb2ludCA9IGxvb2t1cFtwICogbCB8IDBdIHx8IGxvb2t1cFtsIC0gMV07XG5cbiAgICAgIGlmIChwb2ludC5ueCA8IHApIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludC5uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQueSArIChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCAqIHBvaW50LmN5O1xuICAgIH07XG5cbiAgICB0aGlzLmVhc2UuY3VzdG9tID0gdGhpcztcbiAgICB0aGlzLmlkICYmIGdzYXAgJiYgZ3NhcC5yZWdpc3RlckVhc2UodGhpcy5pZCwgdGhpcy5lYXNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0U1ZHRGF0YSA9IGZ1bmN0aW9uIGdldFNWR0RhdGEoY29uZmlnKSB7XG4gICAgcmV0dXJuIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSh0aGlzLCBjb25maWcpO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGlkLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUVhc2UoaWQsIGRhdGEsIGNvbmZpZykuZWFzZTtcbiAgfTtcblxuICBDdXN0b21FYXNlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH07XG5cbiAgQ3VzdG9tRWFzZS5nZXQgPSBmdW5jdGlvbiBnZXQoaWQpIHtcbiAgICByZXR1cm4gZ3NhcC5wYXJzZUVhc2UoaWQpO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSA9IGZ1bmN0aW9uIGdldFNWR0RhdGEoZWFzZSwgY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxMDAsXG4gICAgICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQgfHwgMTAwLFxuICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgeSA9IChjb25maWcueSB8fCAwKSArIGhlaWdodCxcbiAgICAgICAgZSA9IGdzYXAudXRpbHMudG9BcnJheShjb25maWcucGF0aClbMF0sXG4gICAgICAgIGEsXG4gICAgICAgIHNsb3BlLFxuICAgICAgICBpLFxuICAgICAgICBpbmMsXG4gICAgICAgIHR4LFxuICAgICAgICB0eSxcbiAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIHByZXZYLFxuICAgICAgICBwcmV2WTtcblxuICAgIGlmIChjb25maWcuaW52ZXJ0KSB7XG4gICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgeSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlYXNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBlYXNlID0gZ3NhcC5wYXJzZUVhc2UoZWFzZSk7XG4gICAgfVxuXG4gICAgaWYgKGVhc2UuY3VzdG9tKSB7XG4gICAgICBlYXNlID0gZWFzZS5jdXN0b207XG4gICAgfVxuXG4gICAgaWYgKGVhc2UgaW5zdGFuY2VvZiBDdXN0b21FYXNlKSB7XG4gICAgICBhID0gcmF3UGF0aFRvU3RyaW5nKHRyYW5zZm9ybVJhd1BhdGgoW2Vhc2Uuc2VnbWVudF0sIHdpZHRoLCAwLCAwLCAtaGVpZ2h0LCB4LCB5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBbeCwgeV07XG4gICAgICBwcmVjaXNpb24gPSBNYXRoLm1heCg1LCAoY29uZmlnLnByZWNpc2lvbiB8fCAxKSAqIDIwMCk7XG4gICAgICBpbmMgPSAxIC8gcHJlY2lzaW9uO1xuICAgICAgcHJlY2lzaW9uICs9IDI7XG4gICAgICB0aHJlc2hvbGQgPSA1IC8gcHJlY2lzaW9uO1xuICAgICAgcHJldlggPSBfcm91bmQoeCArIGluYyAqIHdpZHRoKTtcbiAgICAgIHByZXZZID0gX3JvdW5kKHkgKyBlYXNlKGluYykgKiAtaGVpZ2h0KTtcbiAgICAgIHNsb3BlID0gKHByZXZZIC0geSkgLyAocHJldlggLSB4KTtcblxuICAgICAgZm9yIChpID0gMjsgaSA8IHByZWNpc2lvbjsgaSsrKSB7XG4gICAgICAgIHR4ID0gX3JvdW5kKHggKyBpICogaW5jICogd2lkdGgpO1xuICAgICAgICB0eSA9IF9yb3VuZCh5ICsgZWFzZShpICogaW5jKSAqIC1oZWlnaHQpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicygodHkgLSBwcmV2WSkgLyAodHggLSBwcmV2WCkgLSBzbG9wZSkgPiB0aHJlc2hvbGQgfHwgaSA9PT0gcHJlY2lzaW9uIC0gMSkge1xuICAgICAgICAgIC8vb25seSBhZGQgcG9pbnRzIHdoZW4gdGhlIHNsb3BlIGNoYW5nZXMgYmV5b25kIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICBhLnB1c2gocHJldlgsIHByZXZZKTtcbiAgICAgICAgICBzbG9wZSA9ICh0eSAtIHByZXZZKSAvICh0eCAtIHByZXZYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZYID0gdHg7XG4gICAgICAgIHByZXZZID0gdHk7XG4gICAgICB9XG5cbiAgICAgIGEgPSBcIk1cIiArIGEuam9pbihcIixcIik7XG4gICAgfVxuXG4gICAgZSAmJiBlLnNldEF0dHJpYnV0ZShcImRcIiwgYSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUVhc2U7XG59KCk7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ3VzdG9tRWFzZSk7XG5DdXN0b21FYXNlLnZlcnNpb24gPSBcIjMuMTEuMlwiO1xuZXhwb3J0IHsgQ3VzdG9tRWFzZSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/CustomEase.js\n"));

/***/ }),

/***/ "./node_modules/gsap/Draggable.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/Draggable.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draggable\": function() { return /* binding */ Draggable; },\n/* harmony export */   \"default\": function() { return /* binding */ Draggable; }\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"./node_modules/gsap/utils/matrix.js\");\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/*!\n * Draggable 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n */\n\n/* eslint-disable */\n\n\nvar gsap,\n    _win,\n    _doc,\n    _docElement,\n    _body,\n    _tempDiv,\n    _placeholderDiv,\n    _coreInitted,\n    _checkPrefix,\n    _toArray,\n    _supportsPassive,\n    _isTouchDevice,\n    _touchEventLookup,\n    _isMultiTouching,\n    _isAndroid,\n    InertiaPlugin,\n    _defaultCursor,\n    _supportsPointer,\n    _dragCount = 0,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === \"undefined\";\n},\n    _emptyFunc = function _emptyFunc() {\n  return false;\n},\n    _transformProp = \"transform\",\n    _transformOriginProp = \"transformOrigin\",\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _isArray = Array.isArray,\n    _createElement = function _createElement(type, ns) {\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n\n  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _RAD2DEG = 180 / Math.PI,\n    _bigNum = 1e20,\n    _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(),\n    _getTime = Date.now || function () {\n  return new Date().getTime();\n},\n    _renderQueue = [],\n    _lookup = {},\n    //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.\n_lookupCount = 0,\n    _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,\n    _lastDragTime = 0,\n    _temp1 = {},\n    // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.\n_windowProxy = {},\n    //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.\n_copy = function _copy(obj, factor) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    copy[p] = factor ? obj[p] * factor : obj[p];\n  }\n\n  return copy;\n},\n    _extend = function _extend(obj, defaults) {\n  for (var p in defaults) {\n    if (!(p in obj)) {\n      obj[p] = defaults[p];\n    }\n  }\n\n  return obj;\n},\n    _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {\n  var i = elements.length,\n      children;\n\n  while (i--) {\n    value ? elements[i].style.touchAction = value : elements[i].style.removeProperty(\"touch-action\");\n    children = elements[i].children;\n    children && children.length && _setTouchActionForAllDescendants(children, value);\n  }\n},\n    _renderQueueTick = function _renderQueueTick() {\n  return _renderQueue.forEach(function (func) {\n    return func();\n  });\n},\n    _addToRenderQueue = function _addToRenderQueue(func) {\n  _renderQueue.push(func);\n\n  if (_renderQueue.length === 1) {\n    gsap.ticker.add(_renderQueueTick);\n  }\n},\n    _renderQueueTimeout = function _renderQueueTimeout() {\n  return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);\n},\n    _removeFromRenderQueue = function _removeFromRenderQueue(func) {\n  var i = _renderQueue.length;\n\n  while (i--) {\n    if (_renderQueue[i] === func) {\n      _renderQueue.splice(i, 1);\n    }\n  }\n\n  gsap.to(_renderQueueTimeout, {\n    overwrite: true,\n    delay: 15,\n    duration: 0,\n    onComplete: _renderQueueTimeout,\n    data: \"_draggable\"\n  }); //remove the \"tick\" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    if (!(p in obj)) {\n      obj[p] = defaults[p];\n    }\n  }\n\n  return obj;\n},\n    _addListener = function _addListener(element, type, func, capture) {\n  if (element.addEventListener) {\n    var touchType = _touchEventLookup[type];\n    capture = capture || (_supportsPassive ? {\n      passive: false\n    } : null);\n    element.addEventListener(touchType || type, func, capture);\n    touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.\n  }\n},\n    _removeListener = function _removeListener(element, type, func) {\n  if (element.removeEventListener) {\n    var touchType = _touchEventLookup[type];\n    element.removeEventListener(touchType || type, func);\n    touchType && type !== touchType && element.removeEventListener(type, func);\n  }\n},\n    _preventDefault = function _preventDefault(event) {\n  event.preventDefault && event.preventDefault();\n  event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers\n},\n    _hasTouchID = function _hasTouchID(list, ID) {\n  var i = list.length;\n\n  while (i--) {\n    if (list[i].identifier === ID) {\n      return true;\n    }\n  }\n},\n    _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {\n  _isMultiTouching = event.touches && _dragCount < event.touches.length;\n\n  _removeListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n},\n    _onMultiTouchDocument = function _onMultiTouchDocument(event) {\n  _isMultiTouching = event.touches && _dragCount < event.touches.length;\n\n  _addListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n},\n    _getDocScrollTop = function _getDocScrollTop(doc) {\n  return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;\n},\n    _getDocScrollLeft = function _getDocScrollLeft(doc) {\n  return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;\n},\n    _addScrollListener = function _addScrollListener(e, callback) {\n  _addListener(e, \"scroll\", callback);\n\n  if (!_isRoot(e.parentNode)) {\n    _addScrollListener(e.parentNode, callback);\n  }\n},\n    _removeScrollListener = function _removeScrollListener(e, callback) {\n  _removeListener(e, \"scroll\", callback);\n\n  if (!_isRoot(e.parentNode)) {\n    _removeScrollListener(e.parentNode, callback);\n  }\n},\n    _isRoot = function _isRoot(e) {\n  return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);\n},\n    _getMaxScroll = function _getMaxScroll(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim;\n  return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win[\"inner\" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);\n},\n    _recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {\n  //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.\n  var x = _getMaxScroll(e, \"x\"),\n      y = _getMaxScroll(e, \"y\");\n\n  if (_isRoot(e)) {\n    e = _windowProxy;\n  } else {\n    _recordMaxScrolls(e.parentNode, skipCurrent);\n  }\n\n  e._gsMaxScrollX = x;\n  e._gsMaxScrollY = y;\n\n  if (!skipCurrent) {\n    e._gsScrollX = e.scrollLeft || 0;\n    e._gsScrollY = e.scrollTop || 0;\n  }\n},\n    _setStyle = function _setStyle(element, property, value) {\n  var style = element.style;\n\n  if (!style) {\n    return;\n  }\n\n  if (_isUndefined(style[property])) {\n    property = _checkPrefix(property, element) || property;\n  }\n\n  if (value == null) {\n    style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n  } else {\n    style[property] = value;\n  }\n},\n    _getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);\n},\n    //the \"host\" stuff helps to accommodate ShadowDom objects.\n_tempRect = {},\n    //reuse to reduce garbage collection tasks\n_parseRect = function _parseRect(e) {\n  //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties\n  if (e === _win) {\n    _tempRect.left = _tempRect.top = 0;\n    _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;\n    _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;\n    return _tempRect;\n  }\n\n  var doc = e.ownerDocument || _doc,\n      r = !_isUndefined(e.pageX) ? {\n    left: e.pageX - _getDocScrollLeft(doc),\n    top: e.pageY - _getDocScrollTop(doc),\n    right: e.pageX - _getDocScrollLeft(doc) + 1,\n    bottom: e.pageY - _getDocScrollTop(doc) + 1\n  } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();\n\n  if (_isUndefined(r.right) && !_isUndefined(r.width)) {\n    r.right = r.left + r.width;\n    r.bottom = r.top + r.height;\n  } else if (_isUndefined(r.width)) {\n    //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.\n    r = {\n      width: r.right - r.left,\n      height: r.bottom - r.top,\n      right: r.right,\n      left: r.left,\n      bottom: r.bottom,\n      top: r.top\n    };\n  }\n\n  return r;\n},\n    _dispatchEvent = function _dispatchEvent(target, type, callbackName) {\n  var vars = target.vars,\n      callback = vars[callbackName],\n      listeners = target._listeners[type],\n      result;\n\n  if (_isFunction(callback)) {\n    result = callback.apply(vars.callbackScope || target, vars[callbackName + \"Params\"] || [target.pointerEvent]);\n  }\n\n  if (listeners && target.dispatchEvent(type) === false) {\n    result = false;\n  }\n\n  return result;\n},\n    _getBounds = function _getBounds(target, context) {\n  //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.\n  var e = _toArray(target)[0],\n      top,\n      left,\n      offset;\n\n  if (!e.nodeType && e !== _win) {\n    if (!_isUndefined(target.left)) {\n      offset = {\n        x: 0,\n        y: 0\n      }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin\n\n      return {\n        left: target.left - offset.x,\n        top: target.top - offset.y,\n        width: target.width,\n        height: target.height\n      };\n    }\n\n    left = target.min || target.minX || target.minRotation || 0;\n    top = target.min || target.minY || 0;\n    return {\n      left: left,\n      top: top,\n      width: (target.max || target.maxX || target.maxRotation || 0) - left,\n      height: (target.max || target.maxY || 0) - top\n    };\n  }\n\n  return _getElementBounds(e, context);\n},\n    _point1 = {},\n    //we reuse to minimize garbage collection tasks.\n_getElementBounds = function _getElementBounds(element, context) {\n  context = _toArray(context)[0];\n  var isSVG = element.getBBox && element.ownerSVGElement,\n      doc = element.ownerDocument || _doc,\n      left,\n      right,\n      top,\n      bottom,\n      matrix,\n      p1,\n      p2,\n      p3,\n      p4,\n      bbox,\n      width,\n      height,\n      cs;\n\n  if (element === _win) {\n    top = _getDocScrollTop(doc);\n    left = _getDocScrollLeft(doc);\n    right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);\n    bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.\n  } else if (context === _win || _isUndefined(context)) {\n    return element.getBoundingClientRect();\n  } else {\n    left = top = 0;\n\n    if (isSVG) {\n      bbox = element.getBBox();\n      width = bbox.width;\n      height = bbox.height;\n    } else {\n      if (element.viewBox && (bbox = element.viewBox.baseVal)) {\n        left = bbox.x || 0;\n        top = bbox.y || 0;\n        width = bbox.width;\n        height = bbox.height;\n      }\n\n      if (!width) {\n        cs = _getComputedStyle(element);\n        bbox = cs.boxSizing === \"border-box\";\n        width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));\n        height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));\n      }\n    }\n\n    right = width;\n    bottom = height;\n  }\n\n  if (element === context) {\n    return {\n      left: left,\n      top: top,\n      width: right - left,\n      height: bottom - top\n    };\n  }\n\n  matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));\n  p1 = matrix.apply({\n    x: left,\n    y: top\n  });\n  p2 = matrix.apply({\n    x: right,\n    y: top\n  });\n  p3 = matrix.apply({\n    x: right,\n    y: bottom\n  });\n  p4 = matrix.apply({\n    x: left,\n    y: bottom\n  });\n  left = Math.min(p1.x, p2.x, p3.x, p4.x);\n  top = Math.min(p1.y, p2.y, p3.y, p4.y);\n  return {\n    left: left,\n    top: top,\n    width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,\n    height: Math.max(p1.y, p2.y, p3.y, p4.y) - top\n  };\n},\n    _parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {\n  var vars = {},\n      a,\n      i,\n      l;\n\n  if (snap) {\n    if (factor !== 1 && snap instanceof Array) {\n      //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.\n      vars.end = a = [];\n      l = snap.length;\n\n      if (_isObject(snap[0])) {\n        //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.\n        for (i = 0; i < l; i++) {\n          a[i] = _copy(snap[i], factor);\n        }\n      } else {\n        for (i = 0; i < l; i++) {\n          a[i] = snap[i] * factor;\n        }\n      }\n\n      max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if \"snap:[-$('#menu').width(), 0]\" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.\n\n      min -= 1.1;\n    } else if (_isFunction(snap)) {\n      vars.end = function (value) {\n        var result = snap.call(draggable, value),\n            copy,\n            p;\n\n        if (factor !== 1) {\n          if (_isObject(result)) {\n            copy = {};\n\n            for (p in result) {\n              copy[p] = result[p] * factor;\n            }\n\n            result = copy;\n          } else {\n            result *= factor;\n          }\n        }\n\n        return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.\n      };\n    } else {\n      vars.end = snap;\n    }\n  }\n\n  if (max || max === 0) {\n    vars.max = max;\n  }\n\n  if (min || min === 0) {\n    vars.min = min;\n  }\n\n  if (forceZeroVelocity) {\n    vars.velocity = 0;\n  }\n\n  return vars;\n},\n    _isClickable = function _isClickable(element) {\n  //sometimes it's convenient to mark an element as clickable by adding a data-clickable=\"true\" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).\n  var data;\n  return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute(\"data-clickable\")) === \"true\" || data !== \"false\" && (element.onclick || _clickableTagExp.test(element.nodeName + \"\") || element.getAttribute(\"contentEditable\") === \"true\") ? true : _isClickable(element.parentNode);\n},\n    _setSelectable = function _setSelectable(elements, selectable) {\n  var i = elements.length,\n      e;\n\n  while (i--) {\n    e = elements[i];\n    e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;\n    gsap.set(e, {\n      lazy: true,\n      userSelect: selectable ? \"text\" : \"none\"\n    });\n  }\n},\n    _isFixed = function _isFixed(element) {\n  if (_getComputedStyle(element).position === \"fixed\") {\n    return true;\n  }\n\n  element = element.parentNode;\n\n  if (element && element.nodeType === 1) {\n    // avoid document fragments which will throw an error.\n    return _isFixed(element);\n  }\n},\n    _supports3D,\n    _addPaddingBR,\n    //The ScrollProxy class wraps an element's contents into another div (we call it \"content\") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.\nScrollProxy = function ScrollProxy(element, vars) {\n  element = gsap.utils.toArray(element)[0];\n  vars = vars || {};\n  var content = document.createElement(\"div\"),\n      style = content.style,\n      node = element.firstChild,\n      offsetTop = 0,\n      offsetLeft = 0,\n      prevTop = element.scrollTop,\n      prevLeft = element.scrollLeft,\n      scrollWidth = element.scrollWidth,\n      scrollHeight = element.scrollHeight,\n      extraPadRight = 0,\n      maxLeft = 0,\n      maxTop = 0,\n      elementWidth,\n      elementHeight,\n      contentHeight,\n      nextNode,\n      transformStart,\n      transformEnd;\n\n  if (_supports3D && vars.force3D !== false) {\n    transformStart = \"translate3d(\";\n    transformEnd = \"px,0px)\";\n  } else if (_transformProp) {\n    transformStart = \"translate(\";\n    transformEnd = \"px)\";\n  }\n\n  this.scrollTop = function (value, force) {\n    if (!arguments.length) {\n      return -this.top();\n    }\n\n    this.top(-value, force);\n  };\n\n  this.scrollLeft = function (value, force) {\n    if (!arguments.length) {\n      return -this.left();\n    }\n\n    this.left(-value, force);\n  };\n\n  this.left = function (value, force) {\n    if (!arguments.length) {\n      return -(element.scrollLeft + offsetLeft);\n    }\n\n    var dif = element.scrollLeft - prevLeft,\n        oldOffset = offsetLeft;\n\n    if ((dif > 2 || dif < -2) && !force) {\n      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n      prevLeft = element.scrollLeft;\n      gsap.killTweensOf(this, {\n        left: 1,\n        scrollLeft: 1\n      });\n      this.left(-prevLeft);\n\n      if (vars.onKill) {\n        vars.onKill();\n      }\n\n      return;\n    }\n\n    value = -value; //invert because scrolling works in the opposite direction\n\n    if (value < 0) {\n      offsetLeft = value - 0.5 | 0;\n      value = 0;\n    } else if (value > maxLeft) {\n      offsetLeft = value - maxLeft | 0;\n      value = maxLeft;\n    } else {\n      offsetLeft = 0;\n    }\n\n    if (offsetLeft || oldOffset) {\n      if (!this._skip) {\n        style[_transformProp] = transformStart + -offsetLeft + \"px,\" + -offsetTop + transformEnd;\n      }\n\n      if (offsetLeft + extraPadRight >= 0) {\n        style.paddingRight = offsetLeft + extraPadRight + \"px\";\n      }\n    }\n\n    element.scrollLeft = value | 0;\n    prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.\n  };\n\n  this.top = function (value, force) {\n    if (!arguments.length) {\n      return -(element.scrollTop + offsetTop);\n    }\n\n    var dif = element.scrollTop - prevTop,\n        oldOffset = offsetTop;\n\n    if ((dif > 2 || dif < -2) && !force) {\n      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n      prevTop = element.scrollTop;\n      gsap.killTweensOf(this, {\n        top: 1,\n        scrollTop: 1\n      });\n      this.top(-prevTop);\n\n      if (vars.onKill) {\n        vars.onKill();\n      }\n\n      return;\n    }\n\n    value = -value; //invert because scrolling works in the opposite direction\n\n    if (value < 0) {\n      offsetTop = value - 0.5 | 0;\n      value = 0;\n    } else if (value > maxTop) {\n      offsetTop = value - maxTop | 0;\n      value = maxTop;\n    } else {\n      offsetTop = 0;\n    }\n\n    if (offsetTop || oldOffset) {\n      if (!this._skip) {\n        style[_transformProp] = transformStart + -offsetLeft + \"px,\" + -offsetTop + transformEnd;\n      }\n    }\n\n    element.scrollTop = value | 0;\n    prevTop = element.scrollTop;\n  };\n\n  this.maxScrollTop = function () {\n    return maxTop;\n  };\n\n  this.maxScrollLeft = function () {\n    return maxLeft;\n  };\n\n  this.disable = function () {\n    node = content.firstChild;\n\n    while (node) {\n      nextNode = node.nextSibling;\n      element.appendChild(node);\n      node = nextNode;\n    }\n\n    if (element === content.parentNode) {\n      //in case disable() is called when it's already disabled.\n      element.removeChild(content);\n    }\n  };\n\n  this.enable = function () {\n    node = element.firstChild;\n\n    if (node === content) {\n      return;\n    }\n\n    while (node) {\n      nextNode = node.nextSibling;\n      content.appendChild(node);\n      node = nextNode;\n    }\n\n    element.appendChild(content);\n    this.calibrate();\n  };\n\n  this.calibrate = function (force) {\n    var widthMatches = element.clientWidth === elementWidth,\n        cs,\n        x,\n        y;\n    prevTop = element.scrollTop;\n    prevLeft = element.scrollLeft;\n\n    if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {\n      return; //no need to recalculate things if the width and height haven't changed.\n    }\n\n    if (offsetTop || offsetLeft) {\n      x = this.left();\n      y = this.top();\n      this.left(-element.scrollLeft);\n      this.top(-element.scrollTop);\n    }\n\n    cs = _getComputedStyle(element); //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)\n\n    if (!widthMatches || force) {\n      style.display = \"block\";\n      style.width = \"auto\";\n      style.paddingRight = \"0px\";\n      extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.\n\n      if (extraPadRight) {\n        extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);\n      }\n    }\n\n    style.display = \"inline-block\";\n    style.position = \"relative\";\n    style.overflow = \"visible\";\n    style.verticalAlign = \"top\";\n    style.boxSizing = \"content-box\";\n    style.width = \"100%\";\n    style.paddingRight = extraPadRight + \"px\"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error\n\n    if (_addPaddingBR) {\n      style.paddingBottom = cs.paddingBottom;\n    }\n\n    elementWidth = element.clientWidth;\n    elementHeight = element.clientHeight;\n    scrollWidth = element.scrollWidth;\n    scrollHeight = element.scrollHeight;\n    maxLeft = element.scrollWidth - elementWidth;\n    maxTop = element.scrollHeight - elementHeight;\n    contentHeight = content.offsetHeight;\n    style.display = \"block\";\n\n    if (x || y) {\n      this.left(x);\n      this.top(y);\n    }\n  };\n\n  this.content = content;\n  this.element = element;\n  this._skip = false;\n  this.enable();\n},\n    _initCore = function _initCore(required) {\n  if (_windowExists() && document.body) {\n    var nav = window && window.navigator;\n    _win = window;\n    _doc = document;\n    _docElement = _doc.documentElement;\n    _body = _doc.body;\n    _tempDiv = _createElement(\"div\");\n    _supportsPointer = !!window.PointerEvent;\n    _placeholderDiv = _createElement(\"div\");\n    _placeholderDiv.style.cssText = \"visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab\";\n    _defaultCursor = _placeholderDiv.style.cursor === \"grab\" ? \"grab\" : \"move\";\n    _isAndroid = nav && nav.userAgent.toLowerCase().indexOf(\"android\") !== -1; //Android handles touch events in an odd way and it's virtually impossible to \"feature test\" so we resort to UA sniffing\n\n    _isTouchDevice = \"ontouchstart\" in _docElement && \"orientation\" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);\n\n    _addPaddingBR = function () {\n      //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).\n      var div = _createElement(\"div\"),\n          child = _createElement(\"div\"),\n          childStyle = child.style,\n          parent = _body,\n          val;\n\n      childStyle.display = \"inline-block\";\n      childStyle.position = \"relative\";\n      div.style.cssText = \"width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden\";\n      div.appendChild(child);\n      parent.appendChild(div);\n      val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.\n\n      parent.removeChild(div);\n      return val;\n    }();\n\n    _touchEventLookup = function (types) {\n      //we create an object that makes it easy to translate touch event types into their \"pointer\" counterparts if we're in a browser that uses those instead. Like IE10 uses \"MSPointerDown\" instead of \"touchstart\", for example.\n      var standard = types.split(\",\"),\n          converted = (\"onpointerdown\" in _tempDiv ? \"pointerdown,pointermove,pointerup,pointercancel\" : \"onmspointerdown\" in _tempDiv ? \"MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel\" : types).split(\",\"),\n          obj = {},\n          i = 4;\n\n      while (--i > -1) {\n        obj[standard[i]] = converted[i];\n        obj[converted[i]] = standard[i];\n      } //to avoid problems in iOS 9, test to see if the browser supports the \"passive\" option on addEventListener().\n\n\n      try {\n        _docElement.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n          get: function get() {\n            _supportsPassive = 1;\n          }\n        }));\n      } catch (e) {}\n\n      return obj;\n    }(\"touchstart,touchmove,touchend,touchcancel\");\n\n    _addListener(_doc, \"touchcancel\", _emptyFunc); //some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document. Very strange indeed.\n\n\n    _addListener(_win, \"touchmove\", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n\n\n    _body && _body.addEventListener(\"touchstart\", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n    _addListener(_doc, \"contextmenu\", function () {\n      for (var p in _lookup) {\n        if (_lookup[p].isPressed) {\n          _lookup[p].endDrag();\n        }\n      }\n    });\n\n    gsap = _coreInitted = _getGSAP();\n  }\n\n  if (gsap) {\n    InertiaPlugin = gsap.plugins.inertia;\n    _checkPrefix = gsap.utils.checkPrefix;\n    _transformProp = _checkPrefix(_transformProp);\n    _transformOriginProp = _checkPrefix(_transformOriginProp);\n    _toArray = gsap.utils.toArray;\n    _supports3D = !!_checkPrefix(\"perspective\");\n  } else if (required) {\n    console.warn(\"Please gsap.registerPlugin(Draggable)\");\n  }\n};\n\nvar EventDispatcher = /*#__PURE__*/function () {\n  function EventDispatcher(target) {\n    this._listeners = {};\n    this.target = target || this;\n  }\n\n  var _proto = EventDispatcher.prototype;\n\n  _proto.addEventListener = function addEventListener(type, callback) {\n    var list = this._listeners[type] || (this._listeners[type] = []);\n\n    if (!~list.indexOf(callback)) {\n      list.push(callback);\n    }\n  };\n\n  _proto.removeEventListener = function removeEventListener(type, callback) {\n    var list = this._listeners[type],\n        i = list && list.indexOf(callback);\n    i >= 0 && list.splice(i, 1);\n  };\n\n  _proto.dispatchEvent = function dispatchEvent(type) {\n    var _this = this;\n\n    var result;\n    (this._listeners[type] || []).forEach(function (callback) {\n      return callback.call(_this, {\n        type: type,\n        target: _this.target\n      }) === false && (result = false);\n    });\n    return result; //if any of the callbacks return false, pass that along.\n  };\n\n  return EventDispatcher;\n}();\n\nvar Draggable = /*#__PURE__*/function (_EventDispatcher) {\n  _inheritsLoose(Draggable, _EventDispatcher);\n\n  function Draggable(target, vars) {\n    var _this2;\n\n    _this2 = _EventDispatcher.call(this) || this;\n    _coreInitted || _initCore(1);\n    target = _toArray(target)[0]; //in case the target is a selector object or selector text\n\n    if (!InertiaPlugin) {\n      InertiaPlugin = gsap.plugins.inertia;\n    }\n\n    _this2.vars = vars = _copy(vars || {});\n    _this2.target = target;\n    _this2.x = _this2.y = _this2.rotation = 0;\n    _this2.dragResistance = parseFloat(vars.dragResistance) || 0;\n    _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;\n    _this2.lockAxis = vars.lockAxis;\n    _this2.autoScroll = vars.autoScroll || 0;\n    _this2.lockedAxis = null;\n    _this2.allowEventDefault = !!vars.allowEventDefault;\n    gsap.getProperty(target, \"x\"); // to ensure that transforms are instantiated.\n\n    var type = (vars.type || \"x,y\").toLowerCase(),\n        xyMode = ~type.indexOf(\"x\") || ~type.indexOf(\"y\"),\n        rotationMode = type.indexOf(\"rotation\") !== -1,\n        xProp = rotationMode ? \"rotation\" : xyMode ? \"x\" : \"left\",\n        yProp = xyMode ? \"y\" : \"top\",\n        allowX = !!(~type.indexOf(\"x\") || ~type.indexOf(\"left\") || type === \"scroll\"),\n        allowY = !!(~type.indexOf(\"y\") || ~type.indexOf(\"top\") || type === \"scroll\"),\n        minimumMovement = vars.minimumMovement || 2,\n        self = _assertThisInitialized(_this2),\n        triggers = _toArray(vars.trigger || vars.handle || target),\n        killProps = {},\n        dragEndTime = 0,\n        checkAutoScrollBounds = false,\n        autoScrollMarginTop = vars.autoScrollMarginTop || 40,\n        autoScrollMarginRight = vars.autoScrollMarginRight || 40,\n        autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,\n        autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,\n        isClickable = vars.clickableTest || _isClickable,\n        clickTime = 0,\n        gsCache = target._gsap || gsap.core.getCache(target),\n        isFixed = _isFixed(target),\n        getPropAsNum = function getPropAsNum(property, unit) {\n      return parseFloat(gsCache.get(target, property, unit));\n    },\n        ownerDoc = target.ownerDocument || _doc,\n        enabled,\n        scrollProxy,\n        startPointerX,\n        startPointerY,\n        startElementX,\n        startElementY,\n        hasBounds,\n        hasDragCallback,\n        hasMoveCallback,\n        maxX,\n        minX,\n        maxY,\n        minY,\n        touch,\n        touchID,\n        rotationOrigin,\n        dirty,\n        old,\n        snapX,\n        snapY,\n        snapXY,\n        isClicking,\n        touchEventTarget,\n        matrix,\n        interrupted,\n        allowNativeTouchScrolling,\n        touchDragAxis,\n        isDispatching,\n        clickDispatch,\n        trustedClickDispatch,\n        isPreventingDefault,\n        innerMatrix,\n        dragged,\n        onContextMenu = function onContextMenu(e) {\n      //used to prevent long-touch from triggering a context menu.\n      // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.\n      _preventDefault(e);\n\n      e.stopImmediatePropagation && e.stopImmediatePropagation();\n      return false;\n    },\n        //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the \"mousemove\" or \"touchmove\" event handler which may get called many times inbetween refreshes.\n    render = function render(suppressEvents) {\n      if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {\n        var e = target,\n            autoScrollFactor = self.autoScroll * 15,\n            //multiplying by 15 just gives us a better \"feel\" speed-wise.\n        parent,\n            isRoot,\n            rect,\n            pointerX,\n            pointerY,\n            changeX,\n            changeY,\n            gap;\n        checkAutoScrollBounds = false;\n        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n        pointerX = self.pointerX - _windowProxy.scrollLeft;\n        pointerY = self.pointerY - _windowProxy.scrollTop;\n\n        while (e && !isRoot) {\n          //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.\n          isRoot = _isRoot(e.parentNode);\n          parent = isRoot ? _windowProxy : e.parentNode;\n          rect = isRoot ? {\n            bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),\n            right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),\n            left: 0,\n            top: 0\n          } : parent.getBoundingClientRect();\n          changeX = changeY = 0;\n\n          if (allowY) {\n            gap = parent._gsMaxScrollY - parent.scrollTop;\n\n            if (gap < 0) {\n              changeY = gap;\n            } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {\n              checkAutoScrollBounds = true;\n              changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);\n            } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {\n              checkAutoScrollBounds = true;\n              changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);\n            }\n\n            if (changeY) {\n              parent.scrollTop += changeY;\n            }\n          }\n\n          if (allowX) {\n            gap = parent._gsMaxScrollX - parent.scrollLeft;\n\n            if (gap < 0) {\n              changeX = gap;\n            } else if (pointerX > rect.right - autoScrollMarginRight && gap) {\n              checkAutoScrollBounds = true;\n              changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);\n            } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {\n              checkAutoScrollBounds = true;\n              changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);\n            }\n\n            if (changeX) {\n              parent.scrollLeft += changeX;\n            }\n          }\n\n          if (isRoot && (changeX || changeY)) {\n            _win.scrollTo(parent.scrollLeft, parent.scrollTop);\n\n            setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);\n          }\n\n          e = parent;\n        }\n      }\n\n      if (dirty) {\n        var x = self.x,\n            y = self.y;\n\n        if (rotationMode) {\n          self.deltaX = x - parseFloat(gsCache.rotation);\n          self.rotation = x;\n          gsCache.rotation = x + \"deg\";\n          gsCache.renderTransform(1, gsCache);\n        } else {\n          if (scrollProxy) {\n            if (allowY) {\n              self.deltaY = y - scrollProxy.top();\n              scrollProxy.top(y);\n            }\n\n            if (allowX) {\n              self.deltaX = x - scrollProxy.left();\n              scrollProxy.left(x);\n            }\n          } else if (xyMode) {\n            if (allowY) {\n              self.deltaY = y - parseFloat(gsCache.y);\n              gsCache.y = y + \"px\";\n            }\n\n            if (allowX) {\n              self.deltaX = x - parseFloat(gsCache.x);\n              gsCache.x = x + \"px\";\n            }\n\n            gsCache.renderTransform(1, gsCache);\n          } else {\n            if (allowY) {\n              self.deltaY = y - parseFloat(target.style.top || 0);\n              target.style.top = y + \"px\";\n            }\n\n            if (allowX) {\n              self.deltaX = x - parseFloat(target.style.left || 0);\n              target.style.left = x + \"px\";\n            }\n          }\n        }\n\n        if (hasDragCallback && !suppressEvents && !isDispatching) {\n          isDispatching = true; //in case onDrag has an update() call (avoid endless loop)\n\n          if (_dispatchEvent(self, \"drag\", \"onDrag\") === false) {\n            if (allowX) {\n              self.x -= self.deltaX;\n            }\n\n            if (allowY) {\n              self.y -= self.deltaY;\n            }\n\n            render(true);\n          }\n\n          isDispatching = false;\n        }\n      }\n\n      dirty = false;\n    },\n        //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.\n    syncXY = function syncXY(skipOnUpdate, skipSnap) {\n      var x = self.x,\n          y = self.y,\n          snappedValue,\n          cs;\n\n      if (!target._gsap) {\n        //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).\n        gsCache = gsap.core.getCache(target);\n      }\n\n      gsCache.uncache && gsap.getProperty(target, \"x\"); // trigger a re-cache\n\n      if (xyMode) {\n        self.x = parseFloat(gsCache.x);\n        self.y = parseFloat(gsCache.y);\n      } else if (rotationMode) {\n        self.x = self.rotation = parseFloat(gsCache.rotation);\n      } else if (scrollProxy) {\n        self.y = scrollProxy.top();\n        self.x = scrollProxy.left();\n      } else {\n        self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;\n        self.x = parseFloat(target.style.left || (cs || {}).left) || 0;\n      }\n\n      if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {\n        if (snapXY) {\n          _temp1.x = self.x;\n          _temp1.y = self.y;\n          snappedValue = snapXY(_temp1);\n\n          if (snappedValue.x !== self.x) {\n            self.x = snappedValue.x;\n            dirty = true;\n          }\n\n          if (snappedValue.y !== self.y) {\n            self.y = snappedValue.y;\n            dirty = true;\n          }\n        }\n\n        if (snapX) {\n          snappedValue = snapX(self.x);\n\n          if (snappedValue !== self.x) {\n            self.x = snappedValue;\n\n            if (rotationMode) {\n              self.rotation = snappedValue;\n            }\n\n            dirty = true;\n          }\n        }\n\n        if (snapY) {\n          snappedValue = snapY(self.y);\n\n          if (snappedValue !== self.y) {\n            self.y = snappedValue;\n          }\n\n          dirty = true;\n        }\n      }\n\n      dirty && render(true);\n\n      if (!skipOnUpdate) {\n        self.deltaX = self.x - x;\n        self.deltaY = self.y - y;\n\n        _dispatchEvent(self, \"throwupdate\", \"onThrowUpdate\");\n      }\n    },\n        buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {\n      if (min == null) {\n        min = -_bigNum;\n      }\n\n      if (max == null) {\n        max = _bigNum;\n      }\n\n      if (_isFunction(snap)) {\n        return function (n) {\n          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n\n          return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor) * factor;\n        };\n      }\n\n      if (_isArray(snap)) {\n        return function (n) {\n          var i = snap.length,\n              closest = 0,\n              absDif = _bigNum,\n              val,\n              dif;\n\n          while (--i > -1) {\n            val = snap[i];\n            dif = val - n;\n\n            if (dif < 0) {\n              dif = -dif;\n            }\n\n            if (dif < absDif && val >= min && val <= max) {\n              closest = i;\n              absDif = dif;\n            }\n          }\n\n          return snap[closest];\n        };\n      }\n\n      return isNaN(snap) ? function (n) {\n        return n;\n      } : function () {\n        return snap * factor;\n      };\n    },\n        buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {\n      radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.\n\n      if (_isFunction(snap)) {\n        return function (point) {\n          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,\n              x = point.x,\n              y = point.y,\n              result,\n              dx,\n              dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n\n          point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;\n          point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;\n          result = snap.call(self, point);\n\n          if (result !== point) {\n            point.x = result.x;\n            point.y = result.y;\n          }\n\n          if (factor !== 1) {\n            point.x *= factor;\n            point.y *= factor;\n          }\n\n          if (radius < _bigNum) {\n            dx = point.x - x;\n            dy = point.y - y;\n\n            if (dx * dx + dy * dy > radius) {\n              point.x = x;\n              point.y = y;\n            }\n          }\n\n          return point;\n        };\n      }\n\n      if (_isArray(snap)) {\n        return function (p) {\n          var i = snap.length,\n              closest = 0,\n              minDist = _bigNum,\n              x,\n              y,\n              point,\n              dist;\n\n          while (--i > -1) {\n            point = snap[i];\n            x = point.x - p.x;\n            y = point.y - p.y;\n            dist = x * x + y * y;\n\n            if (dist < minDist) {\n              closest = i;\n              minDist = dist;\n            }\n          }\n\n          return minDist <= radius ? snap[closest] : p;\n        };\n      }\n\n      return function (n) {\n        return n;\n      };\n    },\n        calculateBounds = function calculateBounds() {\n      var bounds, targetBounds, snap, snapIsRaw;\n      hasBounds = false;\n\n      if (scrollProxy) {\n        scrollProxy.calibrate();\n        self.minX = minX = -scrollProxy.maxScrollLeft();\n        self.minY = minY = -scrollProxy.maxScrollTop();\n        self.maxX = maxX = self.maxY = maxY = 0;\n        hasBounds = true;\n      } else if (!!vars.bounds) {\n        bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}\n\n        if (rotationMode) {\n          self.minX = minX = bounds.left;\n          self.maxX = maxX = bounds.left + bounds.width;\n          self.minY = minY = self.maxY = maxY = 0;\n        } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {\n          bounds = vars.bounds;\n          self.minX = minX = bounds.minX;\n          self.minY = minY = bounds.minY;\n          self.maxX = maxX = bounds.maxX;\n          self.maxY = maxY = bounds.maxY;\n        } else {\n          targetBounds = _getBounds(target, target.parentNode);\n          self.minX = minX = Math.round(getPropAsNum(xProp, \"px\") + bounds.left - targetBounds.left);\n          self.minY = minY = Math.round(getPropAsNum(yProp, \"px\") + bounds.top - targetBounds.top);\n          self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));\n          self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));\n        }\n\n        if (minX > maxX) {\n          self.minX = maxX;\n          self.maxX = maxX = minX;\n          minX = self.minX;\n        }\n\n        if (minY > maxY) {\n          self.minY = maxY;\n          self.maxY = maxY = minY;\n          minY = self.minY;\n        }\n\n        if (rotationMode) {\n          self.minRotation = minX;\n          self.maxRotation = maxX;\n        }\n\n        hasBounds = true;\n      }\n\n      if (vars.liveSnap) {\n        snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;\n        snapIsRaw = _isArray(snap) || _isFunction(snap);\n\n        if (rotationMode) {\n          snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);\n          snapY = null;\n        } else {\n          if (snap.points) {\n            snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);\n          } else {\n            if (allowX) {\n              snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);\n            }\n\n            if (allowY) {\n              snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);\n            }\n          }\n        }\n      }\n    },\n        onThrowComplete = function onThrowComplete() {\n      self.isThrowing = false;\n\n      _dispatchEvent(self, \"throwcomplete\", \"onThrowComplete\");\n    },\n        onThrowInterrupt = function onThrowInterrupt() {\n      self.isThrowing = false;\n    },\n        animate = function animate(inertia, forceZeroVelocity) {\n      var snap, snapIsRaw, tween, overshootTolerance;\n\n      if (inertia && InertiaPlugin) {\n        if (inertia === true) {\n          snap = vars.snap || vars.liveSnap || {};\n          snapIsRaw = _isArray(snap) || _isFunction(snap);\n          inertia = {\n            resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)\n          };\n\n          if (rotationMode) {\n            inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);\n          } else {\n            if (allowX) {\n              inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"x\");\n            }\n\n            if (allowY) {\n              inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"y\");\n            }\n\n            if (snap.points || _isArray(snap) && _isObject(snap[0])) {\n              inertia.linkedProps = xProp + \",\" + yProp;\n              inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a \"radius\" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that \"skipSnap\" parameter is true for syncXY.\n            }\n          }\n        }\n\n        self.isThrowing = true;\n        overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;\n\n        if (!inertia.duration) {\n          inertia.duration = {\n            max: Math.max(vars.minDuration || 0, \"maxDuration\" in vars ? vars.maxDuration : 2),\n            min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,\n            overshoot: overshootTolerance\n          };\n        }\n\n        self.tween = tween = gsap.to(scrollProxy || target, {\n          inertia: inertia,\n          data: \"_draggable\",\n          onComplete: onThrowComplete,\n          onInterrupt: onThrowInterrupt,\n          onUpdate: vars.fastMode ? _dispatchEvent : syncXY,\n          onUpdateParams: vars.fastMode ? [self, \"onthrowupdate\", \"onThrowUpdate\"] : snap && snap.radius ? [false, true] : []\n        });\n\n        if (!vars.fastMode) {\n          if (scrollProxy) {\n            scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n          }\n\n          tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.\n\n          syncXY(true, true);\n          self.endX = self.x;\n          self.endY = self.y;\n\n          if (rotationMode) {\n            self.endRotation = self.x;\n          }\n\n          tween.play(0);\n          syncXY(true, true);\n\n          if (scrollProxy) {\n            scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n          }\n        }\n      } else if (hasBounds) {\n        self.applyBounds();\n      }\n    },\n        updateMatrix = function updateMatrix(shiftStart) {\n      var start = matrix,\n          p;\n      matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n\n      if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) {\n        //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.\n        p = start.inverse().apply({\n          x: startPointerX,\n          y: startPointerY\n        });\n        matrix.apply(p, p);\n        startPointerX = p.x;\n        startPointerY = p.y;\n      }\n\n      if (matrix.equals(_identityMatrix)) {\n        //if there are no transforms, we can optimize performance by not factoring in the matrix\n        matrix = null;\n      }\n    },\n        recordStartPositions = function recordStartPositions() {\n      var edgeTolerance = 1 - self.edgeResistance,\n          offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0,\n          offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0,\n          parsedOrigin,\n          x,\n          y;\n\n      if (xyMode) {\n        // in case the user set it as a different unit, like animating the x to \"100%\". We must convert it back to px!\n        gsCache.x = getPropAsNum(xProp, \"px\") + \"px\";\n        gsCache.y = getPropAsNum(yProp, \"px\") + \"px\";\n        gsCache.renderTransform();\n      }\n\n      updateMatrix(false);\n      _point1.x = self.pointerX - offsetX;\n      _point1.y = self.pointerY - offsetY;\n      matrix && matrix.apply(_point1, _point1);\n      startPointerX = _point1.x; //translate to local coordinate system\n\n      startPointerY = _point1.y;\n\n      if (dirty) {\n        setPointerPosition(self.pointerX, self.pointerY);\n        render(true);\n      }\n\n      innerMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target);\n\n      if (scrollProxy) {\n        calculateBounds();\n        startElementY = scrollProxy.top();\n        startElementX = scrollProxy.left();\n      } else {\n        //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.\n        if (isTweening()) {\n          syncXY(true, true);\n          calculateBounds();\n        } else {\n          self.applyBounds();\n        }\n\n        if (rotationMode) {\n          parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || \"0 0\").split(\" \");\n          rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({\n            x: parseFloat(parsedOrigin[0]) || 0,\n            y: parseFloat(parsedOrigin[1]) || 0\n          });\n          syncXY(true, true);\n          x = self.pointerX - rotationOrigin.x - offsetX;\n          y = rotationOrigin.y - self.pointerY + offsetY;\n          startElementX = self.x; //starting rotation (x always refers to rotation in type:\"rotation\", measured in degrees)\n\n          startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;\n        } else {\n          //parent = !isFixed && target.parentNode;\n          //startScrollTop = parent ? parent.scrollTop || 0 : 0;\n          //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;\n          startElementY = getPropAsNum(yProp, \"px\"); //record the starting top and left values so that we can just add the mouse's movement to them later.\n\n          startElementX = getPropAsNum(xProp, \"px\");\n        }\n      }\n\n      if (hasBounds && edgeTolerance) {\n        if (startElementX > maxX) {\n          startElementX = maxX + (startElementX - maxX) / edgeTolerance;\n        } else if (startElementX < minX) {\n          startElementX = minX - (minX - startElementX) / edgeTolerance;\n        }\n\n        if (!rotationMode) {\n          if (startElementY > maxY) {\n            startElementY = maxY + (startElementY - maxY) / edgeTolerance;\n          } else if (startElementY < minY) {\n            startElementY = minY - (minY - startElementY) / edgeTolerance;\n          }\n        }\n      }\n\n      self.startX = startElementX = _round(startElementX);\n      self.startY = startElementY = _round(startElementY);\n    },\n        isTweening = function isTweening() {\n      return self.tween && self.tween.isActive();\n    },\n        removePlaceholder = function removePlaceholder() {\n      if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {\n        //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.\n        _placeholderDiv.parentNode.removeChild(_placeholderDiv);\n      }\n    },\n        //called when the mouse is pressed (or touch starts)\n    onPress = function onPress(e, force) {\n      var i;\n\n      if (!enabled || self.isPressed || !e || (e.type === \"mousedown\" || e.type === \"pointerdown\") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {\n        //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick \"click\" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.\n        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n\n        return;\n      }\n\n      interrupted = isTweening();\n      dragged = false; // we need to track whether or not it was dragged in this interaction so that if, for example, the user calls .endDrag() to FORCE it to stop and then they keep the mouse pressed down and eventually release, that would normally cause an onClick but we have to skip it in that case if there was dragging that occurred.\n\n      self.pointerEvent = e;\n\n      if (_touchEventLookup[e.type]) {\n        //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n        touchEventTarget = ~e.type.indexOf(\"touch\") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be \"MSPointerDown\" or \"pointerdown\".\n\n        _addListener(touchEventTarget, \"touchend\", onRelease);\n\n        _addListener(touchEventTarget, \"touchmove\", onMove); // possible future change if PointerEvents are more standardized: https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture\n\n\n        _addListener(touchEventTarget, \"touchcancel\", onRelease);\n\n        _addListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n      } else {\n        touchEventTarget = null;\n\n        _addListener(ownerDoc, \"mousemove\", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.\n\n      }\n\n      touchDragAxis = null;\n\n      if (!_supportsPointer || !touchEventTarget) {\n        _addListener(ownerDoc, \"mouseup\", onRelease);\n\n        e && e.target && _addListener(e.target, \"mouseup\", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable=\"true\"\n      }\n\n      isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;\n\n      if (isClicking) {\n        _addListener(e.target, \"change\", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a \"change\" event instead.\n\n\n        _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n\n        _dispatchEvent(self, \"press\", \"onPress\");\n\n        _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable=\"true\" (otherwise user couldn't drag to select text)\n\n\n        isPreventingDefault = false;\n        return;\n      }\n\n      allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? \"y\" : \"x\"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.\n\n      isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;\n\n      if (isPreventingDefault) {\n        _preventDefault(e);\n\n        _addListener(_win, \"touchforcechange\", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n      }\n\n      if (e.changedTouches) {\n        //touch events store the data slightly differently\n        e = touch = e.changedTouches[0];\n        touchID = e.identifier;\n      } else if (e.pointerId) {\n        touchID = e.pointerId; //for some Microsoft browsers\n      } else {\n        touch = touchID = null;\n      }\n\n      _dragCount++;\n\n      _addToRenderQueue(render); //causes the Draggable to render on each \"tick\" of gsap.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)\n\n\n      startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n\n      startPointerX = self.pointerX = e.pageX;\n\n      _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n\n      if (allowNativeTouchScrolling || self.autoScroll) {\n        _recordMaxScrolls(target.parentNode);\n      }\n\n      if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {\n        //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.\n        _placeholderDiv.style.width = target.parentNode.scrollWidth + \"px\";\n        target.parentNode.appendChild(_placeholderDiv);\n      }\n\n      recordStartPositions();\n      self.tween && self.tween.kill();\n      self.isThrowing = false;\n      gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.\n\n      scrollProxy && gsap.killTweensOf(target, {\n        scrollTo: 1\n      }, true); //just in case the original target's scroll position is being tweened somewhere else.\n\n      self.tween = self.lockedAxis = null;\n\n      if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {\n        target.style.zIndex = Draggable.zIndex++;\n      }\n\n      self.isPressed = true;\n      hasDragCallback = !!(vars.onDrag || self._listeners.drag);\n      hasMoveCallback = !!(vars.onMove || self._listeners.move);\n\n      if (vars.cursor !== false || vars.activeCursor) {\n        i = triggers.length;\n\n        while (--i > -1) {\n          gsap.set(triggers[i], {\n            cursor: vars.activeCursor || vars.cursor || (_defaultCursor === \"grab\" ? \"grabbing\" : _defaultCursor)\n          });\n        }\n      }\n\n      _dispatchEvent(self, \"press\", \"onPress\");\n    },\n        //called every time the mouse/touch moves\n    onMove = function onMove(e) {\n      var originalEvent = e,\n          touches,\n          pointerX,\n          pointerY,\n          i,\n          dx,\n          dy;\n\n      if (!enabled || _isMultiTouching || !self.isPressed || !e) {\n        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n\n        return;\n      }\n\n      self.pointerEvent = e;\n      touches = e.changedTouches;\n\n      if (touches) {\n        //touch events store the data slightly differently\n        e = touches[0];\n\n        if (e !== touch && e.identifier !== touchID) {\n          //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n          i = touches.length;\n\n          while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.\n\n\n          if (i < 0) {\n            return;\n          }\n        }\n      } else if (e.pointerId && touchID && e.pointerId !== touchID) {\n        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n        return;\n      }\n\n      if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {\n        //Android browsers force us to decide on the first \"touchmove\" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a \"touchcancel\" will be fired and then no \"touchmove\" or \"touchend\" will fire during the scrolling (no good).\n        _point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);\n        _point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);\n        matrix && matrix.apply(_point1, _point1);\n        pointerX = _point1.x;\n        pointerY = _point1.y;\n        dx = Math.abs(pointerX - startPointerX);\n        dy = Math.abs(pointerY - startPointerY);\n\n        if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n          touchDragAxis = dx > dy && allowX ? \"x\" : \"y\";\n\n          if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {\n            _addListener(_win, \"touchforcechange\", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari\n\n          }\n\n          if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {\n            self.lockedAxis = touchDragAxis === \"x\" ? \"y\" : \"x\";\n            _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);\n          }\n\n          if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n            onRelease(originalEvent);\n            return;\n          }\n        }\n      }\n\n      if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {\n        _preventDefault(originalEvent);\n\n        isPreventingDefault = true;\n      } else if (isPreventingDefault) {\n        isPreventingDefault = false;\n      }\n\n      if (self.autoScroll) {\n        checkAutoScrollBounds = true;\n      }\n\n      setPointerPosition(e.pageX, e.pageY, hasMoveCallback);\n    },\n        setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {\n      var dragTolerance = 1 - self.dragResistance,\n          edgeTolerance = 1 - self.edgeResistance,\n          prevPointerX = self.pointerX,\n          prevPointerY = self.pointerY,\n          prevStartElementY = startElementY,\n          prevX = self.x,\n          prevY = self.y,\n          prevEndX = self.endX,\n          prevEndY = self.endY,\n          prevEndRotation = self.endRotation,\n          prevDirty = dirty,\n          xChange,\n          yChange,\n          x,\n          y,\n          dif,\n          temp;\n      self.pointerX = pointerX;\n      self.pointerY = pointerY;\n\n      if (isFixed) {\n        pointerX -= _getDocScrollLeft(ownerDoc);\n        pointerY -= _getDocScrollTop(ownerDoc);\n      }\n\n      if (rotationMode) {\n        y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;\n        dif = self.y - y;\n\n        if (dif > 180) {\n          startElementY -= 360;\n          self.y = y;\n        } else if (dif < -180) {\n          startElementY += 360;\n          self.y = y;\n        }\n\n        if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {\n          self.y = y;\n          x = startElementX + (startElementY - y) * dragTolerance;\n        } else {\n          x = startElementX;\n        }\n      } else {\n        if (matrix) {\n          temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;\n          pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;\n          pointerX = temp;\n        }\n\n        yChange = pointerY - startPointerY;\n        xChange = pointerX - startPointerX;\n\n        if (yChange < minimumMovement && yChange > -minimumMovement) {\n          yChange = 0;\n        }\n\n        if (xChange < minimumMovement && xChange > -minimumMovement) {\n          xChange = 0;\n        }\n\n        if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {\n          temp = self.lockedAxis;\n\n          if (!temp) {\n            self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? \"y\" : allowY ? \"x\" : null;\n\n            if (temp && _isFunction(self.vars.onLockAxis)) {\n              self.vars.onLockAxis.call(self, self.pointerEvent);\n            }\n          }\n\n          if (temp === \"y\") {\n            yChange = 0;\n          } else if (temp === \"x\") {\n            xChange = 0;\n          }\n        }\n\n        x = _round(startElementX + xChange * dragTolerance);\n        y = _round(startElementY + yChange * dragTolerance);\n      }\n\n      if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {\n        if (snapXY) {\n          _temp1.x = x;\n          _temp1.y = y;\n          temp = snapXY(_temp1);\n          x = _round(temp.x);\n          y = _round(temp.y);\n        }\n\n        if (snapX) {\n          x = _round(snapX(x));\n        }\n\n        if (snapY) {\n          y = _round(snapY(y));\n        }\n      }\n\n      if (hasBounds) {\n        if (x > maxX) {\n          x = maxX + Math.round((x - maxX) * edgeTolerance);\n        } else if (x < minX) {\n          x = minX + Math.round((x - minX) * edgeTolerance);\n        }\n\n        if (!rotationMode) {\n          if (y > maxY) {\n            y = Math.round(maxY + (y - maxY) * edgeTolerance);\n          } else if (y < minY) {\n            y = Math.round(minY + (y - minY) * edgeTolerance);\n          }\n        }\n      }\n\n      if (self.x !== x || self.y !== y && !rotationMode) {\n        if (rotationMode) {\n          self.endRotation = self.x = self.endX = x;\n          dirty = true;\n        } else {\n          if (allowY) {\n            self.y = self.endY = y;\n            dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a \"tick\" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)\n          }\n\n          if (allowX) {\n            self.x = self.endX = x;\n            dirty = true;\n          }\n        }\n\n        if (!invokeOnMove || _dispatchEvent(self, \"move\", \"onMove\") !== false) {\n          if (!self.isDragging && self.isPressed) {\n            self.isDragging = dragged = true;\n\n            _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n          }\n        } else {\n          //revert because the onMove returned false!\n          self.pointerX = prevPointerX;\n          self.pointerY = prevPointerY;\n          startElementY = prevStartElementY;\n          self.x = prevX;\n          self.y = prevY;\n          self.endX = prevEndX;\n          self.endY = prevEndY;\n          self.endRotation = prevEndRotation;\n          dirty = prevDirty;\n        }\n      }\n    },\n        //called when the mouse/touch is released\n    onRelease = function onRelease(e, force) {\n      if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {\n        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n\n        return;\n      }\n\n      self.isPressed = false;\n      var originalEvent = e,\n          wasDragging = self.isDragging,\n          isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),\n          placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),\n          touches,\n          i,\n          syntheticEvent,\n          eventTarget,\n          syntheticClick;\n\n      if (touchEventTarget) {\n        _removeListener(touchEventTarget, \"touchend\", onRelease);\n\n        _removeListener(touchEventTarget, \"touchmove\", onMove);\n\n        _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n\n        _removeListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n      } else {\n        _removeListener(ownerDoc, \"mousemove\", onMove);\n      }\n\n      _removeListener(_win, \"touchforcechange\", _preventDefault);\n\n      if (!_supportsPointer || !touchEventTarget) {\n        _removeListener(ownerDoc, \"mouseup\", onRelease);\n\n        e && e.target && _removeListener(e.target, \"mouseup\", onRelease);\n      }\n\n      dirty = false;\n\n      if (wasDragging) {\n        dragEndTime = _lastDragTime = _getTime();\n        self.isDragging = false;\n      }\n\n      _removeFromRenderQueue(render);\n\n      if (isClicking && !isContextMenuRelease) {\n        if (e) {\n          _removeListener(e.target, \"change\", onRelease);\n\n          self.pointerEvent = originalEvent;\n        }\n\n        _setSelectable(triggers, false);\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n\n        _dispatchEvent(self, \"click\", \"onClick\");\n\n        isClicking = false;\n        return;\n      }\n\n      i = triggers.length;\n\n      while (--i > -1) {\n        _setStyle(triggers[i], \"cursor\", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));\n      }\n\n      _dragCount--;\n\n      if (e) {\n        touches = e.changedTouches;\n\n        if (touches) {\n          //touch events store the data slightly differently\n          e = touches[0];\n\n          if (e !== touch && e.identifier !== touchID) {\n            //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n            i = touches.length;\n\n            while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}\n\n            if (i < 0 && !force) {\n              return;\n            }\n          }\n        }\n\n        self.pointerEvent = originalEvent;\n        self.pointerX = e.pageX;\n        self.pointerY = e.pageY;\n      }\n\n      if (isContextMenuRelease && originalEvent) {\n        _preventDefault(originalEvent);\n\n        isPreventingDefault = true;\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n      } else if (originalEvent && !wasDragging) {\n        isPreventingDefault = false;\n\n        if (interrupted && (vars.snap || vars.bounds)) {\n          //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)\n          animate(vars.inertia || vars.throwProps);\n        }\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n\n        if ((!_isAndroid || originalEvent.type !== \"touchmove\") && originalEvent.type.indexOf(\"cancel\") === -1) {\n          //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a \"click\".\n          _dispatchEvent(self, \"click\", \"onClick\");\n\n          if (_getTime() - clickTime < 300) {\n            _dispatchEvent(self, \"doubleclick\", \"onDoubleClick\");\n          }\n\n          eventTarget = originalEvent.target || target; //old IE uses srcElement\n\n          clickTime = _getTime();\n\n          syntheticClick = function syntheticClick() {\n            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n            if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {\n              if (eventTarget.click) {\n                //some browsers (like mobile Safari) don't properly trigger the click event\n                eventTarget.click();\n              } else if (ownerDoc.createEvent) {\n                syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);\n                eventTarget.dispatchEvent(syntheticEvent);\n              }\n            }\n          };\n\n          if (!_isAndroid && !originalEvent.defaultPrevented) {\n            //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.\n            gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the \"click\" event with \"capture\" false which solved the video-click-to-play issue, but it would allow the \"click\" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's \"trusted\".\n          }\n        }\n      } else {\n        animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or InertiaPlugin isn't loaded.\n\n        if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {\n          isPreventingDefault = true;\n\n          _preventDefault(originalEvent);\n        } else {\n          isPreventingDefault = false;\n        }\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n      }\n\n      isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets\n\n      wasDragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n      return true;\n    },\n        updateScroll = function updateScroll(e) {\n      if (e && self.isDragging && !scrollProxy) {\n        var parent = e.target || target.parentNode,\n            deltaX = parent.scrollLeft - parent._gsScrollX,\n            deltaY = parent.scrollTop - parent._gsScrollY;\n\n        if (deltaX || deltaY) {\n          if (matrix) {\n            startPointerX -= deltaX * matrix.a + deltaY * matrix.c;\n            startPointerY -= deltaY * matrix.d + deltaX * matrix.b;\n          } else {\n            startPointerX -= deltaX;\n            startPointerY -= deltaY;\n          }\n\n          parent._gsScrollX += deltaX;\n          parent._gsScrollY += deltaY;\n          setPointerPosition(self.pointerX, self.pointerY);\n        }\n      }\n    },\n        onClick = function onClick(e) {\n      //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.\n      var time = _getTime(),\n          recentlyClicked = time - clickTime < 100,\n          recentlyDragged = time - dragEndTime < 50,\n          alreadyDispatched = recentlyClicked && clickDispatch === clickTime,\n          defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,\n          alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,\n          trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic \"click\" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?\n\n\n      if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {\n        e.stopImmediatePropagation();\n      }\n\n      if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {\n        //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)\n        if (trusted && alreadyDispatched) {\n          trustedClickDispatch = clickTime;\n        }\n\n        clickDispatch = clickTime;\n        return;\n      }\n\n      if (self.isPressed || recentlyDragged || recentlyClicked) {\n        if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {\n          _preventDefault(e);\n        }\n      }\n\n      if (!recentlyClicked && !recentlyDragged && !dragged) {\n        // for script-triggered event dispatches, like element.click()\n        e && e.target && (self.pointerEvent = e);\n\n        _dispatchEvent(self, \"click\", \"onClick\");\n      }\n    },\n        localizePoint = function localizePoint(p) {\n      return matrix ? {\n        x: p.x * matrix.a + p.y * matrix.c + matrix.e,\n        y: p.x * matrix.b + p.y * matrix.d + matrix.f\n      } : {\n        x: p.x,\n        y: p.y\n      };\n    };\n\n    old = Draggable.get(target);\n    old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)\n    //give the user access to start/stop dragging...\n\n    _this2.startDrag = function (event, align) {\n      var r1, r2, p1, p2;\n      onPress(event || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly\n\n      if (align && !self.hitTest(event || self.pointerEvent)) {\n        r1 = _parseRect(event || self.pointerEvent);\n        r2 = _parseRect(target);\n        p1 = localizePoint({\n          x: r1.left + r1.width / 2,\n          y: r1.top + r1.height / 2\n        });\n        p2 = localizePoint({\n          x: r2.left + r2.width / 2,\n          y: r2.top + r2.height / 2\n        });\n        startPointerX -= p1.x - p2.x;\n        startPointerY -= p1.y - p2.y;\n      }\n\n      if (!self.isDragging) {\n        self.isDragging = dragged = true;\n\n        _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n      }\n    };\n\n    _this2.drag = onMove;\n\n    _this2.endDrag = function (e) {\n      return onRelease(e || self.pointerEvent, true);\n    };\n\n    _this2.timeSinceDrag = function () {\n      return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;\n    };\n\n    _this2.timeSinceClick = function () {\n      return (_getTime() - clickTime) / 1000;\n    };\n\n    _this2.hitTest = function (target, threshold) {\n      return Draggable.hitTest(self.target, target, threshold);\n    };\n\n    _this2.getDirection = function (from, diagonalThreshold) {\n      //from can be \"start\" (default), \"velocity\", or an element\n      var mode = from === \"velocity\" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? \"element\" : \"start\",\n          xChange,\n          yChange,\n          ratio,\n          direction,\n          r1,\n          r2;\n\n      if (mode === \"element\") {\n        r1 = _parseRect(self.target);\n        r2 = _parseRect(from);\n      }\n\n      xChange = mode === \"start\" ? self.x - startElementX : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);\n\n      if (rotationMode) {\n        return xChange < 0 ? \"counter-clockwise\" : \"clockwise\";\n      } else {\n        diagonalThreshold = diagonalThreshold || 2;\n        yChange = mode === \"start\" ? self.y - startElementY : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);\n        ratio = Math.abs(xChange / yChange);\n        direction = ratio < 1 / diagonalThreshold ? \"\" : xChange < 0 ? \"left\" : \"right\";\n\n        if (ratio < diagonalThreshold) {\n          if (direction !== \"\") {\n            direction += \"-\";\n          }\n\n          direction += yChange < 0 ? \"up\" : \"down\";\n        }\n      }\n\n      return direction;\n    };\n\n    _this2.applyBounds = function (newBounds, sticky) {\n      var x, y, forceZeroVelocity, e, parent, isRoot;\n\n      if (newBounds && vars.bounds !== newBounds) {\n        vars.bounds = newBounds;\n        return self.update(true, sticky);\n      }\n\n      syncXY(true);\n      calculateBounds();\n\n      if (hasBounds && !isTweening()) {\n        x = self.x;\n        y = self.y;\n\n        if (x > maxX) {\n          x = maxX;\n        } else if (x < minX) {\n          x = minX;\n        }\n\n        if (y > maxY) {\n          y = maxY;\n        } else if (y < minY) {\n          y = minY;\n        }\n\n        if (self.x !== x || self.y !== y) {\n          forceZeroVelocity = true;\n          self.x = self.endX = x;\n\n          if (rotationMode) {\n            self.endRotation = x;\n          } else {\n            self.y = self.endY = y;\n          }\n\n          dirty = true;\n          render(true);\n\n          if (self.autoScroll && !self.isDragging) {\n            _recordMaxScrolls(target.parentNode);\n\n            e = target;\n            _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n            _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n\n            while (e && !isRoot) {\n              //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.\n              isRoot = _isRoot(e.parentNode);\n              parent = isRoot ? _windowProxy : e.parentNode;\n\n              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {\n                parent.scrollTop = parent._gsMaxScrollY;\n              }\n\n              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {\n                parent.scrollLeft = parent._gsMaxScrollX;\n              }\n\n              e = parent;\n            }\n          }\n        }\n\n        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {\n          animate(vars.inertia || vars.throwProps, forceZeroVelocity);\n        }\n      }\n\n      return self;\n    };\n\n    _this2.update = function (applyBounds, sticky, ignoreExternalChanges) {\n      if (sticky && self.isPressed) {\n        // in case the element was repositioned in the document flow, thus its x/y may be identical but its position is actually quite different.\n        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target),\n            p = innerMatrix.apply({\n          x: self.x - startElementX,\n          y: self.y - startElementY\n        }),\n            m2 = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n        m2.apply({\n          x: m.e - p.x,\n          y: m.f - p.y\n        }, p);\n        self.x -= p.x - m2.e;\n        self.y -= p.y - m2.f;\n        render(true);\n        recordStartPositions();\n      }\n\n      var x = self.x,\n          y = self.y;\n      updateMatrix(!sticky);\n\n      if (applyBounds) {\n        self.applyBounds();\n      } else {\n        dirty && ignoreExternalChanges && render(true);\n        syncXY(true);\n      }\n\n      if (sticky) {\n        setPointerPosition(self.pointerX, self.pointerY);\n        dirty && render(true);\n      }\n\n      if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {\n        recordStartPositions();\n      }\n\n      if (self.autoScroll) {\n        _recordMaxScrolls(target.parentNode, self.isDragging);\n\n        checkAutoScrollBounds = self.isDragging;\n        render(true); //in case reparenting occurred.\n\n        _removeScrollListener(target, updateScroll);\n\n        _addScrollListener(target, updateScroll);\n      }\n\n      return self;\n    };\n\n    _this2.enable = function (type) {\n      var setVars = {\n        lazy: true\n      },\n          id,\n          i,\n          trigger;\n\n      if (vars.cursor !== false) {\n        setVars.cursor = vars.cursor || _defaultCursor;\n      }\n\n      if (gsap.utils.checkPrefix(\"touchCallout\")) {\n        setVars.touchCallout = \"none\";\n      }\n\n      if (type !== \"soft\") {\n        _setTouchActionForAllDescendants(triggers, allowX === allowY ? \"none\" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is \"manipulate\" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.\n\n\n        i = triggers.length;\n\n        while (--i > -1) {\n          trigger = triggers[i];\n          _supportsPointer || _addListener(trigger, \"mousedown\", onPress);\n\n          _addListener(trigger, \"touchstart\", onPress);\n\n          _addListener(trigger, \"click\", onClick, true); // note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n\n\n          gsap.set(trigger, setVars);\n\n          if (trigger.getBBox && trigger.ownerSVGElement && allowX !== allowY) {\n            // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.\n            gsap.set(trigger.ownerSVGElement, {\n              touchAction: vars.allowNativeTouchScrolling || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"\n            });\n          }\n\n          vars.allowContextMenu || _addListener(trigger, \"contextmenu\", onContextMenu);\n        }\n\n        _setSelectable(triggers, false);\n      }\n\n      _addScrollListener(target, updateScroll);\n\n      enabled = true;\n\n      if (InertiaPlugin && type !== \"soft\") {\n        InertiaPlugin.track(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n      }\n\n      target._gsDragID = id = \"d\" + _lookupCount++;\n      _lookup[id] = self;\n\n      if (scrollProxy) {\n        scrollProxy.enable();\n        scrollProxy.element._gsDragID = id;\n      }\n\n      (vars.bounds || rotationMode) && recordStartPositions();\n      vars.bounds && self.applyBounds();\n      return self;\n    };\n\n    _this2.disable = function (type) {\n      var dragging = self.isDragging,\n          i = triggers.length,\n          trigger;\n\n      while (--i > -1) {\n        _setStyle(triggers[i], \"cursor\", null);\n      }\n\n      if (type !== \"soft\") {\n        _setTouchActionForAllDescendants(triggers, null);\n\n        i = triggers.length;\n\n        while (--i > -1) {\n          trigger = triggers[i];\n\n          _setStyle(trigger, \"touchCallout\", null);\n\n          _removeListener(trigger, \"mousedown\", onPress);\n\n          _removeListener(trigger, \"touchstart\", onPress);\n\n          _removeListener(trigger, \"click\", onClick);\n\n          _removeListener(trigger, \"contextmenu\", onContextMenu);\n        }\n\n        _setSelectable(triggers, true);\n\n        if (touchEventTarget) {\n          _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n\n          _removeListener(touchEventTarget, \"touchend\", onRelease);\n\n          _removeListener(touchEventTarget, \"touchmove\", onMove);\n        }\n\n        _removeListener(ownerDoc, \"mouseup\", onRelease);\n\n        _removeListener(ownerDoc, \"mousemove\", onMove);\n      }\n\n      _removeScrollListener(target, updateScroll);\n\n      enabled = false;\n      InertiaPlugin && type !== \"soft\" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n      scrollProxy && scrollProxy.disable();\n\n      _removeFromRenderQueue(render);\n\n      self.isDragging = self.isPressed = isClicking = false;\n      dragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n      return self;\n    };\n\n    _this2.enabled = function (value, type) {\n      return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;\n    };\n\n    _this2.kill = function () {\n      self.isThrowing = false;\n      self.tween && self.tween.kill();\n      self.disable();\n      gsap.set(triggers, {\n        clearProps: \"userSelect\"\n      });\n      delete _lookup[target._gsDragID];\n      return self;\n    };\n\n    if (~type.indexOf(\"scroll\")) {\n      scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({\n        onKill: function onKill() {\n          //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the \"mouseup\" properly when users drag the scrollbar of an element, so this works around that issue.\n          self.isPressed && onRelease(null);\n        }\n      }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to \"hidden\" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)\n\n      target.style.overflowY = allowY && !_isTouchDevice ? \"auto\" : \"hidden\";\n      target.style.overflowX = allowX && !_isTouchDevice ? \"auto\" : \"hidden\";\n      target = scrollProxy.content;\n    }\n\n    if (rotationMode) {\n      killProps.rotation = 1;\n    } else {\n      if (allowX) {\n        killProps[xProp] = 1;\n      }\n\n      if (allowY) {\n        killProps[yProp] = 1;\n      }\n    }\n\n    gsCache.force3D = \"force3D\" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.\n\n    _this2.enable();\n\n    return _this2;\n  }\n\n  Draggable.register = function register(core) {\n    gsap = core;\n\n    _initCore();\n  };\n\n  Draggable.create = function create(targets, vars) {\n    _coreInitted || _initCore(true);\n    return _toArray(targets).map(function (target) {\n      return new Draggable(target, vars);\n    });\n  };\n\n  Draggable.get = function get(target) {\n    return _lookup[(_toArray(target)[0] || {})._gsDragID];\n  };\n\n  Draggable.timeSinceDrag = function timeSinceDrag() {\n    return (_getTime() - _lastDragTime) / 1000;\n  };\n\n  Draggable.hitTest = function hitTest(obj1, obj2, threshold) {\n    if (obj1 === obj2) {\n      return false;\n    }\n\n    var r1 = _parseRect(obj1),\n        r2 = _parseRect(obj2),\n        top = r1.top,\n        left = r1.left,\n        right = r1.right,\n        bottom = r1.bottom,\n        width = r1.width,\n        height = r1.height,\n        isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top,\n        overlap,\n        area,\n        isRatio;\n\n    if (isOutside || !threshold) {\n      return !isOutside;\n    }\n\n    isRatio = (threshold + \"\").indexOf(\"%\") !== -1;\n    threshold = parseFloat(threshold) || 0;\n    overlap = {\n      left: Math.max(left, r2.left),\n      top: Math.max(top, r2.top)\n    };\n    overlap.width = Math.min(right, r2.right) - overlap.left;\n    overlap.height = Math.min(bottom, r2.bottom) - overlap.top;\n\n    if (overlap.width < 0 || overlap.height < 0) {\n      return false;\n    }\n\n    if (isRatio) {\n      threshold *= 0.01;\n      area = overlap.width * overlap.height;\n      return area >= width * height * threshold || area >= r2.width * r2.height * threshold;\n    }\n\n    return overlap.width > threshold && overlap.height > threshold;\n  };\n\n  return Draggable;\n}(EventDispatcher);\n\n_setDefaults(Draggable.prototype, {\n  pointerX: 0,\n  pointerY: 0,\n  startX: 0,\n  startY: 0,\n  deltaX: 0,\n  deltaY: 0,\n  isDragging: false,\n  isPressed: false\n});\n\nDraggable.zIndex = 1000;\nDraggable.version = \"3.11.2\";\n_getGSAP() && gsap.registerPlugin(Draggable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9EcmFnZ2FibGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLGdEQUFnRCwwREFBMEQsMkNBQTJDOztBQUVySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDBKQUEwSjs7QUFFMUosaURBQWlEO0FBQ2pELENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFRO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ04sQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNERBQTREO0FBQzVELENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtHQUErRztBQUMvRyxDQUFDO0FBQ0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdIQUFnSCwwQkFBMEIsSUFBSSx1QkFBdUI7QUFDcks7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0NBQXNDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdMQUFnTDtBQUNoTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsaUVBQWUseUJBQXlCLGlFQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0Usb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVcsU0FBUyxvQkFBb0Isa0JBQWtCLFdBQVc7QUFDNUg7QUFDQSwrRUFBK0U7O0FBRS9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxhQUFhLGNBQWM7QUFDN0U7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7O0FBRVI7QUFDQSxLQUFLOztBQUVMLG1EQUFtRDs7O0FBR25ELGlEQUFpRDs7O0FBR2pELCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLENBQUM7O0FBRU07QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw2REFBNkQsK0VBQStFLHlDQUF5QyxJQUFJOztBQUV6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFlOztBQUU5QixzRUFBc0Usc0RBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUVBQWU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxpRUFBZTtBQUNoRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGOztBQUU5Rjs7QUFFQSw2REFBNkQ7OztBQUc3RDs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxxREFBcUQ7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFOztBQUVBOztBQUVBO0FBQ0EscURBQXFEOzs7QUFHckQ7O0FBRUE7O0FBRUEsd0NBQXdDOzs7QUFHeEM7QUFDQTtBQUNBOztBQUVBLHlOQUF5Tjs7QUFFek47O0FBRUE7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtCQUErQjtBQUMvQixRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7OztBQUdqQywrQ0FBK0M7O0FBRS9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBLE9BQU8sU0FBUzs7QUFFaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0dBQWdHOzs7QUFHaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFOztBQUVyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRDs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEVBQThFOztBQUU5RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRzs7O0FBR2hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQixpRUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5UkFBeVI7OztBQUd6Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlEOzs7QUFHekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxVQUFVOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0Q7O0FBRS9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvRHJhZ2dhYmxlLmpzPzRjMTUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIERyYWdnYWJsZSAzLjExLjJcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBNYXRyaXgyRCB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX2JvZHksXG4gICAgX3RlbXBEaXYsXG4gICAgX3BsYWNlaG9sZGVyRGl2LFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2hlY2tQcmVmaXgsXG4gICAgX3RvQXJyYXksXG4gICAgX3N1cHBvcnRzUGFzc2l2ZSxcbiAgICBfaXNUb3VjaERldmljZSxcbiAgICBfdG91Y2hFdmVudExvb2t1cCxcbiAgICBfaXNNdWx0aVRvdWNoaW5nLFxuICAgIF9pc0FuZHJvaWQsXG4gICAgSW5lcnRpYVBsdWdpbixcbiAgICBfZGVmYXVsdEN1cnNvcixcbiAgICBfc3VwcG9ydHNQb2ludGVyLFxuICAgIF9kcmFnQ291bnQgPSAwLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMDtcbn0sXG4gICAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfYmlnTnVtID0gMWUyMCxcbiAgICBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4MkQoKSxcbiAgICBfZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufSxcbiAgICBfcmVuZGVyUXVldWUgPSBbXSxcbiAgICBfbG9va3VwID0ge30sXG4gICAgLy93aGVuIGEgRHJhZ2dhYmxlIGlzIGNyZWF0ZWQsIHRoZSB0YXJnZXQgZ2V0cyBhIHVuaXF1ZSBfZ3NEcmFnSUQgcHJvcGVydHkgdGhhdCBhbGxvd3MgZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlIERyYWdnYWJsZSBpbnN0YW5jZSBmb3IgcXVpY2sgbG9va3VwcyBpbiBEcmFnZ2FibGUuZ2V0KCkuIFRoaXMgYXZvaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBjYXVzZSBnYyBwcm9ibGVtcy5cbl9sb29rdXBDb3VudCA9IDAsXG4gICAgX2NsaWNrYWJsZVRhZ0V4cCA9IC9eKD86YXxpbnB1dHx0ZXh0YXJlYXxidXR0b258c2VsZWN0KSQvaSxcbiAgICBfbGFzdERyYWdUaW1lID0gMCxcbiAgICBfdGVtcDEgPSB7fSxcbiAgICAvLyBhIHNpbXBsZSBvYmplY3Qgd2UgcmV1c2UgYW5kIHBvcHVsYXRlICh1c3VhbGx5IHgveSBwcm9wZXJ0aWVzKSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2UuXG5fd2luZG93UHJveHkgPSB7fSxcbiAgICAvL21lbW9yeS9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gLSB3ZSByZXVzZSB0aGlzIG9iamVjdCBkdXJpbmcgYXV0b1Njcm9sbCB0byBzdG9yZSB3aW5kb3ctcmVsYXRlZCBib3VuZHMvb2Zmc2V0cy5cbl9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqLCBmYWN0b3IpIHtcbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIG9iaikge1xuICAgIGNvcHlbcF0gPSBmYWN0b3IgPyBvYmpbcF0gKiBmYWN0b3IgOiBvYmpbcF07XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2V4dGVuZCA9IGZ1bmN0aW9uIF9leHRlbmQob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKCEocCBpbiBvYmopKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyA9IGZ1bmN0aW9uIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKGVsZW1lbnRzLCB2YWx1ZSkge1xuICB2YXIgaSA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGNoaWxkcmVuO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YWx1ZSA/IGVsZW1lbnRzW2ldLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWUgOiBlbGVtZW50c1tpXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRvdWNoLWFjdGlvblwiKTtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnRzW2ldLmNoaWxkcmVuO1xuICAgIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCAmJiBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyhjaGlsZHJlbiwgdmFsdWUpO1xuICB9XG59LFxuICAgIF9yZW5kZXJRdWV1ZVRpY2sgPSBmdW5jdGlvbiBfcmVuZGVyUXVldWVUaWNrKCkge1xuICByZXR1cm4gX3JlbmRlclF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYygpO1xuICB9KTtcbn0sXG4gICAgX2FkZFRvUmVuZGVyUXVldWUgPSBmdW5jdGlvbiBfYWRkVG9SZW5kZXJRdWV1ZShmdW5jKSB7XG4gIF9yZW5kZXJRdWV1ZS5wdXNoKGZ1bmMpO1xuXG4gIGlmIChfcmVuZGVyUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgZ3NhcC50aWNrZXIuYWRkKF9yZW5kZXJRdWV1ZVRpY2spO1xuICB9XG59LFxuICAgIF9yZW5kZXJRdWV1ZVRpbWVvdXQgPSBmdW5jdGlvbiBfcmVuZGVyUXVldWVUaW1lb3V0KCkge1xuICByZXR1cm4gIV9yZW5kZXJRdWV1ZS5sZW5ndGggJiYgZ3NhcC50aWNrZXIucmVtb3ZlKF9yZW5kZXJRdWV1ZVRpY2spO1xufSxcbiAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlID0gZnVuY3Rpb24gX3JlbW92ZUZyb21SZW5kZXJRdWV1ZShmdW5jKSB7XG4gIHZhciBpID0gX3JlbmRlclF1ZXVlLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKF9yZW5kZXJRdWV1ZVtpXSA9PT0gZnVuYykge1xuICAgICAgX3JlbmRlclF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBnc2FwLnRvKF9yZW5kZXJRdWV1ZVRpbWVvdXQsIHtcbiAgICBvdmVyd3JpdGU6IHRydWUsXG4gICAgZGVsYXk6IDE1LFxuICAgIGR1cmF0aW9uOiAwLFxuICAgIG9uQ29tcGxldGU6IF9yZW5kZXJRdWV1ZVRpbWVvdXQsXG4gICAgZGF0YTogXCJfZHJhZ2dhYmxlXCJcbiAgfSk7IC8vcmVtb3ZlIHRoZSBcInRpY2tcIiBsaXN0ZW5lciBvbmx5IGFmdGVyIHRoZSByZW5kZXIgcXVldWUgaXMgZW1wdHkgZm9yIDE1IHNlY29uZHMgKHRvIGltcHJvdmUgcGVyZm9ybWFuY2UpLiBBZGRpbmcvcmVtb3ZpbmcgaXQgY29uc3RhbnRseSBmb3IgZXZlcnkgY2xpY2svdG91Y2ggd291bGRuJ3QgZGVsaXZlciBvcHRpbWFsIHNwZWVkLCBhbmQgd2UgYWxzbyBkb24ndCB3YW50IHRoZSB0aWNrZXIgdG8ga2VlcCBjYWxsaW5nIHRoZSByZW5kZXIgbWV0aG9kIHdoZW4gdGhpbmdzIGFyZSBpZGxlIGZvciBsb25nIHBlcmlvZHMgb2YgdGltZSAod2Ugd2FudCB0byBpbXByb3ZlIGJhdHRlcnkgbGlmZSBvbiBtb2JpbGUgZGV2aWNlcykuXG59LFxuICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikpIHtcbiAgICAgIG9ialtwXSA9IGRlZmF1bHRzW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgdG91Y2hUeXBlID0gX3RvdWNoRXZlbnRMb29rdXBbdHlwZV07XG4gICAgY2FwdHVyZSA9IGNhcHR1cmUgfHwgKF9zdXBwb3J0c1Bhc3NpdmUgPyB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0gOiBudWxsKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hUeXBlIHx8IHR5cGUsIGZ1bmMsIGNhcHR1cmUpO1xuICAgIHRvdWNoVHlwZSAmJiB0eXBlICE9PSB0b3VjaFR5cGUgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIGNhcHR1cmUpOyAvL3NvbWUgYnJvd3NlcnMgYWN0dWFsbHkgc3VwcG9ydCBib3RoLCBzbyBtdXN0IHdlLiBCdXQgcG9pbnRlciBldmVudHMgY292ZXIgYWxsLlxuICB9XG59LFxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jKSB7XG4gIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgdG91Y2hUeXBlID0gX3RvdWNoRXZlbnRMb29rdXBbdHlwZV07XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoVHlwZSB8fCB0eXBlLCBmdW5jKTtcbiAgICB0b3VjaFR5cGUgJiYgdHlwZSAhPT0gdG91Y2hUeXBlICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jKTtcbiAgfVxufSxcbiAgICBfcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBfcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBldmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG59LFxuICAgIF9oYXNUb3VjaElEID0gZnVuY3Rpb24gX2hhc1RvdWNoSUQobGlzdCwgSUQpIHtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGxpc3RbaV0uaWRlbnRpZmllciA9PT0gSUQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufSxcbiAgICBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQgPSBmdW5jdGlvbiBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQoZXZlbnQpIHtcbiAgX2lzTXVsdGlUb3VjaGluZyA9IGV2ZW50LnRvdWNoZXMgJiYgX2RyYWdDb3VudCA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuXG4gIF9yZW1vdmVMaXN0ZW5lcihldmVudC50YXJnZXQsIFwidG91Y2hlbmRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKTtcbn0sXG4gICAgX29uTXVsdGlUb3VjaERvY3VtZW50ID0gZnVuY3Rpb24gX29uTXVsdGlUb3VjaERvY3VtZW50KGV2ZW50KSB7XG4gIF9pc011bHRpVG91Y2hpbmcgPSBldmVudC50b3VjaGVzICYmIF9kcmFnQ291bnQgPCBldmVudC50b3VjaGVzLmxlbmd0aDtcblxuICBfYWRkTGlzdGVuZXIoZXZlbnQudGFyZ2V0LCBcInRvdWNoZW5kXCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZCk7XG59LFxuICAgIF9nZXREb2NTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsVG9wKGRvYykge1xuICByZXR1cm4gX3dpbi5wYWdlWU9mZnNldCB8fCBkb2Muc2Nyb2xsVG9wIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvYy5ib2R5LnNjcm9sbFRvcCB8fCAwO1xufSxcbiAgICBfZ2V0RG9jU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxMZWZ0KGRvYykge1xuICByZXR1cm4gX3dpbi5wYWdlWE9mZnNldCB8fCBkb2Muc2Nyb2xsTGVmdCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jLmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xufSxcbiAgICBfYWRkU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkU2Nyb2xsTGlzdGVuZXIoZSwgY2FsbGJhY2spIHtcbiAgX2FkZExpc3RlbmVyKGUsIFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcblxuICBpZiAoIV9pc1Jvb3QoZS5wYXJlbnROb2RlKSkge1xuICAgIF9hZGRTY3JvbGxMaXN0ZW5lcihlLnBhcmVudE5vZGUsIGNhbGxiYWNrKTtcbiAgfVxufSxcbiAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIoZSwgY2FsbGJhY2spIHtcbiAgX3JlbW92ZUxpc3RlbmVyKGUsIFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcblxuICBpZiAoIV9pc1Jvb3QoZS5wYXJlbnROb2RlKSkge1xuICAgIF9yZW1vdmVTY3JvbGxMaXN0ZW5lcihlLnBhcmVudE5vZGUsIGNhbGxiYWNrKTtcbiAgfVxufSxcbiAgICBfaXNSb290ID0gZnVuY3Rpb24gX2lzUm9vdChlKSB7XG4gIHJldHVybiAhISghZSB8fCBlID09PSBfZG9jRWxlbWVudCB8fCBlLm5vZGVUeXBlID09PSA5IHx8IGUgPT09IF9kb2MuYm9keSB8fCBlID09PSBfd2luIHx8ICFlLm5vZGVUeXBlIHx8ICFlLnBhcmVudE5vZGUpO1xufSxcbiAgICBfZ2V0TWF4U2Nyb2xsID0gZnVuY3Rpb24gX2dldE1heFNjcm9sbChlbGVtZW50LCBheGlzKSB7XG4gIHZhciBkaW0gPSBheGlzID09PSBcInhcIiA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIsXG4gICAgICBzY3JvbGwgPSBcInNjcm9sbFwiICsgZGltLFxuICAgICAgY2xpZW50ID0gXCJjbGllbnRcIiArIGRpbTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIF9pc1Jvb3QoZWxlbWVudCkgPyBNYXRoLm1heChfZG9jRWxlbWVudFtzY3JvbGxdLCBfYm9keVtzY3JvbGxdKSAtIChfd2luW1wiaW5uZXJcIiArIGRpbV0gfHwgX2RvY0VsZW1lbnRbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbY2xpZW50XSk7XG59LFxuICAgIF9yZWNvcmRNYXhTY3JvbGxzID0gZnVuY3Rpb24gX3JlY29yZE1heFNjcm9sbHMoZSwgc2tpcEN1cnJlbnQpIHtcbiAgLy9yZWNvcmRzIF9nc01heFNjcm9sbFggYW5kIF9nc01heFNjcm9sbFkgcHJvcGVydGllcyBmb3IgdGhlIGVsZW1lbnQgYW5kIGFsbCBhbmNlc3RvcnMgdXAgdGhlIGNoYWluIHNvIHRoYXQgd2UgY2FuIGNhcCBpdCwgb3RoZXJ3aXNlIGRyYWdnaW5nIGJleW9uZCB0aGUgZWRnZXMgd2l0aCBhdXRvU2Nyb2xsIG9uIGNhbiBlbmRsZXNzbHkgc2Nyb2xsLlxuICB2YXIgeCA9IF9nZXRNYXhTY3JvbGwoZSwgXCJ4XCIpLFxuICAgICAgeSA9IF9nZXRNYXhTY3JvbGwoZSwgXCJ5XCIpO1xuXG4gIGlmIChfaXNSb290KGUpKSB7XG4gICAgZSA9IF93aW5kb3dQcm94eTtcbiAgfSBlbHNlIHtcbiAgICBfcmVjb3JkTWF4U2Nyb2xscyhlLnBhcmVudE5vZGUsIHNraXBDdXJyZW50KTtcbiAgfVxuXG4gIGUuX2dzTWF4U2Nyb2xsWCA9IHg7XG4gIGUuX2dzTWF4U2Nyb2xsWSA9IHk7XG5cbiAgaWYgKCFza2lwQ3VycmVudCkge1xuICAgIGUuX2dzU2Nyb2xsWCA9IGUuc2Nyb2xsTGVmdCB8fCAwO1xuICAgIGUuX2dzU2Nyb2xsWSA9IGUuc2Nyb2xsVG9wIHx8IDA7XG4gIH1cbn0sXG4gICAgX3NldFN0eWxlID0gZnVuY3Rpb24gX3NldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gIGlmICghc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoX2lzVW5kZWZpbmVkKHN0eWxlW3Byb3BlcnR5XSkpIHtcbiAgICBwcm9wZXJ0eSA9IF9jaGVja1ByZWZpeChwcm9wZXJ0eSwgZWxlbWVudCkgfHwgcHJvcGVydHk7XG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5ICYmIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gIH1cbn0sXG4gICAgX2dldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgPyBlbGVtZW50IDogZWxlbWVudC5ob3N0IHx8IChlbGVtZW50LnBhcmVudE5vZGUgfHwge30pLmhvc3QgfHwgZWxlbWVudCk7XG59LFxuICAgIC8vdGhlIFwiaG9zdFwiIHN0dWZmIGhlbHBzIHRvIGFjY29tbW9kYXRlIFNoYWRvd0RvbSBvYmplY3RzLlxuX3RlbXBSZWN0ID0ge30sXG4gICAgLy9yZXVzZSB0byByZWR1Y2UgZ2FyYmFnZSBjb2xsZWN0aW9uIHRhc2tzXG5fcGFyc2VSZWN0ID0gZnVuY3Rpb24gX3BhcnNlUmVjdChlKSB7XG4gIC8vYWNjZXB0cyBhIERPTSBlbGVtZW50LCBhIG1vdXNlIGV2ZW50LCBvciBhIHJlY3RhbmdsZSBvYmplY3QgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVjdGFuZ2xlIHdpdGggbGVmdCwgcmlnaHQsIHdpZHRoLCBoZWlnaHQsIHRvcCwgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzXG4gIGlmIChlID09PSBfd2luKSB7XG4gICAgX3RlbXBSZWN0LmxlZnQgPSBfdGVtcFJlY3QudG9wID0gMDtcbiAgICBfdGVtcFJlY3Qud2lkdGggPSBfdGVtcFJlY3QucmlnaHQgPSBfZG9jRWxlbWVudC5jbGllbnRXaWR0aCB8fCBlLmlubmVyV2lkdGggfHwgX2JvZHkuY2xpZW50V2lkdGggfHwgMDtcbiAgICBfdGVtcFJlY3QuaGVpZ2h0ID0gX3RlbXBSZWN0LmJvdHRvbSA9IChlLmlubmVySGVpZ2h0IHx8IDApIC0gMjAgPCBfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQgPyBfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQgOiBlLmlubmVySGVpZ2h0IHx8IF9ib2R5LmNsaWVudEhlaWdodCB8fCAwO1xuICAgIHJldHVybiBfdGVtcFJlY3Q7XG4gIH1cblxuICB2YXIgZG9jID0gZS5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICByID0gIV9pc1VuZGVmaW5lZChlLnBhZ2VYKSA/IHtcbiAgICBsZWZ0OiBlLnBhZ2VYIC0gX2dldERvY1Njcm9sbExlZnQoZG9jKSxcbiAgICB0b3A6IGUucGFnZVkgLSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYyksXG4gICAgcmlnaHQ6IGUucGFnZVggLSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpICsgMSxcbiAgICBib3R0b206IGUucGFnZVkgLSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYykgKyAxXG4gIH0gOiAhZS5ub2RlVHlwZSAmJiAhX2lzVW5kZWZpbmVkKGUubGVmdCkgJiYgIV9pc1VuZGVmaW5lZChlLnRvcCkgPyBlIDogX3RvQXJyYXkoZSlbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgaWYgKF9pc1VuZGVmaW5lZChyLnJpZ2h0KSAmJiAhX2lzVW5kZWZpbmVkKHIud2lkdGgpKSB7XG4gICAgci5yaWdodCA9IHIubGVmdCArIHIud2lkdGg7XG4gICAgci5ib3R0b20gPSByLnRvcCArIHIuaGVpZ2h0O1xuICB9IGVsc2UgaWYgKF9pc1VuZGVmaW5lZChyLndpZHRoKSkge1xuICAgIC8vc29tZSBicm93c2VycyBkb24ndCBpbmNsdWRlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcy4gV2UgY2FuJ3QganVzdCBzZXQgdGhlbSBkaXJlY3RseSBvbiByIGJlY2F1c2Ugc29tZSBicm93c2VycyB0aHJvdyBlcnJvcnMsIHNvIGNyZWF0ZSBhIG5ldyBnZW5lcmljIG9iamVjdC5cbiAgICByID0ge1xuICAgICAgd2lkdGg6IHIucmlnaHQgLSByLmxlZnQsXG4gICAgICBoZWlnaHQ6IHIuYm90dG9tIC0gci50b3AsXG4gICAgICByaWdodDogci5yaWdodCxcbiAgICAgIGxlZnQ6IHIubGVmdCxcbiAgICAgIGJvdHRvbTogci5ib3R0b20sXG4gICAgICB0b3A6IHIudG9wXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByO1xufSxcbiAgICBfZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KHRhcmdldCwgdHlwZSwgY2FsbGJhY2tOYW1lKSB7XG4gIHZhciB2YXJzID0gdGFyZ2V0LnZhcnMsXG4gICAgICBjYWxsYmFjayA9IHZhcnNbY2FsbGJhY2tOYW1lXSxcbiAgICAgIGxpc3RlbmVycyA9IHRhcmdldC5fbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgcmVzdWx0O1xuXG4gIGlmIChfaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICByZXN1bHQgPSBjYWxsYmFjay5hcHBseSh2YXJzLmNhbGxiYWNrU2NvcGUgfHwgdGFyZ2V0LCB2YXJzW2NhbGxiYWNrTmFtZSArIFwiUGFyYW1zXCJdIHx8IFt0YXJnZXQucG9pbnRlckV2ZW50XSk7XG4gIH1cblxuICBpZiAobGlzdGVuZXJzICYmIHRhcmdldC5kaXNwYXRjaEV2ZW50KHR5cGUpID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0sXG4gICAgX2dldEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHModGFyZ2V0LCBjb250ZXh0KSB7XG4gIC8vYWNjZXB0cyBhbnkgb2YgdGhlIGZvbGxvd2luZzogYSBET00gZWxlbWVudCwgalF1ZXJ5IG9iamVjdCwgc2VsZWN0b3IgdGV4dCwgb3IgYW4gb2JqZWN0IGRlZmluaW5nIGJvdW5kcyBhcyB7dG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0fSBvciB7bWluWCwgbWF4WCwgbWluWSwgbWF4WX0uIFJldHVybnMgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgYW5kIGhlaWdodCBwcm9wZXJ0aWVzLlxuICB2YXIgZSA9IF90b0FycmF5KHRhcmdldClbMF0sXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgb2Zmc2V0O1xuXG4gIGlmICghZS5ub2RlVHlwZSAmJiBlICE9PSBfd2luKSB7XG4gICAgaWYgKCFfaXNVbmRlZmluZWQodGFyZ2V0LmxlZnQpKSB7XG4gICAgICBvZmZzZXQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07IC8vX2dldE9mZnNldFRyYW5zZm9ybU9yaWdpbihjb250ZXh0KTsgLy90aGUgYm91bmRzIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgb3JpZ2luXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0IC0gb2Zmc2V0LngsXG4gICAgICAgIHRvcDogdGFyZ2V0LnRvcCAtIG9mZnNldC55LFxuICAgICAgICB3aWR0aDogdGFyZ2V0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRhcmdldC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGVmdCA9IHRhcmdldC5taW4gfHwgdGFyZ2V0Lm1pblggfHwgdGFyZ2V0Lm1pblJvdGF0aW9uIHx8IDA7XG4gICAgdG9wID0gdGFyZ2V0Lm1pbiB8fCB0YXJnZXQubWluWSB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdG9wOiB0b3AsXG4gICAgICB3aWR0aDogKHRhcmdldC5tYXggfHwgdGFyZ2V0Lm1heFggfHwgdGFyZ2V0Lm1heFJvdGF0aW9uIHx8IDApIC0gbGVmdCxcbiAgICAgIGhlaWdodDogKHRhcmdldC5tYXggfHwgdGFyZ2V0Lm1heFkgfHwgMCkgLSB0b3BcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXRFbGVtZW50Qm91bmRzKGUsIGNvbnRleHQpO1xufSxcbiAgICBfcG9pbnQxID0ge30sXG4gICAgLy93ZSByZXVzZSB0byBtaW5pbWl6ZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGFza3MuXG5fZ2V0RWxlbWVudEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRFbGVtZW50Qm91bmRzKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgY29udGV4dCA9IF90b0FycmF5KGNvbnRleHQpWzBdO1xuICB2YXIgaXNTVkcgPSBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5vd25lclNWR0VsZW1lbnQsXG4gICAgICBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHAxLFxuICAgICAgcDIsXG4gICAgICBwMyxcbiAgICAgIHA0LFxuICAgICAgYmJveCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgY3M7XG5cbiAgaWYgKGVsZW1lbnQgPT09IF93aW4pIHtcbiAgICB0b3AgPSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYyk7XG4gICAgbGVmdCA9IF9nZXREb2NTY3JvbGxMZWZ0KGRvYyk7XG4gICAgcmlnaHQgPSBsZWZ0ICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZWxlbWVudC5pbm5lcldpZHRoIHx8IGRvYy5ib2R5LmNsaWVudFdpZHRoIHx8IDApO1xuICAgIGJvdHRvbSA9IHRvcCArICgoZWxlbWVudC5pbm5lckhlaWdodCB8fCAwKSAtIDIwIDwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IGVsZW1lbnQuaW5uZXJIZWlnaHQgfHwgZG9jLmJvZHkuY2xpZW50SGVpZ2h0IHx8IDApOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgaWdub3JlIGFic29sdXRlbHkgcG9zaXRpb25lZCBlbGVtZW50cywgYW5kIGNvbGxhcHNlIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgc28gaXQgY291bGQgYmUgOHB4LCBmb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUganVzdCBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2LiBJbiB0aGF0IGNhc2UsIHdlIHVzZSB0aGUgaW5uZXJIZWlnaHQgdG8gcmVzb2x2ZSB0aGlzLlxuICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IF93aW4gfHwgX2lzVW5kZWZpbmVkKGNvbnRleHQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IHRvcCA9IDA7XG5cbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudC52aWV3Qm94ICYmIChiYm94ID0gZWxlbWVudC52aWV3Qm94LmJhc2VWYWwpKSB7XG4gICAgICAgIGxlZnQgPSBiYm94LnggfHwgMDtcbiAgICAgICAgdG9wID0gYmJveC55IHx8IDA7XG4gICAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgYmJveCA9IGNzLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgICAgIHdpZHRoID0gKHBhcnNlRmxvYXQoY3Mud2lkdGgpIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUZsb2F0KGNzLmJvcmRlclJpZ2h0V2lkdGgpKTtcbiAgICAgICAgaGVpZ2h0ID0gKHBhcnNlRmxvYXQoY3MuaGVpZ2h0KSB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCAwKSArIChiYm94ID8gMCA6IHBhcnNlRmxvYXQoY3MuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VGbG9hdChjcy5ib3JkZXJCb3R0b21XaWR0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJpZ2h0ID0gd2lkdGg7XG4gICAgYm90dG9tID0gaGVpZ2h0O1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgPT09IGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgfTtcbiAgfVxuXG4gIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChjb250ZXh0LCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCkpO1xuICBwMSA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3BcbiAgfSk7XG4gIHAyID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiByaWdodCxcbiAgICB5OiB0b3BcbiAgfSk7XG4gIHAzID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiByaWdodCxcbiAgICB5OiBib3R0b21cbiAgfSk7XG4gIHA0ID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiBsZWZ0LFxuICAgIHk6IGJvdHRvbVxuICB9KTtcbiAgbGVmdCA9IE1hdGgubWluKHAxLngsIHAyLngsIHAzLngsIHA0LngpO1xuICB0b3AgPSBNYXRoLm1pbihwMS55LCBwMi55LCBwMy55LCBwNC55KTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHdpZHRoOiBNYXRoLm1heChwMS54LCBwMi54LCBwMy54LCBwNC54KSAtIGxlZnQsXG4gICAgaGVpZ2h0OiBNYXRoLm1heChwMS55LCBwMi55LCBwMy55LCBwNC55KSAtIHRvcFxuICB9O1xufSxcbiAgICBfcGFyc2VJbmVydGlhID0gZnVuY3Rpb24gX3BhcnNlSW5lcnRpYShkcmFnZ2FibGUsIHNuYXAsIG1heCwgbWluLCBmYWN0b3IsIGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG4gIHZhciB2YXJzID0ge30sXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIGw7XG5cbiAgaWYgKHNuYXApIHtcbiAgICBpZiAoZmFjdG9yICE9PSAxICYmIHNuYXAgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgLy9zb21lIGRhdGEgbXVzdCBiZSBhbHRlcmVkIHRvIG1ha2Ugc2Vuc2UsIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGFuIGFycmF5IG9mIHJvdGF0aW9uYWwgdmFsdWVzIGluIGRlZ3JlZXMsIHdlIG11c3QgY29udmVydCBpdCB0byByYWRpYW5zLiBPciBmb3Igc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wLCB3ZSBpbnZlcnQgdGhlIHZhbHVlcy5cbiAgICAgIHZhcnMuZW5kID0gYSA9IFtdO1xuICAgICAgbCA9IHNuYXAubGVuZ3RoO1xuXG4gICAgICBpZiAoX2lzT2JqZWN0KHNuYXBbMF0pKSB7XG4gICAgICAgIC8vaWYgdGhlIGFycmF5IGlzIHBvcHVsYXRlZCB3aXRoIG9iamVjdHMsIGxpa2UgcG9pbnRzICh7eDoxMDAsIHk6MjAwfSksIG1ha2UgY29waWVzIGJlZm9yZSBtdWx0aXBseWluZyBieSB0aGUgZmFjdG9yLCBvdGhlcndpc2Ugd2UnbGwgbWVzcyB1cCB0aGUgb3JpZ2luYWxzIGFuZCB0aGUgdXNlciBtYXkgcmV1c2UgaXQgZWxzZXdoZXJlLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgYVtpXSA9IF9jb3B5KHNuYXBbaV0sIGZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBhW2ldID0gc25hcFtpXSAqIGZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXggKz0gMS4xOyAvL2FsbG93IDEuMSBwaXhlbHMgb2Ygd2lnZ2xlIHJvb20gd2hlbiBzbmFwcGluZyBpbiBvcmRlciB0byB3b3JrIGFyb3VuZCBzb21lIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIGluIHRoZSB3YXkgYm91bmRzIGFyZSByZXBvcnRlZCB3aGljaCBjYW4gbWFrZSB0aGVtIHJvdWdobHkgYSBwaXhlbCBvZmYuIEZvciBleGFtcGxlLCBpZiBcInNuYXA6Wy0kKCcjbWVudScpLndpZHRoKCksIDBdXCIgd2FzIGRlZmluZWQgYW5kICNtZW51IGhhZCBhIHdyYXBwZXIgdGhhdCB3YXMgdXNlZCBhcyB0aGUgYm91bmRzLCBzb21lIGJyb3dzZXJzIHdvdWxkIGJlIG9uZSBwaXhlbCBvZmYsIG1ha2luZyB0aGUgbWluaW11bSAtNzUyIGZvciBleGFtcGxlIHdoZW4gc25hcCB3YXMgWy03NTMsMF0sIHRodXMgaW5zdGVhZCBvZiBzbmFwcGluZyB0byAtNzUzLCBpdCB3b3VsZCBzbmFwIHRvIDAgc2luY2UgLTc1MyB3YXMgYmVsb3cgdGhlIG1pbmltdW0uXG5cbiAgICAgIG1pbiAtPSAxLjE7XG4gICAgfSBlbHNlIGlmIChfaXNGdW5jdGlvbihzbmFwKSkge1xuICAgICAgdmFycy5lbmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNuYXAuY2FsbChkcmFnZ2FibGUsIHZhbHVlKSxcbiAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICBwO1xuXG4gICAgICAgIGlmIChmYWN0b3IgIT09IDEpIHtcbiAgICAgICAgICBpZiAoX2lzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGNvcHkgPSB7fTtcblxuICAgICAgICAgICAgZm9yIChwIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICBjb3B5W3BdID0gcmVzdWx0W3BdICogZmFjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBjb3B5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKj0gZmFjdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7IC8vd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3ZSBjYW4gc2NvcGUgdGhlIGZ1bmN0aW9uIGNhbGwgdG8gdGhlIERyYWdnYWJsZSBpbnN0YW5jZSBpdHNlbGYgc28gdGhhdCB1c2VycyBjYW4gYWNjZXNzIGltcG9ydGFudCB2YWx1ZXMgbGlrZSBtYXhYLCBtaW5YLCBtYXhZLCBtaW5ZLCB4LCBhbmQgeSBmcm9tIHdpdGhpbiB0aGF0IGZ1bmN0aW9uLlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5lbmQgPSBzbmFwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXggfHwgbWF4ID09PSAwKSB7XG4gICAgdmFycy5tYXggPSBtYXg7XG4gIH1cblxuICBpZiAobWluIHx8IG1pbiA9PT0gMCkge1xuICAgIHZhcnMubWluID0gbWluO1xuICB9XG5cbiAgaWYgKGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG4gICAgdmFycy52ZWxvY2l0eSA9IDA7XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2lzQ2xpY2thYmxlID0gZnVuY3Rpb24gX2lzQ2xpY2thYmxlKGVsZW1lbnQpIHtcbiAgLy9zb21ldGltZXMgaXQncyBjb252ZW5pZW50IHRvIG1hcmsgYW4gZWxlbWVudCBhcyBjbGlja2FibGUgYnkgYWRkaW5nIGEgZGF0YS1jbGlja2FibGU9XCJ0cnVlXCIgYXR0cmlidXRlIChpbiB3aGljaCBjYXNlIHdlIHdvbid0IHByZXZlbnREZWZhdWx0KCkgdGhlIG1vdXNlL3RvdWNoIGV2ZW50KS4gVGhpcyBtZXRob2QgY2hlY2tzIGlmIHRoZSBlbGVtZW50IGlzIGFuIDxhPiwgPGlucHV0Piwgb3IgPGJ1dHRvbj4gb3IgaGFzIGFuIG9uY2xpY2sgb3IgaGFzIHRoZSBkYXRhLWNsaWNrYWJsZSBvciBjb250ZW50RWRpdGFibGUgYXR0cmlidXRlIHNldCB0byB0cnVlIChvciBhbnkgb2YgaXRzIHBhcmVudCBlbGVtZW50cykuXG4gIHZhciBkYXRhO1xuICByZXR1cm4gIWVsZW1lbnQgfHwgIWVsZW1lbnQuZ2V0QXR0cmlidXRlIHx8IGVsZW1lbnQgPT09IF9ib2R5ID8gZmFsc2UgOiAoZGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jbGlja2FibGVcIikpID09PSBcInRydWVcIiB8fCBkYXRhICE9PSBcImZhbHNlXCIgJiYgKGVsZW1lbnQub25jbGljayB8fCBfY2xpY2thYmxlVGFnRXhwLnRlc3QoZWxlbWVudC5ub2RlTmFtZSArIFwiXCIpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpID09PSBcInRydWVcIikgPyB0cnVlIDogX2lzQ2xpY2thYmxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XG59LFxuICAgIF9zZXRTZWxlY3RhYmxlID0gZnVuY3Rpb24gX3NldFNlbGVjdGFibGUoZWxlbWVudHMsIHNlbGVjdGFibGUpIHtcbiAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlID0gZWxlbWVudHNbaV07XG4gICAgZS5vbmRyYWdzdGFydCA9IGUub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBudWxsIDogX2VtcHR5RnVuYztcbiAgICBnc2FwLnNldChlLCB7XG4gICAgICBsYXp5OiB0cnVlLFxuICAgICAgdXNlclNlbGVjdDogc2VsZWN0YWJsZSA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICB9KTtcbiAgfVxufSxcbiAgICBfaXNGaXhlZCA9IGZ1bmN0aW9uIF9pc0ZpeGVkKGVsZW1lbnQpIHtcbiAgaWYgKF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIGF2b2lkIGRvY3VtZW50IGZyYWdtZW50cyB3aGljaCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIHJldHVybiBfaXNGaXhlZChlbGVtZW50KTtcbiAgfVxufSxcbiAgICBfc3VwcG9ydHMzRCxcbiAgICBfYWRkUGFkZGluZ0JSLFxuICAgIC8vVGhlIFNjcm9sbFByb3h5IGNsYXNzIHdyYXBzIGFuIGVsZW1lbnQncyBjb250ZW50cyBpbnRvIGFub3RoZXIgZGl2ICh3ZSBjYWxsIGl0IFwiY29udGVudFwiKSB0aGF0IHdlIGVpdGhlciBhZGQgcGFkZGluZyB3aGVuIG5lY2Vzc2FyeSBvciBhcHBseSBhIHRyYW5zbGF0ZTNkKCkgdHJhbnNmb3JtIGluIG9yZGVyIHRvIG92ZXJzY3JvbGwgKHNjcm9sbCBwYXN0IHRoZSBib3VuZGFyaWVzKS4gVGhpcyBhbGxvd3MgdXMgdG8gc2ltcGx5IHNldCB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgKG9yIHRvcC9sZWZ0IGZvciBlYXNpZXIgcmV2ZXJzZS1heGlzIG9yaWVudGF0aW9uLCB3aGljaCBpcyB3aGF0IHdlIGRvIGluIERyYWdnYWJsZSkgYW5kIGl0J2xsIGRvIGFsbCB0aGUgd29yayBmb3IgdXMuIEZvciBleGFtcGxlLCBpZiB3ZSB0cmllZCBzZXR0aW5nIHNjcm9sbFRvcCB0byAtMTAwIG9uIGEgbm9ybWFsIERPTSBlbGVtZW50LCBpdCB3b3VsZG4ndCB3b3JrIC0gaXQnZCBsb29rIHRoZSBzYW1lIGFzIHNldHRpbmcgaXQgdG8gMCwgYnV0IGlmIHdlIHNldCBzY3JvbGxUb3Agb2YgYSBTY3JvbGxQcm94eSB0byAtMTAwLCBpdCdsbCBnaXZlIHRoZSBjb3JyZWN0IGFwcGVhcmFuY2UgYnkgZWl0aGVyIHNldHRpbmcgcGFkZGluZ1RvcCBvZiB0aGUgd3JhcHBlciB0byAxMDAgb3IgYXBwbHlpbmcgYSAxMDAtcGl4ZWwgdHJhbnNsYXRlWS5cblNjcm9sbFByb3h5ID0gZnVuY3Rpb24gU2Nyb2xsUHJveHkoZWxlbWVudCwgdmFycykge1xuICBlbGVtZW50ID0gZ3NhcC51dGlscy50b0FycmF5KGVsZW1lbnQpWzBdO1xuICB2YXJzID0gdmFycyB8fCB7fTtcbiAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgc3R5bGUgPSBjb250ZW50LnN0eWxlLFxuICAgICAgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsV2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICBleHRyYVBhZFJpZ2h0ID0gMCxcbiAgICAgIG1heExlZnQgPSAwLFxuICAgICAgbWF4VG9wID0gMCxcbiAgICAgIGVsZW1lbnRXaWR0aCxcbiAgICAgIGVsZW1lbnRIZWlnaHQsXG4gICAgICBjb250ZW50SGVpZ2h0LFxuICAgICAgbmV4dE5vZGUsXG4gICAgICB0cmFuc2Zvcm1TdGFydCxcbiAgICAgIHRyYW5zZm9ybUVuZDtcblxuICBpZiAoX3N1cHBvcnRzM0QgJiYgdmFycy5mb3JjZTNEICE9PSBmYWxzZSkge1xuICAgIHRyYW5zZm9ybVN0YXJ0ID0gXCJ0cmFuc2xhdGUzZChcIjtcbiAgICB0cmFuc2Zvcm1FbmQgPSBcInB4LDBweClcIjtcbiAgfSBlbHNlIGlmIChfdHJhbnNmb3JtUHJvcCkge1xuICAgIHRyYW5zZm9ybVN0YXJ0ID0gXCJ0cmFuc2xhdGUoXCI7XG4gICAgdHJhbnNmb3JtRW5kID0gXCJweClcIjtcbiAgfVxuXG4gIHRoaXMuc2Nyb2xsVG9wID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC10aGlzLnRvcCgpO1xuICAgIH1cblxuICAgIHRoaXMudG9wKC12YWx1ZSwgZm9yY2UpO1xuICB9O1xuXG4gIHRoaXMuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtdGhpcy5sZWZ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWZ0KC12YWx1ZSwgZm9yY2UpO1xuICB9O1xuXG4gIHRoaXMubGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtKGVsZW1lbnQuc2Nyb2xsTGVmdCArIG9mZnNldExlZnQpO1xuICAgIH1cblxuICAgIHZhciBkaWYgPSBlbGVtZW50LnNjcm9sbExlZnQgLSBwcmV2TGVmdCxcbiAgICAgICAgb2xkT2Zmc2V0ID0gb2Zmc2V0TGVmdDtcblxuICAgIGlmICgoZGlmID4gMiB8fCBkaWYgPCAtMikgJiYgIWZvcmNlKSB7XG4gICAgICAvL2lmIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzY3JvbGxiYXIgKG9yIHNvbWV0aGluZyBlbHNlIHNjcm9sbHMgaXQsIGxpa2UgdGhlIG1vdXNlIHdoZWVsKSwgd2Ugc2hvdWxkIGtpbGwgYW55IHR3ZWVucyBvZiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtcbiAgICAgICAgbGVmdDogMSxcbiAgICAgICAgc2Nyb2xsTGVmdDogMVxuICAgICAgfSk7XG4gICAgICB0aGlzLmxlZnQoLXByZXZMZWZ0KTtcblxuICAgICAgaWYgKHZhcnMub25LaWxsKSB7XG4gICAgICAgIHZhcnMub25LaWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IC12YWx1ZTsgLy9pbnZlcnQgYmVjYXVzZSBzY3JvbGxpbmcgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuXG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgb2Zmc2V0TGVmdCA9IHZhbHVlIC0gMC41IHwgMDtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4TGVmdCkge1xuICAgICAgb2Zmc2V0TGVmdCA9IHZhbHVlIC0gbWF4TGVmdCB8IDA7XG4gICAgICB2YWx1ZSA9IG1heExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRMZWZ0IHx8IG9sZE9mZnNldCkge1xuICAgICAgaWYgKCF0aGlzLl9za2lwKSB7XG4gICAgICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybVN0YXJ0ICsgLW9mZnNldExlZnQgKyBcInB4LFwiICsgLW9mZnNldFRvcCArIHRyYW5zZm9ybUVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldExlZnQgKyBleHRyYVBhZFJpZ2h0ID49IDApIHtcbiAgICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gb2Zmc2V0TGVmdCArIGV4dHJhUGFkUmlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gdmFsdWUgfCAwO1xuICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0OyAvL2Rvbid0IG1lcmdlIHRoaXMgd2l0aCB0aGUgbGluZSBhYm92ZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgYWRqdXN0IHRoZSBzY3JvbGxMZWZ0IGFmdGVyIGl0J3Mgc2V0LCBzbyBpbiBvcmRlciB0byBiZSAxMDAlIGFjY3VyYXRlIGluIHRyYWNraW5nIGl0LCB3ZSBuZWVkIHRvIGFzayB0aGUgYnJvd3NlciB0byByZXBvcnQgaXQuXG4gIH07XG5cbiAgdGhpcy50b3AgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLShlbGVtZW50LnNjcm9sbFRvcCArIG9mZnNldFRvcCk7XG4gICAgfVxuXG4gICAgdmFyIGRpZiA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gcHJldlRvcCxcbiAgICAgICAgb2xkT2Zmc2V0ID0gb2Zmc2V0VG9wO1xuXG4gICAgaWYgKChkaWYgPiAyIHx8IGRpZiA8IC0yKSAmJiAhZm9yY2UpIHtcbiAgICAgIC8vaWYgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIHNjcm9sbGJhciAob3Igc29tZXRoaW5nIGVsc2Ugc2Nyb2xscyBpdCwgbGlrZSB0aGUgbW91c2Ugd2hlZWwpLCB3ZSBzaG91bGQga2lsbCBhbnkgdHdlZW5zIG9mIHRoZSBTY3JvbGxQcm94eS5cbiAgICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtcbiAgICAgICAgdG9wOiAxLFxuICAgICAgICBzY3JvbGxUb3A6IDFcbiAgICAgIH0pO1xuICAgICAgdGhpcy50b3AoLXByZXZUb3ApO1xuXG4gICAgICBpZiAodmFycy5vbktpbGwpIHtcbiAgICAgICAgdmFycy5vbktpbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbHVlID0gLXZhbHVlOyAvL2ludmVydCBiZWNhdXNlIHNjcm9sbGluZyB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICBvZmZzZXRUb3AgPSB2YWx1ZSAtIDAuNSB8IDA7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heFRvcCkge1xuICAgICAgb2Zmc2V0VG9wID0gdmFsdWUgLSBtYXhUb3AgfCAwO1xuICAgICAgdmFsdWUgPSBtYXhUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldFRvcCB8fCBvbGRPZmZzZXQpIHtcbiAgICAgIGlmICghdGhpcy5fc2tpcCkge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1TdGFydCArIC1vZmZzZXRMZWZ0ICsgXCJweCxcIiArIC1vZmZzZXRUb3AgKyB0cmFuc2Zvcm1FbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSB2YWx1ZSB8IDA7XG4gICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIHRoaXMubWF4U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhUb3A7XG4gIH07XG5cbiAgdGhpcy5tYXhTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhMZWZ0O1xuICB9O1xuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgPT09IGNvbnRlbnQucGFyZW50Tm9kZSkge1xuICAgICAgLy9pbiBjYXNlIGRpc2FibGUoKSBpcyBjYWxsZWQgd2hlbiBpdCdzIGFscmVhZHkgZGlzYWJsZWQuXG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBub2RlID0gZWxlbWVudC5maXJzdENoaWxkO1xuXG4gICAgaWYgKG5vZGUgPT09IGNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuY2FsaWJyYXRlKCk7XG4gIH07XG5cbiAgdGhpcy5jYWxpYnJhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICB2YXIgd2lkdGhNYXRjaGVzID0gZWxlbWVudC5jbGllbnRXaWR0aCA9PT0gZWxlbWVudFdpZHRoLFxuICAgICAgICBjcyxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcbiAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG5cbiAgICBpZiAod2lkdGhNYXRjaGVzICYmIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID09PSBlbGVtZW50SGVpZ2h0ICYmIGNvbnRlbnQub2Zmc2V0SGVpZ2h0ID09PSBjb250ZW50SGVpZ2h0ICYmIHNjcm9sbFdpZHRoID09PSBlbGVtZW50LnNjcm9sbFdpZHRoICYmIHNjcm9sbEhlaWdodCA9PT0gZWxlbWVudC5zY3JvbGxIZWlnaHQgJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47IC8vbm8gbmVlZCB0byByZWNhbGN1bGF0ZSB0aGluZ3MgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgIH1cblxuICAgIGlmIChvZmZzZXRUb3AgfHwgb2Zmc2V0TGVmdCkge1xuICAgICAgeCA9IHRoaXMubGVmdCgpO1xuICAgICAgeSA9IHRoaXMudG9wKCk7XG4gICAgICB0aGlzLmxlZnQoLWVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICB0aGlzLnRvcCgtZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIH1cblxuICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7IC8vZmlyc3QsIHdlIG5lZWQgdG8gcmVtb3ZlIGFueSB3aWR0aCBjb25zdHJhaW50cyB0byBzZWUgaG93IHRoZSBjb250ZW50IG5hdHVyYWxseSBmbG93cyBzbyB0aGF0IHdlIGNhbiBzZWUgaWYgaXQncyB3aWRlciB0aGFuIHRoZSBjb250YWluaW5nIGVsZW1lbnQuIElmIHNvLCB3ZSd2ZSBnb3QgdG8gcmVjb3JkIHRoZSBhbW91bnQgb2Ygb3ZlcmFnZSBzbyB0aGF0IHdlIGNhbiBhcHBseSB0aGF0IGFzIHBhZGRpbmcgaW4gb3JkZXIgZm9yIGJyb3dzZXJzIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhpbmdzLiBUaGVuIHdlIHN3aXRjaCBiYWNrIHRvIGEgd2lkdGggb2YgMTAwJSAod2l0aG91dCB0aGF0LCBzb21lIGJyb3dzZXJzIGRvbid0IGZsb3cgdGhlIGNvbnRlbnQgY29ycmVjdGx5KVxuXG4gICAgaWYgKCF3aWR0aE1hdGNoZXMgfHwgZm9yY2UpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBzdHlsZS53aWR0aCA9IFwiYXV0b1wiO1xuICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwcHhcIjtcbiAgICAgIGV4dHJhUGFkUmlnaHQgPSBNYXRoLm1heCgwLCBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCk7IC8vaWYgdGhlIGNvbnRlbnQgaXMgd2lkZXIgdGhhbiB0aGUgY29udGFpbmVyLCB3ZSBuZWVkIHRvIGFkZCB0aGUgcGFkZGluZ0xlZnQgYW5kIHBhZGRpbmdSaWdodCBpbiBvcmRlciBmb3IgdGhpbmdzIHRvIGJlaGF2ZSBjb3JyZWN0bHkuXG5cbiAgICAgIGlmIChleHRyYVBhZFJpZ2h0KSB7XG4gICAgICAgIGV4dHJhUGFkUmlnaHQgKz0gcGFyc2VGbG9hdChjcy5wYWRkaW5nTGVmdCkgKyAoX2FkZFBhZGRpbmdCUiA/IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgc3R5bGUudmVydGljYWxBbGlnbiA9IFwidG9wXCI7XG4gICAgc3R5bGUuYm94U2l6aW5nID0gXCJjb250ZW50LWJveFwiO1xuICAgIHN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gZXh0cmFQYWRSaWdodCArIFwicHhcIjsgLy9zb21lIGJyb3dzZXJzIG5lZ2xlY3QgdG8gZmFjdG9yIGluIHRoZSBib3R0b20gcGFkZGluZyB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzY3JvbGxIZWlnaHQsIHNvIHdlIG5lZWQgdG8gYWRkIHRoYXQgcGFkZGluZyB0byB0aGUgY29udGVudCB3aGVuIHRoYXQgaGFwcGVucy4gQWxsb3cgYSAycHggbWFyZ2luIGZvciBlcnJvclxuXG4gICAgaWYgKF9hZGRQYWRkaW5nQlIpIHtcbiAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBjcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cblxuICAgIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICBtYXhMZWZ0ID0gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnRXaWR0aDtcbiAgICBtYXhUb3AgPSBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29udGVudEhlaWdodCA9IGNvbnRlbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICB0aGlzLmxlZnQoeCk7XG4gICAgICB0aGlzLnRvcCh5KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fc2tpcCA9IGZhbHNlO1xuICB0aGlzLmVuYWJsZSgpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUocmVxdWlyZWQpIHtcbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgdmFyIG5hdiA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgX3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfc3VwcG9ydHNQb2ludGVyID0gISF3aW5kb3cuUG9pbnRlckV2ZW50O1xuICAgIF9wbGFjZWhvbGRlckRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF9wbGFjZWhvbGRlckRpdi5zdHlsZS5jc3NUZXh0ID0gXCJ2aXNpYmlsaXR5OmhpZGRlbjtoZWlnaHQ6MXB4O3RvcDotMXB4O3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7Y2xlYXI6Ym90aDtjdXJzb3I6Z3JhYlwiO1xuICAgIF9kZWZhdWx0Q3Vyc29yID0gX3BsYWNlaG9sZGVyRGl2LnN0eWxlLmN1cnNvciA9PT0gXCJncmFiXCIgPyBcImdyYWJcIiA6IFwibW92ZVwiO1xuICAgIF9pc0FuZHJvaWQgPSBuYXYgJiYgbmF2LnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmRyb2lkXCIpICE9PSAtMTsgLy9BbmRyb2lkIGhhbmRsZXMgdG91Y2ggZXZlbnRzIGluIGFuIG9kZCB3YXkgYW5kIGl0J3MgdmlydHVhbGx5IGltcG9zc2libGUgdG8gXCJmZWF0dXJlIHRlc3RcIiBzbyB3ZSByZXNvcnQgdG8gVUEgc25pZmZpbmdcblxuICAgIF9pc1RvdWNoRGV2aWNlID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBfZG9jRWxlbWVudCAmJiBcIm9yaWVudGF0aW9uXCIgaW4gX3dpbiB8fCBuYXYgJiYgKG5hdi5NYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2Lm1zTWF4VG91Y2hQb2ludHMgPiAwKTtcblxuICAgIF9hZGRQYWRkaW5nQlIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvL3RoaXMgZnVuY3Rpb24gaXMgaW4gY2hhcmdlIG9mIGFuYWx5emluZyBicm93c2VyIGJlaGF2aW9yIHJlbGF0ZWQgdG8gcGFkZGluZy4gSXQgc2V0cyB0aGUgX2FkZFBhZGRpbmdCUiB0byB0cnVlIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgbm9ybWFsbHkgZmFjdG9yIGluIHRoZSBib3R0b20gb3IgcmlnaHQgcGFkZGluZyBvbiB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIHNjcm9sbGluZyBhcmVhLCBhbmQgaXQgc2V0cyBfYWRkUGFkZGluZ0xlZnQgdG8gdHJ1ZSBpZiBpdCdzIGEgYnJvd3NlciB0aGF0IHJlcXVpcmVzIHRoZSBleHRyYSBvZmZzZXQgKG9mZnNldExlZnQpIHRvIGJlIGFkZGVkIHRvIHRoZSBwYWRkaW5nUmlnaHQgKGxpa2UgT3BlcmEpLlxuICAgICAgdmFyIGRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgIGNoaWxkID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgY2hpbGRTdHlsZSA9IGNoaWxkLnN0eWxlLFxuICAgICAgICAgIHBhcmVudCA9IF9ib2R5LFxuICAgICAgICAgIHZhbDtcblxuICAgICAgY2hpbGRTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgIGNoaWxkU3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6OTBweDtoZWlnaHQ6NDBweDtwYWRkaW5nOjEwcHg7b3ZlcmZsb3c6YXV0bzt2aXNpYmlsaXR5OmhpZGRlblwiO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgdmFsID0gY2hpbGQub2Zmc2V0SGVpZ2h0ICsgMTggPiBkaXYuc2Nyb2xsSGVpZ2h0OyAvL2Rpdi5zY3JvbGxIZWlnaHQgc2hvdWxkIGJlIGNoaWxkLm9mZnNldEhlaWdodCArIDIwIGJlY2F1c2Ugb2YgdGhlIDEwcHggb2YgcGFkZGluZyBvbiBlYWNoIHNpZGUsIGJ1dCBzb21lIGJyb3dzZXJzIGlnbm9yZSBvbmUgc2lkZS4gV2UgYWxsb3cgYSAycHggbWFyZ2luIG9mIGVycm9yLlxuXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSgpO1xuXG4gICAgX3RvdWNoRXZlbnRMb29rdXAgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgIC8vd2UgY3JlYXRlIGFuIG9iamVjdCB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gdHJhbnNsYXRlIHRvdWNoIGV2ZW50IHR5cGVzIGludG8gdGhlaXIgXCJwb2ludGVyXCIgY291bnRlcnBhcnRzIGlmIHdlJ3JlIGluIGEgYnJvd3NlciB0aGF0IHVzZXMgdGhvc2UgaW5zdGVhZC4gTGlrZSBJRTEwIHVzZXMgXCJNU1BvaW50ZXJEb3duXCIgaW5zdGVhZCBvZiBcInRvdWNoc3RhcnRcIiwgZm9yIGV4YW1wbGUuXG4gICAgICB2YXIgc3RhbmRhcmQgPSB0eXBlcy5zcGxpdChcIixcIiksXG4gICAgICAgICAgY29udmVydGVkID0gKFwib25wb2ludGVyZG93blwiIGluIF90ZW1wRGl2ID8gXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVydXAscG9pbnRlcmNhbmNlbFwiIDogXCJvbm1zcG9pbnRlcmRvd25cIiBpbiBfdGVtcERpdiA/IFwiTVNQb2ludGVyRG93bixNU1BvaW50ZXJNb3ZlLE1TUG9pbnRlclVwLE1TUG9pbnRlckNhbmNlbFwiIDogdHlwZXMpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICBpID0gNDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIG9ialtzdGFuZGFyZFtpXV0gPSBjb252ZXJ0ZWRbaV07XG4gICAgICAgIG9ialtjb252ZXJ0ZWRbaV1dID0gc3RhbmRhcmRbaV07XG4gICAgICB9IC8vdG8gYXZvaWQgcHJvYmxlbXMgaW4gaU9TIDksIHRlc3QgdG8gc2VlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBcInBhc3NpdmVcIiBvcHRpb24gb24gYWRkRXZlbnRMaXN0ZW5lcigpLlxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIF9kb2NFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIF9zdXBwb3J0c1Bhc3NpdmUgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KFwidG91Y2hzdGFydCx0b3VjaG1vdmUsdG91Y2hlbmQsdG91Y2hjYW5jZWxcIik7XG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfZW1wdHlGdW5jKTsgLy9zb21lIG9sZGVyIEFuZHJvaWQgZGV2aWNlcyBpbnRlcm1pdHRlbnRseSBzdG9wIGRpc3BhdGNoaW5nIFwidG91Y2htb3ZlXCIgZXZlbnRzIGlmIHdlIGRvbid0IGxpc3RlbiBmb3IgXCJ0b3VjaGNhbmNlbFwiIG9uIHRoZSBkb2N1bWVudC4gVmVyeSBzdHJhbmdlIGluZGVlZC5cblxuXG4gICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2htb3ZlXCIsIF9lbXB0eUZ1bmMpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVncyB0aGF0IHN0aWxsIGFsbG93IHRoZSBwYWdlIHRvIHNjcm9sbCBldmVuIHdoZW4gd2UgcHJldmVudERlZmF1bHQoKSBvbiB0aGUgdG91Y2htb3ZlIGV2ZW50LlxuXG5cbiAgICBfYm9keSAmJiBfYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfZW1wdHlGdW5jKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gX2xvb2t1cCkge1xuICAgICAgICBpZiAoX2xvb2t1cFtwXS5pc1ByZXNzZWQpIHtcbiAgICAgICAgICBfbG9va3VwW3BdLmVuZERyYWcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZ3NhcCA9IF9jb3JlSW5pdHRlZCA9IF9nZXRHU0FQKCk7XG4gIH1cblxuICBpZiAoZ3NhcCkge1xuICAgIEluZXJ0aWFQbHVnaW4gPSBnc2FwLnBsdWdpbnMuaW5lcnRpYTtcbiAgICBfY2hlY2tQcmVmaXggPSBnc2FwLnV0aWxzLmNoZWNrUHJlZml4O1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJlZml4KF90cmFuc2Zvcm1Qcm9wKTtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtT3JpZ2luUHJvcCk7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgX3N1cHBvcnRzM0QgPSAhIV9jaGVja1ByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICB9IGVsc2UgaWYgKHJlcXVpcmVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlKVwiKTtcbiAgfVxufTtcblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcblxuICAgIGlmICghfmxpc3QuaW5kZXhPZihjYWxsYmFjaykpIHtcbiAgICAgIGxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgICBpID0gbGlzdCAmJiBsaXN0LmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGkgPj0gMCAmJiBsaXN0LnNwbGljZShpLCAxKTtcbiAgfTtcblxuICBfcHJvdG8uZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodHlwZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpcywge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YXJnZXQ6IF90aGlzLnRhcmdldFxuICAgICAgfSkgPT09IGZhbHNlICYmIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDsgLy9pZiBhbnkgb2YgdGhlIGNhbGxiYWNrcyByZXR1cm4gZmFsc2UsIHBhc3MgdGhhdCBhbG9uZy5cbiAgfTtcblxuICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xufSgpO1xuXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RGlzcGF0Y2hlcikge1xuICBfaW5oZXJpdHNMb29zZShEcmFnZ2FibGUsIF9FdmVudERpc3BhdGNoZXIpO1xuXG4gIGZ1bmN0aW9uIERyYWdnYWJsZSh0YXJnZXQsIHZhcnMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX3RoaXMyID0gX0V2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgxKTtcbiAgICB0YXJnZXQgPSBfdG9BcnJheSh0YXJnZXQpWzBdOyAvL2luIGNhc2UgdGhlIHRhcmdldCBpcyBhIHNlbGVjdG9yIG9iamVjdCBvciBzZWxlY3RvciB0ZXh0XG5cbiAgICBpZiAoIUluZXJ0aWFQbHVnaW4pIHtcbiAgICAgIEluZXJ0aWFQbHVnaW4gPSBnc2FwLnBsdWdpbnMuaW5lcnRpYTtcbiAgICB9XG5cbiAgICBfdGhpczIudmFycyA9IHZhcnMgPSBfY29weSh2YXJzIHx8IHt9KTtcbiAgICBfdGhpczIudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIF90aGlzMi54ID0gX3RoaXMyLnkgPSBfdGhpczIucm90YXRpb24gPSAwO1xuICAgIF90aGlzMi5kcmFnUmVzaXN0YW5jZSA9IHBhcnNlRmxvYXQodmFycy5kcmFnUmVzaXN0YW5jZSkgfHwgMDtcbiAgICBfdGhpczIuZWRnZVJlc2lzdGFuY2UgPSBpc05hTih2YXJzLmVkZ2VSZXNpc3RhbmNlKSA/IDEgOiBwYXJzZUZsb2F0KHZhcnMuZWRnZVJlc2lzdGFuY2UpIHx8IDA7XG4gICAgX3RoaXMyLmxvY2tBeGlzID0gdmFycy5sb2NrQXhpcztcbiAgICBfdGhpczIuYXV0b1Njcm9sbCA9IHZhcnMuYXV0b1Njcm9sbCB8fCAwO1xuICAgIF90aGlzMi5sb2NrZWRBeGlzID0gbnVsbDtcbiAgICBfdGhpczIuYWxsb3dFdmVudERlZmF1bHQgPSAhIXZhcnMuYWxsb3dFdmVudERlZmF1bHQ7XG4gICAgZ3NhcC5nZXRQcm9wZXJ0eSh0YXJnZXQsIFwieFwiKTsgLy8gdG8gZW5zdXJlIHRoYXQgdHJhbnNmb3JtcyBhcmUgaW5zdGFudGlhdGVkLlxuXG4gICAgdmFyIHR5cGUgPSAodmFycy50eXBlIHx8IFwieCx5XCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHh5TW9kZSA9IH50eXBlLmluZGV4T2YoXCJ4XCIpIHx8IH50eXBlLmluZGV4T2YoXCJ5XCIpLFxuICAgICAgICByb3RhdGlvbk1vZGUgPSB0eXBlLmluZGV4T2YoXCJyb3RhdGlvblwiKSAhPT0gLTEsXG4gICAgICAgIHhQcm9wID0gcm90YXRpb25Nb2RlID8gXCJyb3RhdGlvblwiIDogeHlNb2RlID8gXCJ4XCIgOiBcImxlZnRcIixcbiAgICAgICAgeVByb3AgPSB4eU1vZGUgPyBcInlcIiA6IFwidG9wXCIsXG4gICAgICAgIGFsbG93WCA9ICEhKH50eXBlLmluZGV4T2YoXCJ4XCIpIHx8IH50eXBlLmluZGV4T2YoXCJsZWZ0XCIpIHx8IHR5cGUgPT09IFwic2Nyb2xsXCIpLFxuICAgICAgICBhbGxvd1kgPSAhISh+dHlwZS5pbmRleE9mKFwieVwiKSB8fCB+dHlwZS5pbmRleE9mKFwidG9wXCIpIHx8IHR5cGUgPT09IFwic2Nyb2xsXCIpLFxuICAgICAgICBtaW5pbXVtTW92ZW1lbnQgPSB2YXJzLm1pbmltdW1Nb3ZlbWVudCB8fCAyLFxuICAgICAgICBzZWxmID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpLFxuICAgICAgICB0cmlnZ2VycyA9IF90b0FycmF5KHZhcnMudHJpZ2dlciB8fCB2YXJzLmhhbmRsZSB8fCB0YXJnZXQpLFxuICAgICAgICBraWxsUHJvcHMgPSB7fSxcbiAgICAgICAgZHJhZ0VuZFRpbWUgPSAwLFxuICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBmYWxzZSxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpblRvcCA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpblRvcCB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpblJpZ2h0ID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luUmlnaHQgfHwgNDAsXG4gICAgICAgIGF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gfHwgNDAsXG4gICAgICAgIGF1dG9TY3JvbGxNYXJnaW5MZWZ0ID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luTGVmdCB8fCA0MCxcbiAgICAgICAgaXNDbGlja2FibGUgPSB2YXJzLmNsaWNrYWJsZVRlc3QgfHwgX2lzQ2xpY2thYmxlLFxuICAgICAgICBjbGlja1RpbWUgPSAwLFxuICAgICAgICBnc0NhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgICBpc0ZpeGVkID0gX2lzRml4ZWQodGFyZ2V0KSxcbiAgICAgICAgZ2V0UHJvcEFzTnVtID0gZnVuY3Rpb24gZ2V0UHJvcEFzTnVtKHByb3BlcnR5LCB1bml0KSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChnc0NhY2hlLmdldCh0YXJnZXQsIHByb3BlcnR5LCB1bml0KSk7XG4gICAgfSxcbiAgICAgICAgb3duZXJEb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBzY3JvbGxQcm94eSxcbiAgICAgICAgc3RhcnRQb2ludGVyWCxcbiAgICAgICAgc3RhcnRQb2ludGVyWSxcbiAgICAgICAgc3RhcnRFbGVtZW50WCxcbiAgICAgICAgc3RhcnRFbGVtZW50WSxcbiAgICAgICAgaGFzQm91bmRzLFxuICAgICAgICBoYXNEcmFnQ2FsbGJhY2ssXG4gICAgICAgIGhhc01vdmVDYWxsYmFjayxcbiAgICAgICAgbWF4WCxcbiAgICAgICAgbWluWCxcbiAgICAgICAgbWF4WSxcbiAgICAgICAgbWluWSxcbiAgICAgICAgdG91Y2gsXG4gICAgICAgIHRvdWNoSUQsXG4gICAgICAgIHJvdGF0aW9uT3JpZ2luLFxuICAgICAgICBkaXJ0eSxcbiAgICAgICAgb2xkLFxuICAgICAgICBzbmFwWCxcbiAgICAgICAgc25hcFksXG4gICAgICAgIHNuYXBYWSxcbiAgICAgICAgaXNDbGlja2luZyxcbiAgICAgICAgdG91Y2hFdmVudFRhcmdldCxcbiAgICAgICAgbWF0cml4LFxuICAgICAgICBpbnRlcnJ1cHRlZCxcbiAgICAgICAgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyxcbiAgICAgICAgdG91Y2hEcmFnQXhpcyxcbiAgICAgICAgaXNEaXNwYXRjaGluZyxcbiAgICAgICAgY2xpY2tEaXNwYXRjaCxcbiAgICAgICAgdHJ1c3RlZENsaWNrRGlzcGF0Y2gsXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQsXG4gICAgICAgIGlubmVyTWF0cml4LFxuICAgICAgICBkcmFnZ2VkLFxuICAgICAgICBvbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gb25Db250ZXh0TWVudShlKSB7XG4gICAgICAvL3VzZWQgdG8gcHJldmVudCBsb25nLXRvdWNoIGZyb20gdHJpZ2dlcmluZyBhIGNvbnRleHQgbWVudS5cbiAgICAgIC8vIChzZWxmLmlzUHJlc3NlZCAmJiBlLndoaWNoIDwgMikgJiYgc2VsZi5lbmREcmFnKCkgLy8gcHJldmlvdXNseSBlbmRlZCBkcmFnIHdoZW4gY29udGV4dCBtZW51IHdhcyB0cmlnZ2VyZWQsIGJ1dCBpbnN0ZWFkIHdlIHNob3VsZCBqdXN0IHN0b3AgcHJvcGFnYXRpb24gYW5kIHByZXZlbnQgdGhlIGRlZmF1bHQgZXZlbnQgYmVoYXZpb3IuXG4gICAgICBfcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAgICAgLy90aGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBvbiBldmVyeSB0aWNrIG9mIFR3ZWVuTGl0ZS50aWNrZXIgd2hpY2ggYWxsb3dzIHVzIHRvIHN5bmNocm9uaXplIHRoZSByZW5kZXJzIHRvIHRoZSBjb3JlIGVuZ2luZSAod2hpY2ggaXMgdHlwaWNhbGx5IHN5bmNocm9uaXplZCB3aXRoIHRoZSBkaXNwbGF5IHJlZnJlc2ggdmlhIHJlcXVlc3RBbmltYXRpb25GcmFtZSkuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIC0gaXQncyBiZXR0ZXIgdGhhbiBhcHBseWluZyB0aGUgdmFsdWVzIGluc2lkZSB0aGUgXCJtb3VzZW1vdmVcIiBvciBcInRvdWNobW92ZVwiIGV2ZW50IGhhbmRsZXIgd2hpY2ggbWF5IGdldCBjYWxsZWQgbWFueSB0aW1lcyBpbmJldHdlZW4gcmVmcmVzaGVzLlxuICAgIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzdXBwcmVzc0V2ZW50cykge1xuICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCAmJiBzZWxmLmlzRHJhZ2dpbmcgJiYgKGNoZWNrQXV0b1Njcm9sbEJvdW5kcyB8fCBkaXJ0eSkpIHtcbiAgICAgICAgdmFyIGUgPSB0YXJnZXQsXG4gICAgICAgICAgICBhdXRvU2Nyb2xsRmFjdG9yID0gc2VsZi5hdXRvU2Nyb2xsICogMTUsXG4gICAgICAgICAgICAvL211bHRpcGx5aW5nIGJ5IDE1IGp1c3QgZ2l2ZXMgdXMgYSBiZXR0ZXIgXCJmZWVsXCIgc3BlZWQtd2lzZS5cbiAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgaXNSb290LFxuICAgICAgICAgICAgcmVjdCxcbiAgICAgICAgICAgIHBvaW50ZXJYLFxuICAgICAgICAgICAgcG9pbnRlclksXG4gICAgICAgICAgICBjaGFuZ2VYLFxuICAgICAgICAgICAgY2hhbmdlWSxcbiAgICAgICAgICAgIGdhcDtcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gZmFsc2U7XG4gICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxUb3AgPSBfd2luLnBhZ2VZT2Zmc2V0ICE9IG51bGwgPyBfd2luLnBhZ2VZT2Zmc2V0IDogb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPSBudWxsID8gb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsTGVmdCA9IF93aW4ucGFnZVhPZmZzZXQgIT0gbnVsbCA/IF93aW4ucGFnZVhPZmZzZXQgOiBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCAhPSBudWxsID8gb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBvd25lckRvYy5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgIHBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCAtIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0O1xuICAgICAgICBwb2ludGVyWSA9IHNlbGYucG9pbnRlclkgLSBfd2luZG93UHJveHkuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHdoaWxlIChlICYmICFpc1Jvb3QpIHtcbiAgICAgICAgICAvL3dhbGsgdXAgdGhlIGNoYWluIGFuZCBzZW5zZSB3aGVyZXZlciB0aGUgcG9pbnRlciBpcyB3aXRoaW4gNDBweCBvZiBhbiBlZGdlIHRoYXQncyBzY3JvbGxhYmxlLlxuICAgICAgICAgIGlzUm9vdCA9IF9pc1Jvb3QoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBwYXJlbnQgPSBpc1Jvb3QgPyBfd2luZG93UHJveHkgOiBlLnBhcmVudE5vZGU7XG4gICAgICAgICAgcmVjdCA9IGlzUm9vdCA/IHtcbiAgICAgICAgICAgIGJvdHRvbTogTWF0aC5tYXgoX2RvY0VsZW1lbnQuY2xpZW50SGVpZ2h0LCBfd2luLmlubmVySGVpZ2h0IHx8IDApLFxuICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KF9kb2NFbGVtZW50LmNsaWVudFdpZHRoLCBfd2luLmlubmVyV2lkdGggfHwgMCksXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgfSA6IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBjaGFuZ2VYID0gY2hhbmdlWSA9IDA7XG5cbiAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICBnYXAgPSBwYXJlbnQuX2dzTWF4U2Nyb2xsWSAtIHBhcmVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICAgIGNoYW5nZVkgPSBnYXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJZID4gcmVjdC5ib3R0b20gLSBhdXRvU2Nyb2xsTWFyZ2luQm90dG9tICYmIGdhcCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VZID0gTWF0aC5taW4oZ2FwLCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCByZWN0LmJvdHRvbSAtIHBvaW50ZXJZKSAvIGF1dG9TY3JvbGxNYXJnaW5Cb3R0b20pIHwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJZIDwgcmVjdC50b3AgKyBhdXRvU2Nyb2xsTWFyZ2luVG9wICYmIHBhcmVudC5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWSA9IC1NYXRoLm1pbihwYXJlbnQuc2Nyb2xsVG9wLCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCBwb2ludGVyWSAtIHJlY3QudG9wKSAvIGF1dG9TY3JvbGxNYXJnaW5Ub3ApIHwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VZKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5zY3JvbGxUb3AgKz0gY2hhbmdlWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICBnYXAgPSBwYXJlbnQuX2dzTWF4U2Nyb2xsWCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICBpZiAoZ2FwIDwgMCkge1xuICAgICAgICAgICAgICBjaGFuZ2VYID0gZ2FwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWCA+IHJlY3QucmlnaHQgLSBhdXRvU2Nyb2xsTWFyZ2luUmlnaHQgJiYgZ2FwKSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVggPSBNYXRoLm1pbihnYXAsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHJlY3QucmlnaHQgLSBwb2ludGVyWCkgLyBhdXRvU2Nyb2xsTWFyZ2luUmlnaHQpIHwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJYIDwgcmVjdC5sZWZ0ICsgYXV0b1Njcm9sbE1hcmdpbkxlZnQgJiYgcGFyZW50LnNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWCA9IC1NYXRoLm1pbihwYXJlbnQuc2Nyb2xsTGVmdCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcG9pbnRlclggLSByZWN0LmxlZnQpIC8gYXV0b1Njcm9sbE1hcmdpbkxlZnQpIHwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VYKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5zY3JvbGxMZWZ0ICs9IGNoYW5nZVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUm9vdCAmJiAoY2hhbmdlWCB8fCBjaGFuZ2VZKSkge1xuICAgICAgICAgICAgX3dpbi5zY3JvbGxUbyhwYXJlbnQuc2Nyb2xsTGVmdCwgcGFyZW50LnNjcm9sbFRvcCk7XG5cbiAgICAgICAgICAgIHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYICsgY2hhbmdlWCwgc2VsZi5wb2ludGVyWSArIGNoYW5nZVkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgIHZhciB4ID0gc2VsZi54LFxuICAgICAgICAgICAgeSA9IHNlbGYueTtcblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5kZWx0YVggPSB4IC0gcGFyc2VGbG9hdChnc0NhY2hlLnJvdGF0aW9uKTtcbiAgICAgICAgICBzZWxmLnJvdGF0aW9uID0geDtcbiAgICAgICAgICBnc0NhY2hlLnJvdGF0aW9uID0geCArIFwiZGVnXCI7XG4gICAgICAgICAgZ3NDYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgZ3NDYWNoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFZID0geSAtIHNjcm9sbFByb3h5LnRvcCgpO1xuICAgICAgICAgICAgICBzY3JvbGxQcm94eS50b3AoeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVggPSB4IC0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgICAgICAgICBzY3JvbGxQcm94eS5sZWZ0KHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoeHlNb2RlKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFZID0geSAtIHBhcnNlRmxvYXQoZ3NDYWNoZS55KTtcbiAgICAgICAgICAgICAgZ3NDYWNoZS55ID0geSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KGdzQ2FjaGUueCk7XG4gICAgICAgICAgICAgIGdzQ2FjaGUueCA9IHggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdzQ2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGdzQ2FjaGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFZID0geSAtIHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLnRvcCB8fCAwKTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVggPSB4IC0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCB8fCAwKTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEcmFnQ2FsbGJhY2sgJiYgIXN1cHByZXNzRXZlbnRzICYmICFpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7IC8vaW4gY2FzZSBvbkRyYWcgaGFzIGFuIHVwZGF0ZSgpIGNhbGwgKGF2b2lkIGVuZGxlc3MgbG9vcClcblxuICAgICAgICAgIGlmIChfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdcIiwgXCJvbkRyYWdcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYueCAtPSBzZWxmLmRlbHRhWDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLnkgLT0gc2VsZi5kZWx0YVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICB9LFxuICAgICAgICAvL2NvcGllcyB0aGUgeC95IGZyb20gdGhlIGVsZW1lbnQgKHdoZXRoZXIgdGhhdCBiZSB0cmFuc2Zvcm1zLCB0b3AvbGVmdCwgb3IgU2Nyb2xsUHJveHkncyB0b3AvbGVmdCkgdG8gdGhlIERyYWdnYWJsZSdzIHggYW5kIHkgKGFuZCByb3RhdGlvbiBpZiBuZWNlc3NhcnkpIHByb3BlcnRpZXMgc28gdGhhdCB0aGV5IHJlZmxlY3QgcmVhbGl0eSBhbmQgaXQgYWxzbyAob3B0aW9uYWxseSkgYXBwbGllcyBhbnkgc25hcHBpbmcgbmVjZXNzYXJ5LiBUaGlzIGlzIHVzZWQgYnkgdGhlIEluZXJ0aWFQbHVnaW4gdHdlZW4gaW4gYW4gb25VcGRhdGUgdG8gZW5zdXJlIHRoaW5ncyBhcmUgc3luY2VkIGFuZCBzbmFwcGVkLlxuICAgIHN5bmNYWSA9IGZ1bmN0aW9uIHN5bmNYWShza2lwT25VcGRhdGUsIHNraXBTbmFwKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueCxcbiAgICAgICAgICB5ID0gc2VsZi55LFxuICAgICAgICAgIHNuYXBwZWRWYWx1ZSxcbiAgICAgICAgICBjcztcblxuICAgICAgaWYgKCF0YXJnZXQuX2dzYXApIHtcbiAgICAgICAgLy9qdXN0IGluIGNhc2UgdGhlIF9nc2FwIGNhY2hlIGdvdCB3aXBlZCwgbGlrZSBpZiB0aGUgdXNlciBjYWxsZWQgY2xlYXJQcm9wcyBvbiB0aGUgdHJhbnNmb3JtIG9yIHNvbWV0aGluZyAodmVyeSByYXJlKS5cbiAgICAgICAgZ3NDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBnc0NhY2hlLnVuY2FjaGUgJiYgZ3NhcC5nZXRQcm9wZXJ0eSh0YXJnZXQsIFwieFwiKTsgLy8gdHJpZ2dlciBhIHJlLWNhY2hlXG5cbiAgICAgIGlmICh4eU1vZGUpIHtcbiAgICAgICAgc2VsZi54ID0gcGFyc2VGbG9hdChnc0NhY2hlLngpO1xuICAgICAgICBzZWxmLnkgPSBwYXJzZUZsb2F0KGdzQ2FjaGUueSk7XG4gICAgICB9IGVsc2UgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICBzZWxmLnggPSBzZWxmLnJvdGF0aW9uID0gcGFyc2VGbG9hdChnc0NhY2hlLnJvdGF0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgc2VsZi55ID0gc2Nyb2xsUHJveHkudG9wKCk7XG4gICAgICAgIHNlbGYueCA9IHNjcm9sbFByb3h5LmxlZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYueSA9IHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLnRvcCB8fCAoY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpKSAmJiBjcy50b3ApIHx8IDA7XG4gICAgICAgIHNlbGYueCA9IHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQgfHwgKGNzIHx8IHt9KS5sZWZ0KSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHNuYXBYIHx8IHNuYXBZIHx8IHNuYXBYWSkgJiYgIXNraXBTbmFwICYmIChzZWxmLmlzRHJhZ2dpbmcgfHwgc2VsZi5pc1Rocm93aW5nKSkge1xuICAgICAgICBpZiAoc25hcFhZKSB7XG4gICAgICAgICAgX3RlbXAxLnggPSBzZWxmLng7XG4gICAgICAgICAgX3RlbXAxLnkgPSBzZWxmLnk7XG4gICAgICAgICAgc25hcHBlZFZhbHVlID0gc25hcFhZKF90ZW1wMSk7XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlLnggIT09IHNlbGYueCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc25hcHBlZFZhbHVlLng7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZS55ICE9PSBzZWxmLnkpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNuYXBwZWRWYWx1ZS55O1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwWCkge1xuICAgICAgICAgIHNuYXBwZWRWYWx1ZSA9IHNuYXBYKHNlbGYueCk7XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlICE9PSBzZWxmLngpIHtcbiAgICAgICAgICAgIHNlbGYueCA9IHNuYXBwZWRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgICBzZWxmLnJvdGF0aW9uID0gc25hcHBlZFZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBZKSB7XG4gICAgICAgICAgc25hcHBlZFZhbHVlID0gc25hcFkoc2VsZi55KTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUgIT09IHNlbGYueSkge1xuICAgICAgICAgICAgc2VsZi55ID0gc25hcHBlZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXJ0eSAmJiByZW5kZXIodHJ1ZSk7XG5cbiAgICAgIGlmICghc2tpcE9uVXBkYXRlKSB7XG4gICAgICAgIHNlbGYuZGVsdGFYID0gc2VsZi54IC0geDtcbiAgICAgICAgc2VsZi5kZWx0YVkgPSBzZWxmLnkgLSB5O1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwidGhyb3d1cGRhdGVcIiwgXCJvblRocm93VXBkYXRlXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGJ1aWxkU25hcEZ1bmMgPSBmdW5jdGlvbiBidWlsZFNuYXBGdW5jKHNuYXAsIG1pbiwgbWF4LCBmYWN0b3IpIHtcbiAgICAgIGlmIChtaW4gPT0gbnVsbCkge1xuICAgICAgICBtaW4gPSAtX2JpZ051bTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICAgIG1heCA9IF9iaWdOdW07XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICB2YXIgZWRnZVRvbGVyYW5jZSA9ICFzZWxmLmlzUHJlc3NlZCA/IDEgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZTsgLy9pZiB3ZSdyZSB0d2VlbmluZywgZGlzYWJsZSB0aGUgZWRnZVRvbGVyYW5jZSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWN0b3JlZCBpbnRvIHRoZSB0d2VlbmluZyB2YWx1ZXMgKHdlIGRvbid0IHdhbnQgdG8gYXBwbHkgaXQgbXVsdGlwbGUgdGltZXMpXG5cbiAgICAgICAgICByZXR1cm4gc25hcC5jYWxsKHNlbGYsIChuID4gbWF4ID8gbWF4ICsgKG4gLSBtYXgpICogZWRnZVRvbGVyYW5jZSA6IG4gPCBtaW4gPyBtaW4gKyAobiAtIG1pbikgKiBlZGdlVG9sZXJhbmNlIDogbikgKiBmYWN0b3IpICogZmFjdG9yO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzQXJyYXkoc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgdmFyIGkgPSBzbmFwLmxlbmd0aCxcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgICAgICAgIGFic0RpZiA9IF9iaWdOdW0sXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZGlmO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgICAgICB2YWwgPSBzbmFwW2ldO1xuICAgICAgICAgICAgZGlmID0gdmFsIC0gbjtcblxuICAgICAgICAgICAgaWYgKGRpZiA8IDApIHtcbiAgICAgICAgICAgICAgZGlmID0gLWRpZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpZiA8IGFic0RpZiAmJiB2YWwgPj0gbWluICYmIHZhbCA8PSBtYXgpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgICAgICAgIGFic0RpZiA9IGRpZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc25hcFtjbG9zZXN0XTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzTmFOKHNuYXApID8gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc25hcCAqIGZhY3RvcjtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgYnVpbGRQb2ludFNuYXBGdW5jID0gZnVuY3Rpb24gYnVpbGRQb2ludFNuYXBGdW5jKHNuYXAsIG1pblgsIG1heFgsIG1pblksIG1heFksIHJhZGl1cywgZmFjdG9yKSB7XG4gICAgICByYWRpdXMgPSByYWRpdXMgJiYgcmFkaXVzIDwgX2JpZ051bSA/IHJhZGl1cyAqIHJhZGl1cyA6IF9iaWdOdW07IC8vc28gd2UgZG9uJ3QgaGF2ZSB0byBNYXRoLnNxcnQoKSBpbiB0aGUgZnVuY3Rpb25zLiBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAhc2VsZi5pc1ByZXNzZWQgPyAxIDogMSAtIHNlbGYuZWRnZVJlc2lzdGFuY2UsXG4gICAgICAgICAgICAgIHggPSBwb2ludC54LFxuICAgICAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICBkeCxcbiAgICAgICAgICAgICAgZHk7IC8vaWYgd2UncmUgdHdlZW5pbmcsIGRpc2FibGUgdGhlIGVkZ2VUb2xlcmFuY2UgYmVjYXVzZSBpdCdzIGFscmVhZHkgZmFjdG9yZWQgaW50byB0aGUgdHdlZW5pbmcgdmFsdWVzICh3ZSBkb24ndCB3YW50IHRvIGFwcGx5IGl0IG11bHRpcGxlIHRpbWVzKVxuXG4gICAgICAgICAgcG9pbnQueCA9IHggPSB4ID4gbWF4WCA/IG1heFggKyAoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSA6IHggPCBtaW5YID8gbWluWCArICh4IC0gbWluWCkgKiBlZGdlVG9sZXJhbmNlIDogeDtcbiAgICAgICAgICBwb2ludC55ID0geSA9IHkgPiBtYXhZID8gbWF4WSArICh5IC0gbWF4WSkgKiBlZGdlVG9sZXJhbmNlIDogeSA8IG1pblkgPyBtaW5ZICsgKHkgLSBtaW5ZKSAqIGVkZ2VUb2xlcmFuY2UgOiB5O1xuICAgICAgICAgIHJlc3VsdCA9IHNuYXAuY2FsbChzZWxmLCBwb2ludCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBwb2ludCkge1xuICAgICAgICAgICAgcG9pbnQueCA9IHJlc3VsdC54O1xuICAgICAgICAgICAgcG9pbnQueSA9IHJlc3VsdC55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmYWN0b3IgIT09IDEpIHtcbiAgICAgICAgICAgIHBvaW50LnggKj0gZmFjdG9yO1xuICAgICAgICAgICAgcG9pbnQueSAqPSBmYWN0b3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhZGl1cyA8IF9iaWdOdW0pIHtcbiAgICAgICAgICAgIGR4ID0gcG9pbnQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IHBvaW50LnkgLSB5O1xuXG4gICAgICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgcG9pbnQueCA9IHg7XG4gICAgICAgICAgICAgIHBvaW50LnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0FycmF5KHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBpID0gc25hcC5sZW5ndGgsXG4gICAgICAgICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICAgICAgICBtaW5EaXN0ID0gX2JpZ051bSxcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgIGRpc3Q7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHBvaW50ID0gc25hcFtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludC54IC0gcC54O1xuICAgICAgICAgICAgeSA9IHBvaW50LnkgLSBwLnk7XG4gICAgICAgICAgICBkaXN0ID0geCAqIHggKyB5ICogeTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWluRGlzdCA8PSByYWRpdXMgPyBzbmFwW2Nsb3Nlc3RdIDogcDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBjYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICB2YXIgYm91bmRzLCB0YXJnZXRCb3VuZHMsIHNuYXAsIHNuYXBJc1JhdztcbiAgICAgIGhhc0JvdW5kcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgc2Nyb2xsUHJveHkuY2FsaWJyYXRlKCk7XG4gICAgICAgIHNlbGYubWluWCA9IG1pblggPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsTGVmdCgpO1xuICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gLXNjcm9sbFByb3h5Lm1heFNjcm9sbFRvcCgpO1xuICAgICAgICBzZWxmLm1heFggPSBtYXhYID0gc2VsZi5tYXhZID0gbWF4WSA9IDA7XG4gICAgICAgIGhhc0JvdW5kcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEhdmFycy5ib3VuZHMpIHtcbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyh2YXJzLmJvdW5kcywgdGFyZ2V0LnBhcmVudE5vZGUpOyAvL2NvdWxkIGJlIGEgc2VsZWN0b3IvalF1ZXJ5IG9iamVjdCBvciBhIERPTSBlbGVtZW50IG9yIGEgZ2VuZXJpYyBvYmplY3QgbGlrZSB7dG9wOjAsIGxlZnQ6MTAwLCB3aWR0aDoxMDAwLCBoZWlnaHQ6ODAwfSBvciB7bWluWDoxMDAsIG1heFg6MTEwMCwgbWluWTowLCBtYXhZOjgwMH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IGJvdW5kcy5sZWZ0O1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aDtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gc2VsZi5tYXhZID0gbWF4WSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIV9pc1VuZGVmaW5lZCh2YXJzLmJvdW5kcy5tYXhYKSB8fCAhX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFkpKSB7XG4gICAgICAgICAgYm91bmRzID0gdmFycy5ib3VuZHM7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IGJvdW5kcy5taW5YO1xuICAgICAgICAgIHNlbGYubWluWSA9IG1pblkgPSBib3VuZHMubWluWTtcbiAgICAgICAgICBzZWxmLm1heFggPSBtYXhYID0gYm91bmRzLm1heFg7XG4gICAgICAgICAgc2VsZi5tYXhZID0gbWF4WSA9IGJvdW5kcy5tYXhZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldEJvdW5kcyA9IF9nZXRCb3VuZHModGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IE1hdGgucm91bmQoZ2V0UHJvcEFzTnVtKHhQcm9wLCBcInB4XCIpICsgYm91bmRzLmxlZnQgLSB0YXJnZXRCb3VuZHMubGVmdCk7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWluWSA9IE1hdGgucm91bmQoZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpICsgYm91bmRzLnRvcCAtIHRhcmdldEJvdW5kcy50b3ApO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBNYXRoLnJvdW5kKG1pblggKyAoYm91bmRzLndpZHRoIC0gdGFyZ2V0Qm91bmRzLndpZHRoKSk7XG4gICAgICAgICAgc2VsZi5tYXhZID0gbWF4WSA9IE1hdGgucm91bmQobWluWSArIChib3VuZHMuaGVpZ2h0IC0gdGFyZ2V0Qm91bmRzLmhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblggPiBtYXhYKSB7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWF4WDtcbiAgICAgICAgICBzZWxmLm1heFggPSBtYXhYID0gbWluWDtcbiAgICAgICAgICBtaW5YID0gc2VsZi5taW5YO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblkgPiBtYXhZKSB7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWF4WTtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gbWluWTtcbiAgICAgICAgICBtaW5ZID0gc2VsZi5taW5ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIHNlbGYubWluUm90YXRpb24gPSBtaW5YO1xuICAgICAgICAgIHNlbGYubWF4Um90YXRpb24gPSBtYXhYO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcnMubGl2ZVNuYXApIHtcbiAgICAgICAgc25hcCA9IHZhcnMubGl2ZVNuYXAgPT09IHRydWUgPyB2YXJzLnNuYXAgfHwge30gOiB2YXJzLmxpdmVTbmFwO1xuICAgICAgICBzbmFwSXNSYXcgPSBfaXNBcnJheShzbmFwKSB8fCBfaXNGdW5jdGlvbihzbmFwKTtcblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc25hcFggPSBidWlsZFNuYXBGdW5jKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnJvdGF0aW9uLCBtaW5YLCBtYXhYLCAxKTtcbiAgICAgICAgICBzbmFwWSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNuYXAucG9pbnRzKSB7XG4gICAgICAgICAgICBzbmFwWFkgPSBidWlsZFBvaW50U25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzLCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCBzbmFwLnJhZGl1cywgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNuYXBYID0gYnVpbGRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC54IHx8IHNuYXAubGVmdCB8fCBzbmFwLnNjcm9sbExlZnQsIG1pblgsIG1heFgsIHNjcm9sbFByb3h5ID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzbmFwWSA9IGJ1aWxkU25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAueSB8fCBzbmFwLnRvcCB8fCBzbmFwLnNjcm9sbFRvcCwgbWluWSwgbWF4WSwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgICAgIG9uVGhyb3dDb21wbGV0ZSA9IGZ1bmN0aW9uIG9uVGhyb3dDb21wbGV0ZSgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInRocm93Y29tcGxldGVcIiwgXCJvblRocm93Q29tcGxldGVcIik7XG4gICAgfSxcbiAgICAgICAgb25UaHJvd0ludGVycnVwdCA9IGZ1bmN0aW9uIG9uVGhyb3dJbnRlcnJ1cHQoKSB7XG4gICAgICBzZWxmLmlzVGhyb3dpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgICAgICBhbmltYXRlID0gZnVuY3Rpb24gYW5pbWF0ZShpbmVydGlhLCBmb3JjZVplcm9WZWxvY2l0eSkge1xuICAgICAgdmFyIHNuYXAsIHNuYXBJc1JhdywgdHdlZW4sIG92ZXJzaG9vdFRvbGVyYW5jZTtcblxuICAgICAgaWYgKGluZXJ0aWEgJiYgSW5lcnRpYVBsdWdpbikge1xuICAgICAgICBpZiAoaW5lcnRpYSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNuYXAgPSB2YXJzLnNuYXAgfHwgdmFycy5saXZlU25hcCB8fCB7fTtcbiAgICAgICAgICBzbmFwSXNSYXcgPSBfaXNBcnJheShzbmFwKSB8fCBfaXNGdW5jdGlvbihzbmFwKTtcbiAgICAgICAgICBpbmVydGlhID0ge1xuICAgICAgICAgICAgcmVzaXN0YW5jZTogKHZhcnMudGhyb3dSZXNpc3RhbmNlIHx8IHZhcnMucmVzaXN0YW5jZSB8fCAxMDAwKSAvIChyb3RhdGlvbk1vZGUgPyAxMCA6IDEpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIGluZXJ0aWEucm90YXRpb24gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnJvdGF0aW9uLCBtYXhYLCBtaW5YLCAxLCBmb3JjZVplcm9WZWxvY2l0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgaW5lcnRpYVt4UHJvcF0gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnBvaW50cyB8fCBzbmFwLnggfHwgc25hcC5sZWZ0LCBtYXhYLCBtaW5YLCBzY3JvbGxQcm94eSA/IC0xIDogMSwgZm9yY2VaZXJvVmVsb2NpdHkgfHwgc2VsZi5sb2NrZWRBeGlzID09PSBcInhcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgaW5lcnRpYVt5UHJvcF0gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnBvaW50cyB8fCBzbmFwLnkgfHwgc25hcC50b3AsIG1heFksIG1pblksIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmxvY2tlZEF4aXMgPT09IFwieVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXAucG9pbnRzIHx8IF9pc0FycmF5KHNuYXApICYmIF9pc09iamVjdChzbmFwWzBdKSkge1xuICAgICAgICAgICAgICBpbmVydGlhLmxpbmtlZFByb3BzID0geFByb3AgKyBcIixcIiArIHlQcm9wO1xuICAgICAgICAgICAgICBpbmVydGlhLnJhZGl1cyA9IHNuYXAucmFkaXVzOyAvL25vdGU6IHdlIGFsc28gZGlzYWJsZSBsaXZlU25hcHBpbmcgd2hpbGUgdGhyb3dpbmcgaWYgdGhlcmUncyBhIFwicmFkaXVzXCIgZGVmaW5lZCwgb3RoZXJ3aXNlIGl0IGxvb2tzIHdlaXJkIHRvIGhhdmUgdGhlIGl0ZW0gdGhyb3duIHBhc3QgYSBzbmFwcGluZyBwb2ludCBidXQgbGl2ZS1zbmFwcGluZyBtaWQtdHdlZW4uIFdlIGRvIHRoaXMgYnkgYWx0ZXJpbmcgdGhlIG9uVXBkYXRlUGFyYW1zIHNvIHRoYXQgXCJza2lwU25hcFwiIHBhcmFtZXRlciBpcyB0cnVlIGZvciBzeW5jWFkuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5pc1Rocm93aW5nID0gdHJ1ZTtcbiAgICAgICAgb3ZlcnNob290VG9sZXJhbmNlID0gIWlzTmFOKHZhcnMub3ZlcnNob290VG9sZXJhbmNlKSA/IHZhcnMub3ZlcnNob290VG9sZXJhbmNlIDogdmFycy5lZGdlUmVzaXN0YW5jZSA9PT0gMSA/IDAgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSArIDAuMjtcblxuICAgICAgICBpZiAoIWluZXJ0aWEuZHVyYXRpb24pIHtcbiAgICAgICAgICBpbmVydGlhLmR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbWF4OiBNYXRoLm1heCh2YXJzLm1pbkR1cmF0aW9uIHx8IDAsIFwibWF4RHVyYXRpb25cIiBpbiB2YXJzID8gdmFycy5tYXhEdXJhdGlvbiA6IDIpLFxuICAgICAgICAgICAgbWluOiAhaXNOYU4odmFycy5taW5EdXJhdGlvbikgPyB2YXJzLm1pbkR1cmF0aW9uIDogb3ZlcnNob290VG9sZXJhbmNlID09PSAwIHx8IF9pc09iamVjdChpbmVydGlhKSAmJiBpbmVydGlhLnJlc2lzdGFuY2UgPiAxMDAwID8gMCA6IDAuNSxcbiAgICAgICAgICAgIG92ZXJzaG9vdDogb3ZlcnNob290VG9sZXJhbmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHdlZW4gPSB0d2VlbiA9IGdzYXAudG8oc2Nyb2xsUHJveHkgfHwgdGFyZ2V0LCB7XG4gICAgICAgICAgaW5lcnRpYTogaW5lcnRpYSxcbiAgICAgICAgICBkYXRhOiBcIl9kcmFnZ2FibGVcIixcbiAgICAgICAgICBvbkNvbXBsZXRlOiBvblRocm93Q29tcGxldGUsXG4gICAgICAgICAgb25JbnRlcnJ1cHQ6IG9uVGhyb3dJbnRlcnJ1cHQsXG4gICAgICAgICAgb25VcGRhdGU6IHZhcnMuZmFzdE1vZGUgPyBfZGlzcGF0Y2hFdmVudCA6IHN5bmNYWSxcbiAgICAgICAgICBvblVwZGF0ZVBhcmFtczogdmFycy5mYXN0TW9kZSA/IFtzZWxmLCBcIm9udGhyb3d1cGRhdGVcIiwgXCJvblRocm93VXBkYXRlXCJdIDogc25hcCAmJiBzbmFwLnJhZGl1cyA/IFtmYWxzZSwgdHJ1ZV0gOiBbXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZhcnMuZmFzdE1vZGUpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgICAgIHNjcm9sbFByb3h5Ll9za2lwID0gdHJ1ZTsgLy8gTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBicmllZmx5IHJlbmRlciB0aGUgcG9zaXRpb24gaW5jb3JyZWN0bHkgKGl0IGZsYXNoZXMgdG8gdGhlIGVuZCBzdGF0ZSB3aGVuIHdlIHNlZWsoKSB0aGUgdHdlZW4gZXZlbiB0aG91Z2ggd2UganVtcCByaWdodCBiYWNrIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhpcyBvbmx5IHNlZW1zIHRvIGhhcHBlbiB3aGVuIHdlJ3JlIGFmZmVjdGluZyBib3RoIHRvcCBhbmQgbGVmdCksIHNvIHdlIHNldCBhIF9zdXNwZW5kVHJhbnNmb3JtcyBmbGFnIHRvIHByZXZlbnQgaXQgZnJvbSBhY3R1YWxseSBhcHBseWluZyB0aGUgdmFsdWVzIGluIHRoZSBTY3JvbGxQcm94eS5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0d2Vlbi5yZW5kZXIoMWU5LCB0cnVlLCB0cnVlKTsgLy8gZm9yY2UgdG8gdGhlIGVuZC4gUmVtZW1iZXIsIHRoZSBkdXJhdGlvbiB3aWxsIGxpa2VseSBjaGFuZ2UgdXBvbiBpbml0dGluZyBiZWNhdXNlIHRoYXQncyB3aGVuIEluZXJ0aWFQbHVnaW4gY2FsY3VsYXRlcyBpdC5cblxuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICBzZWxmLmVuZFggPSBzZWxmLng7XG4gICAgICAgICAgc2VsZi5lbmRZID0gc2VsZi55O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0d2Vlbi5wbGF5KDApO1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgc2Nyb2xsUHJveHkuX3NraXAgPSBmYWxzZTsgLy9NaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNCb3VuZHMpIHtcbiAgICAgICAgc2VsZi5hcHBseUJvdW5kcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIHVwZGF0ZU1hdHJpeCA9IGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeChzaGlmdFN0YXJ0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBtYXRyaXgsXG4gICAgICAgICAgcDtcbiAgICAgIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChzaGlmdFN0YXJ0ICYmIHNlbGYuaXNQcmVzc2VkICYmICFtYXRyaXguZXF1YWxzKHN0YXJ0IHx8IG5ldyBNYXRyaXgyRCgpKSkge1xuICAgICAgICAvL2lmIHRoZSBtYXRyaXggY2hhbmdlcyBXSElMRSB0aGUgZWxlbWVudCBpcyBwcmVzc2VkLCB3ZSBtdXN0IGFkanVzdCB0aGUgc3RhcnRQb2ludGVyWCBhbmQgc3RhcnRQb2ludGVyWSBhY2NvcmRpbmdseSwgc28gd2UgaW52ZXJ0IHRoZSBvcmlnaW5hbCBtYXRyaXggYW5kIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHBvaW50ZXJYIGFuZCBwb2ludGVyWSB3ZXJlIGluIHRoZSBnbG9iYWwgc3BhY2UsIHRoZW4gYXBwbHkgdGhlIG5ldyBtYXRyaXggdG8gZ2V0IHRoZSB1cGRhdGVkIGNvb3JkaW5hdGVzLlxuICAgICAgICBwID0gc3RhcnQuaW52ZXJzZSgpLmFwcGx5KHtcbiAgICAgICAgICB4OiBzdGFydFBvaW50ZXJYLFxuICAgICAgICAgIHk6IHN0YXJ0UG9pbnRlcllcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdHJpeC5hcHBseShwLCBwKTtcbiAgICAgICAgc3RhcnRQb2ludGVyWCA9IHAueDtcbiAgICAgICAgc3RhcnRQb2ludGVyWSA9IHAueTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdHJpeC5lcXVhbHMoX2lkZW50aXR5TWF0cml4KSkge1xuICAgICAgICAvL2lmIHRoZXJlIGFyZSBubyB0cmFuc2Zvcm1zLCB3ZSBjYW4gb3B0aW1pemUgcGVyZm9ybWFuY2UgYnkgbm90IGZhY3RvcmluZyBpbiB0aGUgbWF0cml4XG4gICAgICAgIG1hdHJpeCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWNvcmRTdGFydFBvc2l0aW9ucygpIHtcbiAgICAgIHZhciBlZGdlVG9sZXJhbmNlID0gMSAtIHNlbGYuZWRnZVJlc2lzdGFuY2UsXG4gICAgICAgICAgb2Zmc2V0WCA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsTGVmdChvd25lckRvYykgOiAwLFxuICAgICAgICAgIG9mZnNldFkgPSBpc0ZpeGVkID8gX2dldERvY1Njcm9sbFRvcChvd25lckRvYykgOiAwLFxuICAgICAgICAgIHBhcnNlZE9yaWdpbixcbiAgICAgICAgICB4LFxuICAgICAgICAgIHk7XG5cbiAgICAgIGlmICh4eU1vZGUpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciBzZXQgaXQgYXMgYSBkaWZmZXJlbnQgdW5pdCwgbGlrZSBhbmltYXRpbmcgdGhlIHggdG8gXCIxMDAlXCIuIFdlIG11c3QgY29udmVydCBpdCBiYWNrIHRvIHB4IVxuICAgICAgICBnc0NhY2hlLnggPSBnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIikgKyBcInB4XCI7XG4gICAgICAgIGdzQ2FjaGUueSA9IGdldFByb3BBc051bSh5UHJvcCwgXCJweFwiKSArIFwicHhcIjtcbiAgICAgICAgZ3NDYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlTWF0cml4KGZhbHNlKTtcbiAgICAgIF9wb2ludDEueCA9IHNlbGYucG9pbnRlclggLSBvZmZzZXRYO1xuICAgICAgX3BvaW50MS55ID0gc2VsZi5wb2ludGVyWSAtIG9mZnNldFk7XG4gICAgICBtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuICAgICAgc3RhcnRQb2ludGVyWCA9IF9wb2ludDEueDsgLy90cmFuc2xhdGUgdG8gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cblxuICAgICAgc3RhcnRQb2ludGVyWSA9IF9wb2ludDEueTtcblxuICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgIHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZKTtcbiAgICAgICAgcmVuZGVyKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpbm5lck1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpO1xuXG4gICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIHN0YXJ0RWxlbWVudFkgPSBzY3JvbGxQcm94eS50b3AoKTtcbiAgICAgICAgc3RhcnRFbGVtZW50WCA9IHNjcm9sbFByb3h5LmxlZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vaWYgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgdHdlZW5pbmcsIGRvbid0IGZvcmNlIHNuYXBwaW5nIHRvIG9jY3VyIGJlY2F1c2UgaXQgY291bGQgbWFrZSBpdCBqdW1wLiBJbWFnaW5lIHRoZSB1c2VyIHRocm93aW5nLCB0aGVuIGJlZm9yZSBpdCdzIGRvbmUsIGNsaWNraW5nIG9uIHRoZSBlbGVtZW50IGluIGl0cyBpbmJldHdlZW4gc3RhdGUuXG4gICAgICAgIGlmIChpc1R3ZWVuaW5nKCkpIHtcbiAgICAgICAgICBzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5hcHBseUJvdW5kcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIHBhcnNlZE9yaWdpbiA9IHRhcmdldC5vd25lclNWR0VsZW1lbnQgPyBbZ3NDYWNoZS54T3JpZ2luIC0gdGFyZ2V0LmdldEJCb3goKS54LCBnc0NhY2hlLnlPcmlnaW4gLSB0YXJnZXQuZ2V0QkJveCgpLnldIDogKF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldClbX3RyYW5zZm9ybU9yaWdpblByb3BdIHx8IFwiMCAwXCIpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICByb3RhdGlvbk9yaWdpbiA9IHNlbGYucm90YXRpb25PcmlnaW4gPSBnZXRHbG9iYWxNYXRyaXgodGFyZ2V0KS5hcHBseSh7XG4gICAgICAgICAgICB4OiBwYXJzZUZsb2F0KHBhcnNlZE9yaWdpblswXSkgfHwgMCxcbiAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQocGFyc2VkT3JpZ2luWzFdKSB8fCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIHggPSBzZWxmLnBvaW50ZXJYIC0gcm90YXRpb25PcmlnaW4ueCAtIG9mZnNldFg7XG4gICAgICAgICAgeSA9IHJvdGF0aW9uT3JpZ2luLnkgLSBzZWxmLnBvaW50ZXJZICsgb2Zmc2V0WTtcbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gc2VsZi54OyAvL3N0YXJ0aW5nIHJvdGF0aW9uICh4IGFsd2F5cyByZWZlcnMgdG8gcm90YXRpb24gaW4gdHlwZTpcInJvdGF0aW9uXCIsIG1lYXN1cmVkIGluIGRlZ3JlZXMpXG5cbiAgICAgICAgICBzdGFydEVsZW1lbnRZID0gc2VsZi55ID0gTWF0aC5hdGFuMih5LCB4KSAqIF9SQUQyREVHO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vcGFyZW50ID0gIWlzRml4ZWQgJiYgdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgLy9zdGFydFNjcm9sbFRvcCA9IHBhcmVudCA/IHBhcmVudC5zY3JvbGxUb3AgfHwgMCA6IDA7XG4gICAgICAgICAgLy9zdGFydFNjcm9sbExlZnQgPSBwYXJlbnQgPyBwYXJlbnQuc2Nyb2xsTGVmdCB8fCAwIDogMDtcbiAgICAgICAgICBzdGFydEVsZW1lbnRZID0gZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgdG9wIGFuZCBsZWZ0IHZhbHVlcyBzbyB0aGF0IHdlIGNhbiBqdXN0IGFkZCB0aGUgbW91c2UncyBtb3ZlbWVudCB0byB0aGVtIGxhdGVyLlxuXG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IGdldFByb3BBc051bSh4UHJvcCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQm91bmRzICYmIGVkZ2VUb2xlcmFuY2UpIHtcbiAgICAgICAgaWYgKHN0YXJ0RWxlbWVudFggPiBtYXhYKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IG1heFggKyAoc3RhcnRFbGVtZW50WCAtIG1heFgpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydEVsZW1lbnRYIDwgbWluWCkge1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBtaW5YIC0gKG1pblggLSBzdGFydEVsZW1lbnRYKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIGlmIChzdGFydEVsZW1lbnRZID4gbWF4WSkge1xuICAgICAgICAgICAgc3RhcnRFbGVtZW50WSA9IG1heFkgKyAoc3RhcnRFbGVtZW50WSAtIG1heFkpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RWxlbWVudFkgPCBtaW5ZKSB7XG4gICAgICAgICAgICBzdGFydEVsZW1lbnRZID0gbWluWSAtIChtaW5ZIC0gc3RhcnRFbGVtZW50WSkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLnN0YXJ0WCA9IHN0YXJ0RWxlbWVudFggPSBfcm91bmQoc3RhcnRFbGVtZW50WCk7XG4gICAgICBzZWxmLnN0YXJ0WSA9IHN0YXJ0RWxlbWVudFkgPSBfcm91bmQoc3RhcnRFbGVtZW50WSk7XG4gICAgfSxcbiAgICAgICAgaXNUd2VlbmluZyA9IGZ1bmN0aW9uIGlzVHdlZW5pbmcoKSB7XG4gICAgICByZXR1cm4gc2VsZi50d2VlbiAmJiBzZWxmLnR3ZWVuLmlzQWN0aXZlKCk7XG4gICAgfSxcbiAgICAgICAgcmVtb3ZlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiByZW1vdmVQbGFjZWhvbGRlcigpIHtcbiAgICAgIGlmIChfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZSAmJiAhaXNUd2VlbmluZygpICYmICFzZWxmLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgLy9fcGxhY2Vob2xkZXJEaXYganVzdCBwcm9wcyBvcGVuIGF1dG8tc2Nyb2xsaW5nIGNvbnRhaW5lcnMgc28gdGhleSBkb24ndCBjb2xsYXBzZSBhcyB0aGUgdXNlciBkcmFncyBsZWZ0L3VwLiBXZSByZW1vdmUgaXQgYWZ0ZXIgZHJhZ2dpbmcgKGFuZCB0aHJvd2luZywgaWYgbmVjZXNzYXJ5KSBmaW5pc2hlcy5cbiAgICAgICAgX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3BsYWNlaG9sZGVyRGl2KTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICAvL2NhbGxlZCB3aGVuIHRoZSBtb3VzZSBpcyBwcmVzc2VkIChvciB0b3VjaCBzdGFydHMpXG4gICAgb25QcmVzcyA9IGZ1bmN0aW9uIG9uUHJlc3MoZSwgZm9yY2UpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoIWVuYWJsZWQgfHwgc2VsZi5pc1ByZXNzZWQgfHwgIWUgfHwgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiB8fCBlLnR5cGUgPT09IFwicG9pbnRlcmRvd25cIikgJiYgIWZvcmNlICYmIF9nZXRUaW1lKCkgLSBjbGlja1RpbWUgPCAzMCAmJiBfdG91Y2hFdmVudExvb2t1cFtzZWxmLnBvaW50ZXJFdmVudC50eXBlXSkge1xuICAgICAgICAvL3doZW4gd2UgRE9OJ1QgcHJldmVudERlZmF1bHQoKSBpbiBvcmRlciB0byBhY2NvbW1vZGF0ZSB0b3VjaC1zY3JvbGxpbmcgYW5kIHRoZSB1c2VyIGp1c3QgdGFwcywgbWFueSBicm93c2VycyBhbHNvIGZpcmUgYSBtb3VzZWRvd24vbW91c2V1cCBzZXF1ZW5jZSBBRlRFUiB0aGUgdG91Y2hzdGFydC90b3VjaGVuZCBzZXF1ZW5jZSwgdGh1cyBpdCdkIHJlc3VsdCBpbiB0d28gcXVpY2sgXCJjbGlja1wiIGV2ZW50cyBiZWluZyBkaXNwYXRjaGVkLiBUaGlzIGxpbmUgc2Vuc2VzIHRoYXQgY29uZGl0aW9uIGFuZCBoYWx0cyBpdCBvbiB0aGUgc3Vic2VxdWVudCBtb3VzZWRvd24uXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2hzdGFydCwgcG9pbnRlcmRvd24sIG1vdXNlZG93bi4gVGhlIGZpcnN0IHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdlIHJlY29yZCB3aGV0aGVyIG9yIG5vdCB3ZSBfcHJldmVudERlZmF1bHQoKSBzbyB0aGF0IG9uIGR1cGxpY2F0ZSBjYWxscywgd2UgY2FuIGRvIHRoZSBzYW1lIGlmIG5lY2Vzc2FyeS5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGludGVycnVwdGVkID0gaXNUd2VlbmluZygpO1xuICAgICAgZHJhZ2dlZCA9IGZhbHNlOyAvLyB3ZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgb3Igbm90IGl0IHdhcyBkcmFnZ2VkIGluIHRoaXMgaW50ZXJhY3Rpb24gc28gdGhhdCBpZiwgZm9yIGV4YW1wbGUsIHRoZSB1c2VyIGNhbGxzIC5lbmREcmFnKCkgdG8gRk9SQ0UgaXQgdG8gc3RvcCBhbmQgdGhlbiB0aGV5IGtlZXAgdGhlIG1vdXNlIHByZXNzZWQgZG93biBhbmQgZXZlbnR1YWxseSByZWxlYXNlLCB0aGF0IHdvdWxkIG5vcm1hbGx5IGNhdXNlIGFuIG9uQ2xpY2sgYnV0IHdlIGhhdmUgdG8gc2tpcCBpdCBpbiB0aGF0IGNhc2UgaWYgdGhlcmUgd2FzIGRyYWdnaW5nIHRoYXQgb2NjdXJyZWQuXG5cbiAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gZTtcblxuICAgICAgaWYgKF90b3VjaEV2ZW50TG9va3VwW2UudHlwZV0pIHtcbiAgICAgICAgLy9ub3RlOiBvbiBpT1MsIEJPVEggdG91Y2htb3ZlIGFuZCBtb3VzZW1vdmUgYXJlIGRpc3BhdGNoZWQsIGJ1dCB0aGUgbW91c2Vtb3ZlIGhhcyBwYWdlWSBhbmQgcGFnZVggb2YgMCB3aGljaCB3b3VsZCBtZXNzIHVwIHRoZSBjYWxjdWxhdGlvbnMgYW5kIG5lZWRsZXNzbHkgaHVydCBwZXJmb3JtYW5jZS5cbiAgICAgICAgdG91Y2hFdmVudFRhcmdldCA9IH5lLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID8gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0IDogb3duZXJEb2M7IC8vcG9pbnRlci1iYXNlZCB0b3VjaGVzIChmb3IgTWljcm9zb2Z0IGJyb3dzZXJzKSBkb24ndCByZW1haW4gbG9ja2VkIHRvIHRoZSBvcmlnaW5hbCB0YXJnZXQgbGlrZSBvdGhlciBicm93c2Vycywgc28gd2UgbXVzdCB1c2UgdGhlIGRvY3VtZW50IGluc3RlYWQuIFRoZSBldmVudCB0eXBlIHdvdWxkIGJlIFwiTVNQb2ludGVyRG93blwiIG9yIFwicG9pbnRlcmRvd25cIi5cblxuICAgICAgICBfYWRkTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNobW92ZVwiLCBvbk1vdmUpOyAvLyBwb3NzaWJsZSBmdXR1cmUgY2hhbmdlIGlmIFBvaW50ZXJFdmVudHMgYXJlIG1vcmUgc3RhbmRhcmRpemVkOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zZXRQb2ludGVyQ2FwdHVyZVxuXG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG91Y2hFdmVudFRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpOyAvL2F0dGFjaCB0aGVzZSB0byB0aGUgZG9jdW1lbnQgaW5zdGVhZCBvZiB0aGUgYm94IGl0c2VsZiBzbyB0aGF0IGlmIHRoZSB1c2VyJ3MgbW91c2UgbW92ZXMgdG9vIHF1aWNrbHkgKGFuZCBvZmYgb2YgdGhlIGJveCksIHRoaW5ncyBzdGlsbCB3b3JrLlxuXG4gICAgICB9XG5cbiAgICAgIHRvdWNoRHJhZ0F4aXMgPSBudWxsO1xuXG4gICAgICBpZiAoIV9zdXBwb3J0c1BvaW50ZXIgfHwgIXRvdWNoRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIF9hZGRMaXN0ZW5lcihlLnRhcmdldCwgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7IC8vd2UgYWxzbyBoYXZlIHRvIGxpc3RlbiBkaXJlY3RseSBvbiB0aGUgZWxlbWVudCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgYnViYmxlIHVwIHRoZSBldmVudCB0byB0aGUgX2RvYyBvbiBlbGVtZW50cyB3aXRoIGNvbnRlbnRFZGl0YWJsZT1cInRydWVcIlxuICAgICAgfVxuXG4gICAgICBpc0NsaWNraW5nID0gaXNDbGlja2FibGUuY2FsbChzZWxmLCBlLnRhcmdldCkgJiYgdmFycy5kcmFnQ2xpY2thYmxlcyA9PT0gZmFsc2UgJiYgIWZvcmNlO1xuXG4gICAgICBpZiAoaXNDbGlja2luZykge1xuICAgICAgICBfYWRkTGlzdGVuZXIoZS50YXJnZXQsIFwiY2hhbmdlXCIsIG9uUmVsZWFzZSk7IC8vaW4gc29tZSBicm93c2Vycywgd2hlbiB5b3UgbW91c2Vkb3duIG9uIGEgPHNlbGVjdD4gZWxlbWVudCwgbm8gbW91c2V1cCBnZXRzIGRpc3BhdGNoZWQhIFNvIHdlIGxpc3RlbiBmb3IgYSBcImNoYW5nZVwiIGV2ZW50IGluc3RlYWQuXG5cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInByZXNzSW5pdFwiLCBcIm9uUHJlc3NJbml0XCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NcIiwgXCJvblByZXNzXCIpO1xuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCB0cnVlKTsgLy9hY2NvbW1vZGF0ZXMgdGhpbmdzIGxpa2UgaW5wdXRzIGFuZCBlbGVtZW50cyB3aXRoIGNvbnRlbnRFZGl0YWJsZT1cInRydWVcIiAob3RoZXJ3aXNlIHVzZXIgY291bGRuJ3QgZHJhZyB0byBzZWxlY3QgdGV4dClcblxuXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID0gIXRvdWNoRXZlbnRUYXJnZXQgfHwgYWxsb3dYID09PSBhbGxvd1kgfHwgc2VsZi52YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IGZhbHNlIHx8IHNlbGYudmFycy5hbGxvd0NvbnRleHRNZW51ICYmIGUgJiYgKGUuY3RybEtleSB8fCBlLndoaWNoID4gMikgPyBmYWxzZSA6IGFsbG93WCA/IFwieVwiIDogXCJ4XCI7IC8vbm90ZTogaW4gQ2hyb21lLCByaWdodC1jbGlja2luZyAoZm9yIGEgY29udGV4dCBtZW51KSBmaXJlcyBvblByZXNzIGFuZCBpdCBkb2Vzbid0IGhhdmUgdGhlIGV2ZW50LndoaWNoIHNldCBwcm9wZXJseSwgc28gd2UgbXVzdCBsb29rIGZvciBldmVudC5jdHJsS2V5LiBJZiB0aGUgdXNlciB3YW50cyB0byBhbGxvdyBjb250ZXh0IG1lbnVzIHdlIHNob3VsZCBvZiBjb3Vyc2Ugc2Vuc2UgaXQgaGVyZSBhbmQgbm90IGFsbG93IG5hdGl2ZSB0b3VjaCBzY3JvbGxpbmcuXG5cbiAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSAhYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyAmJiAhc2VsZi5hbGxvd0V2ZW50RGVmYXVsdDtcblxuICAgICAgaWYgKGlzUHJldmVudGluZ0RlZmF1bHQpIHtcbiAgICAgICAgX3ByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcInRvdWNoZm9yY2VjaGFuZ2VcIiwgX3ByZXZlbnREZWZhdWx0KTsgLy93b3JrcyBhcm91bmQgc2FmYXJpIGJ1ZzogaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICBlID0gdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB0b3VjaElEID0gZS5pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCkge1xuICAgICAgICB0b3VjaElEID0gZS5wb2ludGVySWQ7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaCA9IHRvdWNoSUQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfZHJhZ0NvdW50Kys7XG5cbiAgICAgIF9hZGRUb1JlbmRlclF1ZXVlKHJlbmRlcik7IC8vY2F1c2VzIHRoZSBEcmFnZ2FibGUgdG8gcmVuZGVyIG9uIGVhY2ggXCJ0aWNrXCIgb2YgZ3NhcC50aWNrZXIgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHVwZGF0aW5nIHZhbHVlcyBpbiBhIG1vdXNlbW92ZSBjYW4gY2F1c2UgdGhlbSB0byBoYXBwZW4gdG9vIGZyZXF1ZW50bHksIGxpa2UgbXVsdGlwbGUgdGltZXMgYmV0d2VlbiBmcmFtZSByZWRyYXdzIHdoaWNoIGlzIHdhc3RlZnVsLCBhbmQgaXQgYWxzbyBwcmV2ZW50cyB2YWx1ZXMgZnJvbSB1cGRhdGluZyBwcm9wZXJseSBpbiBJRTgpXG5cblxuICAgICAgc3RhcnRQb2ludGVyWSA9IHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgeCBhbmQgeSBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1vdmVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGluIF9vbk1vdXNlTW92ZVxuXG4gICAgICBzdGFydFBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgIGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJiBzZWxmLmF1dG9TY3JvbGwgJiYgIXNjcm9sbFByb3h5ICYmICFyb3RhdGlvbk1vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuX2dzTWF4U2Nyb2xsWCAmJiAhX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIXRhcmdldC5nZXRCQm94KSB7XG4gICAgICAgIC8vYWRkIGEgcGxhY2Vob2xkZXIgZGl2IHRvIHByZXZlbnQgdGhlIHBhcmVudCBjb250YWluZXIgZnJvbSBjb2xsYXBzaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGVsZW1lbnQgbGVmdC5cbiAgICAgICAgX3BsYWNlaG9sZGVyRGl2LnN0eWxlLndpZHRoID0gdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxQcm94eSB8fCB0YXJnZXQsIGtpbGxQcm9wcywgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdXNlciB0cmllcyB0byBkcmFnIGl0IGJlZm9yZSB0aGUgbGFzdCB0d2VlbiBpcyBkb25lLlxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0YXJnZXQsIHtcbiAgICAgICAgc2Nyb2xsVG86IDFcbiAgICAgIH0sIHRydWUpOyAvL2p1c3QgaW4gY2FzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0J3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHR3ZWVuZWQgc29tZXdoZXJlIGVsc2UuXG5cbiAgICAgIHNlbGYudHdlZW4gPSBzZWxmLmxvY2tlZEF4aXMgPSBudWxsO1xuXG4gICAgICBpZiAodmFycy56SW5kZXhCb29zdCB8fCAhcm90YXRpb25Nb2RlICYmICFzY3JvbGxQcm94eSAmJiB2YXJzLnpJbmRleEJvb3N0ICE9PSBmYWxzZSkge1xuICAgICAgICB0YXJnZXQuc3R5bGUuekluZGV4ID0gRHJhZ2dhYmxlLnpJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBoYXNEcmFnQ2FsbGJhY2sgPSAhISh2YXJzLm9uRHJhZyB8fCBzZWxmLl9saXN0ZW5lcnMuZHJhZyk7XG4gICAgICBoYXNNb3ZlQ2FsbGJhY2sgPSAhISh2YXJzLm9uTW92ZSB8fCBzZWxmLl9saXN0ZW5lcnMubW92ZSk7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgfHwgdmFycy5hY3RpdmVDdXJzb3IpIHtcbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICBnc2FwLnNldCh0cmlnZ2Vyc1tpXSwge1xuICAgICAgICAgICAgY3Vyc29yOiB2YXJzLmFjdGl2ZUN1cnNvciB8fCB2YXJzLmN1cnNvciB8fCAoX2RlZmF1bHRDdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiYmluZ1wiIDogX2RlZmF1bHRDdXJzb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgZXZlcnkgdGltZSB0aGUgbW91c2UvdG91Y2ggbW92ZXNcbiAgICBvbk1vdmUgPSBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgcG9pbnRlclksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IF9pc011bHRpVG91Y2hpbmcgfHwgIXNlbGYuaXNQcmVzc2VkIHx8ICFlKSB7XG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2htb3ZlLCBwb2ludGVybW92ZSwgbW91c2Vtb3ZlLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgIGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fSAvLyBTb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBhIHRvdWNoc3RhcnQgQU5EIHBvaW50ZXJkb3duIGluaXRpYWxseSwgYW5kIHRoZW4gb25seSBwb2ludGVybW92ZSB0aHVzIHRoZSB0b3VjaElEIG1heSBub3QgbWF0Y2ggYmVjYXVzZSBpdCB3YXMgZ3JhYmJlZCBmcm9tIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IHdoZXJlYXMgdGhlIHBvaW50ZXIgZXZlbnQgaXMgdGhlIG9uZSB0aGF0IHRoZSBicm93c2VyIGRpc3BhdGNoZXMgZm9yIG1vdmUsIHNvIGlmIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyB0aGlzIERyYWdnYWJsZSdzIHRhcmdldCwgbGV0IGl0IHRocm91Z2guXG5cblxuICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCAmJiB0b3VjaElEICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0ICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgLy9BbmRyb2lkIGJyb3dzZXJzIGZvcmNlIHVzIHRvIGRlY2lkZSBvbiB0aGUgZmlyc3QgXCJ0b3VjaG1vdmVcIiBldmVudCBpZiB3ZSBzaG91bGQgYWxsb3cgdGhlIGRlZmF1bHQgKHNjcm9sbGluZykgYmVoYXZpb3Igb3IgcHJldmVudERlZmF1bHQoKS4gT3RoZXJ3aXNlLCBhIFwidG91Y2hjYW5jZWxcIiB3aWxsIGJlIGZpcmVkIGFuZCB0aGVuIG5vIFwidG91Y2htb3ZlXCIgb3IgXCJ0b3VjaGVuZFwiIHdpbGwgZmlyZSBkdXJpbmcgdGhlIHNjcm9sbGluZyAobm8gZ29vZCkuXG4gICAgICAgIF9wb2ludDEueCA9IGUucGFnZVggLSAoaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDApO1xuICAgICAgICBfcG9pbnQxLnkgPSBlLnBhZ2VZIC0gKGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDApO1xuICAgICAgICBtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuICAgICAgICBwb2ludGVyWCA9IF9wb2ludDEueDtcbiAgICAgICAgcG9pbnRlclkgPSBfcG9pbnQxLnk7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMocG9pbnRlclggLSBzdGFydFBvaW50ZXJYKTtcbiAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclkpO1xuXG4gICAgICAgIGlmIChkeCAhPT0gZHkgJiYgKGR4ID4gbWluaW11bU1vdmVtZW50IHx8IGR5ID4gbWluaW11bU1vdmVtZW50KSB8fCBfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgICB0b3VjaERyYWdBeGlzID0gZHggPiBkeSAmJiBhbGxvd1ggPyBcInhcIiA6IFwieVwiO1xuXG4gICAgICAgICAgaWYgKGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgdG91Y2hEcmFnQXhpcyAhPT0gYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZykge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvLyBwcmV2ZW50cyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nIGZyb20gdGFraW5nIG92ZXIgaWYgdGhlIHVzZXIgc3RhcnRlZCBkcmFnZ2luZyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGluIGlPUyBTYWZhcmlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnZhcnMubG9ja0F4aXNPblRvdWNoU2Nyb2xsICE9PSBmYWxzZSAmJiBhbGxvd1ggJiYgYWxsb3dZKSB7XG4gICAgICAgICAgICBzZWxmLmxvY2tlZEF4aXMgPSB0b3VjaERyYWdBeGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gICAgICAgICAgICBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykgJiYgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2lzQW5kcm9pZCAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSB7XG4gICAgICAgICAgICBvblJlbGVhc2Uob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICE9PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKGUucGFnZVgsIGUucGFnZVksIGhhc01vdmVDYWxsYmFjayk7XG4gICAgfSxcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9pbnRlclBvc2l0aW9uKHBvaW50ZXJYLCBwb2ludGVyWSwgaW52b2tlT25Nb3ZlKSB7XG4gICAgICB2YXIgZHJhZ1RvbGVyYW5jZSA9IDEgLSBzZWxmLmRyYWdSZXNpc3RhbmNlLFxuICAgICAgICAgIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBwcmV2UG9pbnRlclggPSBzZWxmLnBvaW50ZXJYLFxuICAgICAgICAgIHByZXZQb2ludGVyWSA9IHNlbGYucG9pbnRlclksXG4gICAgICAgICAgcHJldlN0YXJ0RWxlbWVudFkgPSBzdGFydEVsZW1lbnRZLFxuICAgICAgICAgIHByZXZYID0gc2VsZi54LFxuICAgICAgICAgIHByZXZZID0gc2VsZi55LFxuICAgICAgICAgIHByZXZFbmRYID0gc2VsZi5lbmRYLFxuICAgICAgICAgIHByZXZFbmRZID0gc2VsZi5lbmRZLFxuICAgICAgICAgIHByZXZFbmRSb3RhdGlvbiA9IHNlbGYuZW5kUm90YXRpb24sXG4gICAgICAgICAgcHJldkRpcnR5ID0gZGlydHksXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkaWYsXG4gICAgICAgICAgdGVtcDtcbiAgICAgIHNlbGYucG9pbnRlclggPSBwb2ludGVyWDtcbiAgICAgIHNlbGYucG9pbnRlclkgPSBwb2ludGVyWTtcblxuICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgcG9pbnRlclggLT0gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpO1xuICAgICAgICBwb2ludGVyWSAtPSBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICB5ID0gTWF0aC5hdGFuMihyb3RhdGlvbk9yaWdpbi55IC0gcG9pbnRlclksIHBvaW50ZXJYIC0gcm90YXRpb25PcmlnaW4ueCkgKiBfUkFEMkRFRztcbiAgICAgICAgZGlmID0gc2VsZi55IC0geTtcblxuICAgICAgICBpZiAoZGlmID4gMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSAtPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWYgPCAtMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSArPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHN0YXJ0RWxlbWVudFggfHwgTWF0aC5hYnMoc3RhcnRFbGVtZW50WSAtIHkpID4gbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgICB4ID0gc3RhcnRFbGVtZW50WCArIChzdGFydEVsZW1lbnRZIC0geSkgKiBkcmFnVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBzdGFydEVsZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgdGVtcCA9IHBvaW50ZXJYICogbWF0cml4LmEgKyBwb2ludGVyWSAqIG1hdHJpeC5jICsgbWF0cml4LmU7XG4gICAgICAgICAgcG9pbnRlclkgPSBwb2ludGVyWCAqIG1hdHJpeC5iICsgcG9pbnRlclkgKiBtYXRyaXguZCArIG1hdHJpeC5mO1xuICAgICAgICAgIHBvaW50ZXJYID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHlDaGFuZ2UgPSBwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclk7XG4gICAgICAgIHhDaGFuZ2UgPSBwb2ludGVyWCAtIHN0YXJ0UG9pbnRlclg7XG5cbiAgICAgICAgaWYgKHlDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeUNoYW5nZSA+IC1taW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Q2hhbmdlIDwgbWluaW11bU1vdmVtZW50ICYmIHhDaGFuZ2UgPiAtbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgeENoYW5nZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHNlbGYubG9ja0F4aXMgfHwgc2VsZi5sb2NrZWRBeGlzKSAmJiAoeENoYW5nZSB8fCB5Q2hhbmdlKSkge1xuICAgICAgICAgIHRlbXAgPSBzZWxmLmxvY2tlZEF4aXM7XG5cbiAgICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHNlbGYubG9ja2VkQXhpcyA9IHRlbXAgPSBhbGxvd1ggJiYgTWF0aC5hYnMoeENoYW5nZSkgPiBNYXRoLmFicyh5Q2hhbmdlKSA/IFwieVwiIDogYWxsb3dZID8gXCJ4XCIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGVtcCAmJiBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykpIHtcbiAgICAgICAgICAgICAgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBzZWxmLnBvaW50ZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRlbXAgPT09IFwieVwiKSB7XG4gICAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPT09IFwieFwiKSB7XG4gICAgICAgICAgICB4Q2hhbmdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gX3JvdW5kKHN0YXJ0RWxlbWVudFggKyB4Q2hhbmdlICogZHJhZ1RvbGVyYW5jZSk7XG4gICAgICAgIHkgPSBfcm91bmQoc3RhcnRFbGVtZW50WSArIHlDaGFuZ2UgKiBkcmFnVG9sZXJhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5ICYmICFyb3RhdGlvbk1vZGUpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHg7XG4gICAgICAgICAgX3RlbXAxLnkgPSB5O1xuICAgICAgICAgIHRlbXAgPSBzbmFwWFkoX3RlbXAxKTtcbiAgICAgICAgICB4ID0gX3JvdW5kKHRlbXAueCk7XG4gICAgICAgICAgeSA9IF9yb3VuZCh0ZW1wLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgeCA9IF9yb3VuZChzbmFwWCh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICB5ID0gX3JvdW5kKHNuYXBZKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQm91bmRzKSB7XG4gICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgIHggPSBtYXhYICsgTWF0aC5yb3VuZCgoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICB4ID0gbWluWCArIE1hdGgucm91bmQoKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKG1heFkgKyAoeSAtIG1heFkpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobWluWSArICh5IC0gbWluWSkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkgJiYgIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7IC8vYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgbmV4dCB0aW1lIHRoZSBUd2VlbkxpdGUudGlja2VyIGRpc3BhdGNoZXMgYSBcInRpY2tcIiBldmVudCAodHlwaWNhbGx5IG9uIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKHdlIHNob3VsZG4ndCByZW5kZXIgb24gZXZlcnkgbW92ZSBiZWNhdXNlIHNvbWV0aW1lcyBtYW55IG1vdmUgZXZlbnRzIGNhbiBnZXQgZGlzcGF0Y2hlZCBiZXR3ZWVuIHNjcmVlbiByZWZyZXNoZXMsIGFuZCB0aGF0J2QgYmUgd2FzdGVmdWwgdG8gcmVuZGVyIGV2ZXJ5IHRpbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc2VsZi5lbmRYID0geDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludm9rZU9uTW92ZSB8fCBfZGlzcGF0Y2hFdmVudChzZWxmLCBcIm1vdmVcIiwgXCJvbk1vdmVcIikgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLmlzRHJhZ2dpbmcgJiYgc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IGRyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL3JldmVydCBiZWNhdXNlIHRoZSBvbk1vdmUgcmV0dXJuZWQgZmFsc2UhXG4gICAgICAgICAgc2VsZi5wb2ludGVyWCA9IHByZXZQb2ludGVyWDtcbiAgICAgICAgICBzZWxmLnBvaW50ZXJZID0gcHJldlBvaW50ZXJZO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBwcmV2U3RhcnRFbGVtZW50WTtcbiAgICAgICAgICBzZWxmLnggPSBwcmV2WDtcbiAgICAgICAgICBzZWxmLnkgPSBwcmV2WTtcbiAgICAgICAgICBzZWxmLmVuZFggPSBwcmV2RW5kWDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBwcmV2RW5kWTtcbiAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gcHJldkVuZFJvdGF0aW9uO1xuICAgICAgICAgIGRpcnR5ID0gcHJldkRpcnR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgd2hlbiB0aGUgbW91c2UvdG91Y2ggaXMgcmVsZWFzZWRcbiAgICBvblJlbGVhc2UgPSBmdW5jdGlvbiBvblJlbGVhc2UoZSwgZm9yY2UpIHtcbiAgICAgIGlmICghZW5hYmxlZCB8fCAhc2VsZi5pc1ByZXNzZWQgfHwgZSAmJiB0b3VjaElEICE9IG51bGwgJiYgIWZvcmNlICYmIChlLnBvaW50ZXJJZCAmJiBlLnBvaW50ZXJJZCAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0IHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgIV9oYXNUb3VjaElEKGUuY2hhbmdlZFRvdWNoZXMsIHRvdWNoSUQpKSkge1xuICAgICAgICAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vycywgd2UgbXVzdCBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvIHRoZSBkb2MgcmF0aGVyIHRoYW4gdGhlIHRyaWdnZXIgc28gdGhhdCB3aGVuIHRoZSBmaW5nZXIgbW92ZXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSB0cmlnZ2VyLCB0aGluZ3Mgc3RpbGwgd29yay4gU28gaWYgdGhlIGV2ZW50IHdlJ3JlIHJlY2VpdmluZyBoYXMgYSBwb2ludGVySWQgdGhhdCBkb2Vzbid0IG1hdGNoIHRoZSB0b3VjaElELCBpZ25vcmUgaXQgKGZvciBtdWx0aS10b3VjaClcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaGVuZCwgcG9pbnRlcnVwLCBtb3VzZXVwLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZSxcbiAgICAgICAgICB3YXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyxcbiAgICAgICAgICBpc0NvbnRleHRNZW51UmVsZWFzZSA9IHNlbGYudmFycy5hbGxvd0NvbnRleHRNZW51ICYmIGUgJiYgKGUuY3RybEtleSB8fCBlLndoaWNoID4gMiksXG4gICAgICAgICAgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoMC4wMDEsIHJlbW92ZVBsYWNlaG9sZGVyKSxcbiAgICAgICAgICB0b3VjaGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc3ludGhldGljRXZlbnQsXG4gICAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgICAgc3ludGhldGljQ2xpY2s7XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgIGlmICghX3N1cHBvcnRzUG9pbnRlciB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIGUgJiYgZS50YXJnZXQgJiYgX3JlbW92ZUxpc3RlbmVyKGUudGFyZ2V0LCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcbiAgICAgIH1cblxuICAgICAgZGlydHkgPSBmYWxzZTtcblxuICAgICAgaWYgKHdhc0RyYWdnaW5nKSB7XG4gICAgICAgIGRyYWdFbmRUaW1lID0gX2xhc3REcmFnVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIGlmIChpc0NsaWNraW5nICYmICFpc0NvbnRleHRNZW51UmVsZWFzZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuXG4gICAgICAgIGlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCB2YXJzLmN1cnNvciB8fCAodmFycy5jdXJzb3IgIT09IGZhbHNlID8gX2RlZmF1bHRDdXJzb3IgOiBudWxsKSk7XG4gICAgICB9XG5cbiAgICAgIF9kcmFnQ291bnQtLTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgICAgaWYgKGUgIT09IHRvdWNoICYmIGUuaWRlbnRpZmllciAhPT0gdG91Y2hJRCkge1xuICAgICAgICAgICAgLy9Vc3VhbGx5IGNoYW5nZWRUb3VjaGVzWzBdIHdpbGwgYmUgd2hhdCB3ZSdyZSBsb29raW5nIGZvciwgYnV0IGluIGNhc2UgaXQncyBub3QsIGxvb2sgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgYXJyYXkuLi4oYW5kIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgcmV1c2UgdGhlIGV2ZW50IGxpa2UgaU9TKVxuICAgICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoLS1pID4gLTEgJiYgKGUgPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQpIHt9XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG4gICAgICAgIHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb250ZXh0TWVudVJlbGVhc2UgJiYgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50ICYmICF3YXNEcmFnZ2luZykge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGludGVycnVwdGVkICYmICh2YXJzLnNuYXAgfHwgdmFycy5ib3VuZHMpKSB7XG4gICAgICAgICAgLy9vdGhlcndpc2UsIGlmIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgb2JqZWN0IHdoaWxlIGl0J3MgYW5pbWF0aW5nIHRvIGEgc25hcHBlZCBwb3NpdGlvbiwgYW5kIHRoZW4gcmVsZWFzZXMgd2l0aG91dCBtb3ZpbmcgMyBwaXhlbHMsIGl0IHdpbGwganVzdCBzdGF5IHRoZXJlIChpdCBzaG91bGQgYW5pbWF0ZS9zbmFwKVxuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cbiAgICAgICAgaWYgKCghX2lzQW5kcm9pZCB8fCBvcmlnaW5hbEV2ZW50LnR5cGUgIT09IFwidG91Y2htb3ZlXCIpICYmIG9yaWdpbmFsRXZlbnQudHlwZS5pbmRleE9mKFwiY2FuY2VsXCIpID09PSAtMSkge1xuICAgICAgICAgIC8vdG8gYWNjb21tb2RhdGUgbmF0aXZlIHNjcm9sbGluZyBvbiBBbmRyb2lkIGRldmljZXMsIHdlIGhhdmUgdG8gaW1tZWRpYXRlbHkgY2FsbCBvblJlbGVhc2UoKSBvbiB0aGUgZmlyc3QgdG91Y2htb3ZlIGV2ZW50LCBidXQgdGhhdCBzaG91bGRuJ3QgdHJpZ2dlciBhIFwiY2xpY2tcIi5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcblxuICAgICAgICAgIGlmIChfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRvdWJsZWNsaWNrXCIsIFwib25Eb3VibGVDbGlja1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldmVudFRhcmdldCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IHRhcmdldDsgLy9vbGQgSUUgdXNlcyBzcmNFbGVtZW50XG5cbiAgICAgICAgICBjbGlja1RpbWUgPSBfZ2V0VGltZSgpO1xuXG4gICAgICAgICAgc3ludGhldGljQ2xpY2sgPSBmdW5jdGlvbiBzeW50aGV0aWNDbGljaygpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoY2xpY2tUaW1lICE9PSBjbGlja0Rpc3BhdGNoICYmIHNlbGYuZW5hYmxlZCgpICYmICFzZWxmLmlzUHJlc3NlZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5YLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5ZLCBzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChzeW50aGV0aWNFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFfaXNBbmRyb2lkICYmICFvcmlnaW5hbEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIC8vaU9TIFNhZmFyaSByZXF1aXJlcyB0aGUgc3ludGhldGljIGNsaWNrIHRvIGhhcHBlbiBpbW1lZGlhdGVseSBvciBlbHNlIGl0IHNpbXBseSB3b24ndCB3b3JrLCBidXQgQW5kcm9pZCBkb2Vzbid0IHBsYXkgbmljZS5cbiAgICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wNSwgc3ludGhldGljQ2xpY2spOyAvL2luIGFkZGl0aW9uIHRvIHRoZSBpT1MgYnVnIHdvcmthcm91bmQsIHRoZXJlJ3MgYSBGaXJlZm94IGlzc3VlIHdpdGggY2xpY2tpbmcgb24gdGhpbmdzIGxpa2UgYSB2aWRlbyB0byBwbGF5LCBzbyB3ZSBtdXN0IGZha2UgYSBjbGljayBldmVudCBpbiBhIHNsaWdodGx5IGRlbGF5ZWQgZmFzaGlvbi4gUHJldmlvdXNseSwgd2UgbGlzdGVuZWQgZm9yIHRoZSBcImNsaWNrXCIgZXZlbnQgd2l0aCBcImNhcHR1cmVcIiBmYWxzZSB3aGljaCBzb2x2ZWQgdGhlIHZpZGVvLWNsaWNrLXRvLXBsYXkgaXNzdWUsIGJ1dCBpdCB3b3VsZCBhbGxvdyB0aGUgXCJjbGlja1wiIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQgdHdpY2UgbGlrZSBpZiB5b3Ugd2VyZSB1c2luZyBhIGpRdWVyeS5jbGljaygpIGJlY2F1c2UgdGhhdCB3YXMgaGFuZGxlZCBpbiB0aGUgY2FwdHVyZSBwaGFzZSwgdGh1cyB3ZSBoYWQgdG8gc3dpdGNoIHRvIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGF2b2lkIHRoZSBkb3VibGUtZGlzcGF0Y2hpbmcsIGJ1dCBkbyB0aGUgZGVsYXllZCBzeW50aGV0aWMgY2xpY2suIERvbid0IGZpcmUgaXQgdG9vIGZhc3QgKGxpa2UgMC4wMDAwMSkgYmVjYXVzZSB3ZSB3YW50IHRvIGdpdmUgdGhlIG5hdGl2ZSBldmVudCBhIGNoYW5jZSB0byBmaXJlIGZpcnN0IGFzIGl0J3MgXCJ0cnVzdGVkXCIuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpOyAvL3dpbGwgc2tpcCBpZiBpbmVydGlhL3Rocm93UHJvcHMgaXNuJ3QgZGVmaW5lZCBvciBJbmVydGlhUGx1Z2luIGlzbid0IGxvYWRlZC5cblxuICAgICAgICBpZiAoIXNlbGYuYWxsb3dFdmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudCAmJiAodmFycy5kcmFnQ2xpY2thYmxlcyAhPT0gZmFsc2UgfHwgIWlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgb3JpZ2luYWxFdmVudC50YXJnZXQpKSAmJiB3YXNEcmFnZ2luZyAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfVxuXG4gICAgICBpc1R3ZWVuaW5nKCkgJiYgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbC5kdXJhdGlvbihzZWxmLnR3ZWVuLmR1cmF0aW9uKCkpOyAvL3N5bmMgdGhlIHRpbWluZyBzbyB0aGF0IHRoZSBwbGFjZWhvbGRlciBESVYgZ2V0c1xuXG4gICAgICB3YXNEcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICAgICB1cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoZSkge1xuICAgICAgaWYgKGUgJiYgc2VsZi5pc0RyYWdnaW5nICYmICFzY3JvbGxQcm94eSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZS50YXJnZXQgfHwgdGFyZ2V0LnBhcmVudE5vZGUsXG4gICAgICAgICAgICBkZWx0YVggPSBwYXJlbnQuc2Nyb2xsTGVmdCAtIHBhcmVudC5fZ3NTY3JvbGxYLFxuICAgICAgICAgICAgZGVsdGFZID0gcGFyZW50LnNjcm9sbFRvcCAtIHBhcmVudC5fZ3NTY3JvbGxZO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWCAtPSBkZWx0YVggKiBtYXRyaXguYSArIGRlbHRhWSAqIG1hdHJpeC5jO1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWSAtPSBkZWx0YVkgKiBtYXRyaXguZCArIGRlbHRhWCAqIG1hdHJpeC5iO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJYIC09IGRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclkgLT0gZGVsdGFZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudC5fZ3NTY3JvbGxYICs9IGRlbHRhWDtcbiAgICAgICAgICBwYXJlbnQuX2dzU2Nyb2xsWSArPSBkZWx0YVk7XG4gICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgLy90aGlzIHdhcyBhIGh1Z2UgcGFpbiBpbiB0aGUgbmVjayB0byBhbGlnbiBhbGwgdGhlIHZhcmlvdXMgYnJvd3NlcnMgYW5kIHRoZWlyIGJlaGF2aW9ycy4gQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIE9wZXJhLCBBbmRyb2lkLCBhbmQgTWljcm9zb2Z0IEVkZ2UgYWxsIGhhbmRsZSBldmVudHMgZGlmZmVyZW50bHkhIFNvbWUgd2lsbCBvbmx5IHRyaWdnZXIgbmF0aXZlIGJlaGF2aW9yIChsaWtlIGNoZWNrYm94IHRvZ2dsaW5nKSBmcm9tIHRydXN0ZWQgZXZlbnRzLiBPdGhlcnMgZG9uJ3QgZXZlbiBzdXBwb3J0IGlzVHJ1c3RlZCwgYnV0IHJlcXVpcmUgMiBldmVudHMgdG8gZmxvdyB0aHJvdWdoIGJlZm9yZSB0cmlnZ2VyaW5nIG5hdGl2ZSBiZWhhdmlvci4gRWRnZSB0cmVhdHMgZXZlcnl0aGluZyBhcyB0cnVzdGVkIGJ1dCBhbHNvIG1hbmRhdGVzIHRoYXQgMiBmbG93IHRocm91Z2ggdG8gdHJpZ2dlciB0aGUgY29ycmVjdCBuYXRpdmUgYmVoYXZpb3IuXG4gICAgICB2YXIgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgICAgcmVjZW50bHlDbGlja2VkID0gdGltZSAtIGNsaWNrVGltZSA8IDEwMCxcbiAgICAgICAgICByZWNlbnRseURyYWdnZWQgPSB0aW1lIC0gZHJhZ0VuZFRpbWUgPCA1MCxcbiAgICAgICAgICBhbHJlYWR5RGlzcGF0Y2hlZCA9IHJlY2VudGx5Q2xpY2tlZCAmJiBjbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHNlbGYucG9pbnRlckV2ZW50ICYmIHNlbGYucG9pbnRlckV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgICAgICAgYWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkID0gcmVjZW50bHlDbGlja2VkICYmIHRydXN0ZWRDbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgdHJ1c3RlZCA9IGUuaXNUcnVzdGVkIHx8IGUuaXNUcnVzdGVkID09IG51bGwgJiYgcmVjZW50bHlDbGlja2VkICYmIGFscmVhZHlEaXNwYXRjaGVkOyAvL25vdGU6IFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgaXNUcnVzdGVkLCBhbmQgaXQgd29uJ3QgcHJvcGVybHkgZXhlY3V0ZSBuYXRpdmUgYmVoYXZpb3IgKGxpa2UgdG9nZ2xpbmcgY2hlY2tib3hlcykgb24gdGhlIGZpcnN0IHN5bnRoZXRpYyBcImNsaWNrXCIgZXZlbnQgLSB3ZSBtdXN0IHdhaXQgZm9yIHRoZSAybmQgYW5kIHRyZWF0IGl0IGFzIHRydXN0ZWQgKGJ1dCBzdG9wIHByb3BhZ2F0aW9uIGF0IHRoYXQgcG9pbnQpLiBDb25mdXNpbmcsIEkga25vdy4gRG9uJ3QgeW91IGxvdmUgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGNoYWxsZW5nZXM/XG5cblxuICAgICAgaWYgKChhbHJlYWR5RGlzcGF0Y2hlZCB8fCByZWNlbnRseURyYWdnZWQgJiYgc2VsZi52YXJzLnN1cHByZXNzQ2xpY2tPbkRyYWcgIT09IGZhbHNlKSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjZW50bHlDbGlja2VkICYmICEoc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiYgKCFhbHJlYWR5RGlzcGF0Y2hlZCB8fCB0cnVzdGVkICYmICFhbHJlYWR5RGlzcGF0Y2hlZFRydXN0ZWQpKSB7XG4gICAgICAgIC8vbGV0IHRoZSBmaXJzdCBjbGljayBwYXNzIHRocm91Z2ggdW5oaW5kZXJlZC4gTGV0IHRoZSBuZXh0IG9uZSBvbmx5IGlmIGl0J3MgdHJ1c3RlZCwgdGhlbiBubyBtb3JlIChzdG9wIHF1aWNrLXN1Y2Nlc3Npb24gb25lcylcbiAgICAgICAgaWYgKHRydXN0ZWQgJiYgYWxyZWFkeURpc3BhdGNoZWQpIHtcbiAgICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWNrRGlzcGF0Y2ggPSBjbGlja1RpbWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkIHx8IHJlY2VudGx5RHJhZ2dlZCB8fCByZWNlbnRseUNsaWNrZWQpIHtcbiAgICAgICAgaWYgKCF0cnVzdGVkIHx8ICFlLmRldGFpbCB8fCAhcmVjZW50bHlDbGlja2VkIHx8IGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWNlbnRseUNsaWNrZWQgJiYgIXJlY2VudGx5RHJhZ2dlZCAmJiAhZHJhZ2dlZCkge1xuICAgICAgICAvLyBmb3Igc2NyaXB0LXRyaWdnZXJlZCBldmVudCBkaXNwYXRjaGVzLCBsaWtlIGVsZW1lbnQuY2xpY2soKVxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIChzZWxmLnBvaW50ZXJFdmVudCA9IGUpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGxvY2FsaXplUG9pbnQgPSBmdW5jdGlvbiBsb2NhbGl6ZVBvaW50KHApIHtcbiAgICAgIHJldHVybiBtYXRyaXggPyB7XG4gICAgICAgIHg6IHAueCAqIG1hdHJpeC5hICsgcC55ICogbWF0cml4LmMgKyBtYXRyaXguZSxcbiAgICAgICAgeTogcC54ICogbWF0cml4LmIgKyBwLnkgKiBtYXRyaXguZCArIG1hdHJpeC5mXG4gICAgICB9IDoge1xuICAgICAgICB4OiBwLngsXG4gICAgICAgIHk6IHAueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgb2xkID0gRHJhZ2dhYmxlLmdldCh0YXJnZXQpO1xuICAgIG9sZCAmJiBvbGQua2lsbCgpOyAvLyBhdm9pZHMgZHVwbGljYXRlcyAoYW4gZWxlbWVudCBjYW4gb25seSBiZSBjb250cm9sbGVkIGJ5IG9uZSBEcmFnZ2FibGUpXG4gICAgLy9naXZlIHRoZSB1c2VyIGFjY2VzcyB0byBzdGFydC9zdG9wIGRyYWdnaW5nLi4uXG5cbiAgICBfdGhpczIuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2ZW50LCBhbGlnbikge1xuICAgICAgdmFyIHIxLCByMiwgcDEsIHAyO1xuICAgICAgb25QcmVzcyhldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7IC8vaWYgdGhlIHBvaW50ZXIgaXNuJ3Qgb24gdG9wIG9mIHRoZSBlbGVtZW50LCBhZGp1c3QgdGhpbmdzIGFjY29yZGluZ2x5XG5cbiAgICAgIGlmIChhbGlnbiAmJiAhc2VsZi5oaXRUZXN0KGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50KSkge1xuICAgICAgICByMSA9IF9wYXJzZVJlY3QoZXZlbnQgfHwgc2VsZi5wb2ludGVyRXZlbnQpO1xuICAgICAgICByMiA9IF9wYXJzZVJlY3QodGFyZ2V0KTtcbiAgICAgICAgcDEgPSBsb2NhbGl6ZVBvaW50KHtcbiAgICAgICAgICB4OiByMS5sZWZ0ICsgcjEud2lkdGggLyAyLFxuICAgICAgICAgIHk6IHIxLnRvcCArIHIxLmhlaWdodCAvIDJcbiAgICAgICAgfSk7XG4gICAgICAgIHAyID0gbG9jYWxpemVQb2ludCh7XG4gICAgICAgICAgeDogcjIubGVmdCArIHIyLndpZHRoIC8gMixcbiAgICAgICAgICB5OiByMi50b3AgKyByMi5oZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydFBvaW50ZXJYIC09IHAxLnggLSBwMi54O1xuICAgICAgICBzdGFydFBvaW50ZXJZIC09IHAxLnkgLSBwMi55O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBkcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpczIuZHJhZyA9IG9uTW92ZTtcblxuICAgIF90aGlzMi5lbmREcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBvblJlbGVhc2UoZSB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYuaXNEcmFnZ2luZyA/IDAgOiAoX2dldFRpbWUoKSAtIGRyYWdFbmRUaW1lKSAvIDEwMDA7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX2dldFRpbWUoKSAtIGNsaWNrVGltZSkgLyAxMDAwO1xuICAgIH07XG5cbiAgICBfdGhpczIuaGl0VGVzdCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIERyYWdnYWJsZS5oaXRUZXN0KHNlbGYudGFyZ2V0LCB0YXJnZXQsIHRocmVzaG9sZCk7XG4gICAgfTtcblxuICAgIF90aGlzMi5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZnJvbSwgZGlhZ29uYWxUaHJlc2hvbGQpIHtcbiAgICAgIC8vZnJvbSBjYW4gYmUgXCJzdGFydFwiIChkZWZhdWx0KSwgXCJ2ZWxvY2l0eVwiLCBvciBhbiBlbGVtZW50XG4gICAgICB2YXIgbW9kZSA9IGZyb20gPT09IFwidmVsb2NpdHlcIiAmJiBJbmVydGlhUGx1Z2luID8gZnJvbSA6IF9pc09iamVjdChmcm9tKSAmJiAhcm90YXRpb25Nb2RlID8gXCJlbGVtZW50XCIgOiBcInN0YXJ0XCIsXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICByMSxcbiAgICAgICAgICByMjtcblxuICAgICAgaWYgKG1vZGUgPT09IFwiZWxlbWVudFwiKSB7XG4gICAgICAgIHIxID0gX3BhcnNlUmVjdChzZWxmLnRhcmdldCk7XG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChmcm9tKTtcbiAgICAgIH1cblxuICAgICAgeENoYW5nZSA9IG1vZGUgPT09IFwic3RhcnRcIiA/IHNlbGYueCAtIHN0YXJ0RWxlbWVudFggOiBtb2RlID09PSBcInZlbG9jaXR5XCIgPyBJbmVydGlhUGx1Z2luLmdldFZlbG9jaXR5KHRhcmdldCwgeFByb3ApIDogcjEubGVmdCArIHIxLndpZHRoIC8gMiAtIChyMi5sZWZ0ICsgcjIud2lkdGggLyAyKTtcblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICByZXR1cm4geENoYW5nZSA8IDAgPyBcImNvdW50ZXItY2xvY2t3aXNlXCIgOiBcImNsb2Nrd2lzZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlhZ29uYWxUaHJlc2hvbGQgPSBkaWFnb25hbFRocmVzaG9sZCB8fCAyO1xuICAgICAgICB5Q2hhbmdlID0gbW9kZSA9PT0gXCJzdGFydFwiID8gc2VsZi55IC0gc3RhcnRFbGVtZW50WSA6IG1vZGUgPT09IFwidmVsb2NpdHlcIiA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB5UHJvcCkgOiByMS50b3AgKyByMS5oZWlnaHQgLyAyIC0gKHIyLnRvcCArIHIyLmhlaWdodCAvIDIpO1xuICAgICAgICByYXRpbyA9IE1hdGguYWJzKHhDaGFuZ2UgLyB5Q2hhbmdlKTtcbiAgICAgICAgZGlyZWN0aW9uID0gcmF0aW8gPCAxIC8gZGlhZ29uYWxUaHJlc2hvbGQgPyBcIlwiIDogeENoYW5nZSA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcblxuICAgICAgICBpZiAocmF0aW8gPCBkaWFnb25hbFRocmVzaG9sZCkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiArPSBcIi1cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3Rpb24gKz0geUNoYW5nZSA8IDAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH07XG5cbiAgICBfdGhpczIuYXBwbHlCb3VuZHMgPSBmdW5jdGlvbiAobmV3Qm91bmRzLCBzdGlja3kpIHtcbiAgICAgIHZhciB4LCB5LCBmb3JjZVplcm9WZWxvY2l0eSwgZSwgcGFyZW50LCBpc1Jvb3Q7XG5cbiAgICAgIGlmIChuZXdCb3VuZHMgJiYgdmFycy5ib3VuZHMgIT09IG5ld0JvdW5kcykge1xuICAgICAgICB2YXJzLmJvdW5kcyA9IG5ld0JvdW5kcztcbiAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlKHRydWUsIHN0aWNreSk7XG4gICAgICB9XG5cbiAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuXG4gICAgICBpZiAoaGFzQm91bmRzICYmICFpc1R3ZWVuaW5nKCkpIHtcbiAgICAgICAgeCA9IHNlbGYueDtcbiAgICAgICAgeSA9IHNlbGYueTtcblxuICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICB4ID0gbWF4WDtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgIHggPSBtaW5YO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgeSA9IG1heFk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICB5ID0gbWluWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5KSB7XG4gICAgICAgICAgZm9yY2VaZXJvVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgIHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0geDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi55ID0gc2VsZi5lbmRZID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgcmVuZGVyKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsVG9wID0gX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWU9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgICAgICAvL3dhbGsgdXAgdGhlIGNoYWluIGFuZCBzZW5zZSB3aGVyZXZlciB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgZXhjZWVkcyB0aGUgbWF4aW11bS5cbiAgICAgICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICBwYXJlbnQgPSBpc1Jvb3QgPyBfd2luZG93UHJveHkgOiBlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGFsbG93WSAmJiBwYXJlbnQuc2Nyb2xsVG9wID4gcGFyZW50Ll9nc01heFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wID0gcGFyZW50Ll9nc01heFNjcm9sbFk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWxsb3dYICYmIHBhcmVudC5zY3JvbGxMZWZ0ID4gcGFyZW50Ll9nc01heFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pc1Rocm93aW5nICYmIChmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmVuZFggPiBtYXhYIHx8IHNlbGYuZW5kWCA8IG1pblggfHwgc2VsZi5lbmRZID4gbWF4WSB8fCBzZWxmLmVuZFkgPCBtaW5ZKSkge1xuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcywgZm9yY2VaZXJvVmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIudXBkYXRlID0gZnVuY3Rpb24gKGFwcGx5Qm91bmRzLCBzdGlja3ksIGlnbm9yZUV4dGVybmFsQ2hhbmdlcykge1xuICAgICAgaWYgKHN0aWNreSAmJiBzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBlbGVtZW50IHdhcyByZXBvc2l0aW9uZWQgaW4gdGhlIGRvY3VtZW50IGZsb3csIHRodXMgaXRzIHgveSBtYXkgYmUgaWRlbnRpY2FsIGJ1dCBpdHMgcG9zaXRpb24gaXMgYWN0dWFsbHkgcXVpdGUgZGlmZmVyZW50LlxuICAgICAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLFxuICAgICAgICAgICAgcCA9IGlubmVyTWF0cml4LmFwcGx5KHtcbiAgICAgICAgICB4OiBzZWxmLnggLSBzdGFydEVsZW1lbnRYLFxuICAgICAgICAgIHk6IHNlbGYueSAtIHN0YXJ0RWxlbWVudFlcbiAgICAgICAgfSksXG4gICAgICAgICAgICBtMiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIG0yLmFwcGx5KHtcbiAgICAgICAgICB4OiBtLmUgLSBwLngsXG4gICAgICAgICAgeTogbS5mIC0gcC55XG4gICAgICAgIH0sIHApO1xuICAgICAgICBzZWxmLnggLT0gcC54IC0gbTIuZTtcbiAgICAgICAgc2VsZi55IC09IHAueSAtIG0yLmY7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgeSA9IHNlbGYueTtcbiAgICAgIHVwZGF0ZU1hdHJpeCghc3RpY2t5KTtcblxuICAgICAgaWYgKGFwcGx5Qm91bmRzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5ICYmIGlnbm9yZUV4dGVybmFsQ2hhbmdlcyAmJiByZW5kZXIodHJ1ZSk7XG4gICAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWNreSkge1xuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkICYmICFzdGlja3kgJiYgKGFsbG93WCAmJiBNYXRoLmFicyh4IC0gc2VsZi54KSA+IDAuMDEgfHwgYWxsb3dZICYmIE1hdGguYWJzKHkgLSBzZWxmLnkpID4gMC4wMSAmJiAhcm90YXRpb25Nb2RlKSkge1xuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsKSB7XG4gICAgICAgIF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgICAgcmVuZGVyKHRydWUpOyAvL2luIGNhc2UgcmVwYXJlbnRpbmcgb2NjdXJyZWQuXG5cbiAgICAgICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcblxuICAgICAgICBfYWRkU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2V0VmFycyA9IHtcbiAgICAgICAgbGF6eTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0VmFycy5jdXJzb3IgPSB2YXJzLmN1cnNvciB8fCBfZGVmYXVsdEN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0b3VjaENhbGxvdXRcIikpIHtcbiAgICAgICAgc2V0VmFycy50b3VjaENhbGxvdXQgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBhbGxvd1ggPT09IGFsbG93WSA/IFwibm9uZVwiIDogdmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPT09IHRhcmdldC5jbGllbnRIZWlnaHQgPT09ICh0YXJnZXQuc2Nyb2xsV2lkdGggPT09IHRhcmdldC5jbGllbnRIZWlnaHQpIHx8IHZhcnMuYWxsb3dFdmVudERlZmF1bHQgPyBcIm1hbmlwdWxhdGlvblwiIDogYWxsb3dYID8gXCJwYW4teVwiIDogXCJwYW4teFwiKTsgLy8gU29tZSBicm93c2VycyBsaWtlIEludGVybmV0IEV4cGxvcmVyIHdpbGwgZmlyZSBhIHBvaW50ZXJjYW5jZWwgZXZlbnQgd2hlbiB0aGUgdXNlciBhdHRlbXB0cyB0byBkcmFnIHdoZW4gdG91Y2hBY3Rpb24gaXMgXCJtYW5pcHVsYXRlXCIgYmVjYXVzZSBpdCdzIHBlcmNlaXZlZCBhcyBhIHBhbi4gSWYgdGhlIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgY29udGVudCBpbiBvbmx5IG9uZSBkaXJlY3Rpb24sIHdlIHNob3VsZCB1c2UgcGFuLXggb3IgcGFuLXkgYWNjb3JkaW5nbHkgc28gdGhhdCB0aGUgcG9pbnRlcmNhbmNlbCBkb2Vzbid0IHByZXZlbnQgZHJhZ2dpbmcuXG5cblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcbiAgICAgICAgICBfc3VwcG9ydHNQb2ludGVyIHx8IF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrLCB0cnVlKTsgLy8gbm90ZTogdXNlZCB0byBwYXNzIHRydWUgZm9yIGNhcHR1cmUgYnV0IGl0IHByZXZlbnRlZCBjbGljay10by1wbGF5LXZpZGVvIGZ1bmN0aW9uYWxpdHkgaW4gRmlyZWZveC5cblxuXG4gICAgICAgICAgZ3NhcC5zZXQodHJpZ2dlciwgc2V0VmFycyk7XG5cbiAgICAgICAgICBpZiAodHJpZ2dlci5nZXRCQm94ICYmIHRyaWdnZXIub3duZXJTVkdFbGVtZW50ICYmIGFsbG93WCAhPT0gYWxsb3dZKSB7XG4gICAgICAgICAgICAvLyBhIGJ1ZyBpbiBjaHJvbWUgZG9lc24ndCByZXNwZWN0IHRvdWNoLWFjdGlvbiBvbiBTVkcgZWxlbWVudHMgLSBpdCBvbmx5IHdvcmtzIGlmIHdlIHNldCBpdCBvbiB0aGUgcGFyZW50IFNWRy5cbiAgICAgICAgICAgIGdzYXAuc2V0KHRyaWdnZXIub3duZXJTVkdFbGVtZW50LCB7XG4gICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiB2YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdmFycy5hbGxvd0V2ZW50RGVmYXVsdCA/IFwibWFuaXB1bGF0aW9uXCIgOiBhbGxvd1ggPyBcInBhbi15XCIgOiBcInBhbi14XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMuYWxsb3dDb250ZXh0TWVudSB8fCBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIF9hZGRTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoSW5lcnRpYVBsdWdpbiAmJiB0eXBlICE9PSBcInNvZnRcIikge1xuICAgICAgICBJbmVydGlhUGx1Z2luLnRyYWNrKHNjcm9sbFByb3h5IHx8IHRhcmdldCwgeHlNb2RlID8gXCJ4LHlcIiA6IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IFwidG9wLGxlZnRcIik7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5fZ3NEcmFnSUQgPSBpZCA9IFwiZFwiICsgX2xvb2t1cENvdW50Kys7XG4gICAgICBfbG9va3VwW2lkXSA9IHNlbGY7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5lbmFibGUoKTtcbiAgICAgICAgc2Nyb2xsUHJveHkuZWxlbWVudC5fZ3NEcmFnSUQgPSBpZDtcbiAgICAgIH1cblxuICAgICAgKHZhcnMuYm91bmRzIHx8IHJvdGF0aW9uTW9kZSkgJiYgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIHZhcnMuYm91bmRzICYmIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIuZGlzYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgZHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBudWxsKTtcblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcblxuICAgICAgICAgIF9zZXRTdHlsZSh0cmlnZ2VyLCBcInRvdWNoQ2FsbG91dFwiLCBudWxsKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpO1xuXG4gICAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXG4gICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICBJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiICYmIEluZXJ0aWFQbHVnaW4udW50cmFjayhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHh5TW9kZSA/IFwieCx5XCIgOiByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiBcInRvcCxsZWZ0XCIpO1xuICAgICAgc2Nyb2xsUHJveHkgJiYgc2Nyb2xsUHJveHkuZGlzYWJsZSgpO1xuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNQcmVzc2VkID0gaXNDbGlja2luZyA9IGZhbHNlO1xuICAgICAgZHJhZ2dpbmcgJiYgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnZW5kXCIsIFwib25EcmFnRW5kXCIpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIF90aGlzMi5lbmFibGVkID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHZhbHVlID8gc2VsZi5lbmFibGUodHlwZSkgOiBzZWxmLmRpc2FibGUodHlwZSkgOiBlbmFibGVkO1xuICAgIH07XG5cbiAgICBfdGhpczIua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuICAgICAgc2VsZi50d2VlbiAmJiBzZWxmLnR3ZWVuLmtpbGwoKTtcbiAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgZ3NhcC5zZXQodHJpZ2dlcnMsIHtcbiAgICAgICAgY2xlYXJQcm9wczogXCJ1c2VyU2VsZWN0XCJcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIF9sb29rdXBbdGFyZ2V0Ll9nc0RyYWdJRF07XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgaWYgKH50eXBlLmluZGV4T2YoXCJzY3JvbGxcIikpIHtcbiAgICAgIHNjcm9sbFByb3h5ID0gX3RoaXMyLnNjcm9sbFByb3h5ID0gbmV3IFNjcm9sbFByb3h5KHRhcmdldCwgX2V4dGVuZCh7XG4gICAgICAgIG9uS2lsbDogZnVuY3Rpb24gb25LaWxsKCkge1xuICAgICAgICAgIC8vU2Nyb2xsUHJveHkncyBvbktpbGwoKSBnZXRzIGNhbGxlZCBpZi93aGVuIHRoZSBTY3JvbGxQcm94eSBzZW5zZXMgdGhhdCB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBtYW51YWxseSAobGlrZSB1c2luZyB0aGUgc2Nyb2xsYmFyKS4gSUU5IGRvZXNuJ3QgZmlyZSB0aGUgXCJtb3VzZXVwXCIgcHJvcGVybHkgd2hlbiB1c2VycyBkcmFnIHRoZSBzY3JvbGxiYXIgb2YgYW4gZWxlbWVudCwgc28gdGhpcyB3b3JrcyBhcm91bmQgdGhhdCBpc3N1ZS5cbiAgICAgICAgICBzZWxmLmlzUHJlc3NlZCAmJiBvblJlbGVhc2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHZhcnMpKTsgLy9hIGJ1ZyBpbiBtYW55IEFuZHJvaWQgZGV2aWNlcycgc3RvY2sgYnJvd3NlciBjYXVzZXMgc2Nyb2xsVG9wIHRvIGdldCBmb3JjZWQgYmFjayB0byAwIGFmdGVyIGl0IGlzIGFsdGVyZWQgdmlhIEpTLCBzbyB3ZSBzZXQgb3ZlcmZsb3cgdG8gXCJoaWRkZW5cIiBvbiBtb2JpbGUvdG91Y2ggZGV2aWNlcyAodGhleSBoaWRlIHRoZSBzY3JvbGwgYmFyIGFueXdheSkuIFRoYXQgd29ya3MgYXJvdW5kIHRoZSBidWcuIChUaGlzIGJ1ZyBpcyBkaXNjdXNzZWQgYXQgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTk2MjUpXG5cbiAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvd1kgPSBhbGxvd1kgJiYgIV9pc1RvdWNoRGV2aWNlID8gXCJhdXRvXCIgOiBcImhpZGRlblwiO1xuICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93WCA9IGFsbG93WCAmJiAhX2lzVG91Y2hEZXZpY2UgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG4gICAgICB0YXJnZXQgPSBzY3JvbGxQcm94eS5jb250ZW50O1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgIGtpbGxQcm9wcy5yb3RhdGlvbiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAga2lsbFByb3BzW3hQcm9wXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAga2lsbFByb3BzW3lQcm9wXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3NDYWNoZS5mb3JjZTNEID0gXCJmb3JjZTNEXCIgaW4gdmFycyA/IHZhcnMuZm9yY2UzRCA6IHRydWU7IC8vb3RoZXJ3aXNlLCBub3JtYWwgZHJhZ2dpbmcgd291bGQgYmUgaW4gMkQgYW5kIHRoZW4gYXMgc29vbiBhcyBpdCdzIHJlbGVhc2VkIGFuZCB0aGVyZSdzIGFuIGluZXJ0aWEgdHdlZW4sIGl0J2QganVtcCB0byAzRCB3aGljaCBjYW4gY3JlYXRlIGFuIGluaXRpYWwganVtcCBkdWUgdG8gdGhlIHdvcmsgdGhlIGJyb3dzZXIgbXVzdCB0byBkbyBsYXllcml6ZSBpdC5cblxuICAgIF90aGlzMi5lbmFibGUoKTtcblxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBEcmFnZ2FibGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfTtcblxuICBEcmFnZ2FibGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHRhcmdldHMsIHZhcnMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKHRydWUpO1xuICAgIHJldHVybiBfdG9BcnJheSh0YXJnZXRzKS5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIG5ldyBEcmFnZ2FibGUodGFyZ2V0LCB2YXJzKTtcbiAgICB9KTtcbiAgfTtcblxuICBEcmFnZ2FibGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiBfbG9va3VwWyhfdG9BcnJheSh0YXJnZXQpWzBdIHx8IHt9KS5fZ3NEcmFnSURdO1xuICB9O1xuXG4gIERyYWdnYWJsZS50aW1lU2luY2VEcmFnID0gZnVuY3Rpb24gdGltZVNpbmNlRHJhZygpIHtcbiAgICByZXR1cm4gKF9nZXRUaW1lKCkgLSBfbGFzdERyYWdUaW1lKSAvIDEwMDA7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmhpdFRlc3QgPSBmdW5jdGlvbiBoaXRUZXN0KG9iajEsIG9iajIsIHRocmVzaG9sZCkge1xuICAgIGlmIChvYmoxID09PSBvYmoyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHIxID0gX3BhcnNlUmVjdChvYmoxKSxcbiAgICAgICAgcjIgPSBfcGFyc2VSZWN0KG9iajIpLFxuICAgICAgICB0b3AgPSByMS50b3AsXG4gICAgICAgIGxlZnQgPSByMS5sZWZ0LFxuICAgICAgICByaWdodCA9IHIxLnJpZ2h0LFxuICAgICAgICBib3R0b20gPSByMS5ib3R0b20sXG4gICAgICAgIHdpZHRoID0gcjEud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHIxLmhlaWdodCxcbiAgICAgICAgaXNPdXRzaWRlID0gcjIubGVmdCA+IHJpZ2h0IHx8IHIyLnJpZ2h0IDwgbGVmdCB8fCByMi50b3AgPiBib3R0b20gfHwgcjIuYm90dG9tIDwgdG9wLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBhcmVhLFxuICAgICAgICBpc1JhdGlvO1xuXG4gICAgaWYgKGlzT3V0c2lkZSB8fCAhdGhyZXNob2xkKSB7XG4gICAgICByZXR1cm4gIWlzT3V0c2lkZTtcbiAgICB9XG5cbiAgICBpc1JhdGlvID0gKHRocmVzaG9sZCArIFwiXCIpLmluZGV4T2YoXCIlXCIpICE9PSAtMTtcbiAgICB0aHJlc2hvbGQgPSBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMDtcbiAgICBvdmVybGFwID0ge1xuICAgICAgbGVmdDogTWF0aC5tYXgobGVmdCwgcjIubGVmdCksXG4gICAgICB0b3A6IE1hdGgubWF4KHRvcCwgcjIudG9wKVxuICAgIH07XG4gICAgb3ZlcmxhcC53aWR0aCA9IE1hdGgubWluKHJpZ2h0LCByMi5yaWdodCkgLSBvdmVybGFwLmxlZnQ7XG4gICAgb3ZlcmxhcC5oZWlnaHQgPSBNYXRoLm1pbihib3R0b20sIHIyLmJvdHRvbSkgLSBvdmVybGFwLnRvcDtcblxuICAgIGlmIChvdmVybGFwLndpZHRoIDwgMCB8fCBvdmVybGFwLmhlaWdodCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNSYXRpbykge1xuICAgICAgdGhyZXNob2xkICo9IDAuMDE7XG4gICAgICBhcmVhID0gb3ZlcmxhcC53aWR0aCAqIG92ZXJsYXAuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGFyZWEgPj0gd2lkdGggKiBoZWlnaHQgKiB0aHJlc2hvbGQgfHwgYXJlYSA+PSByMi53aWR0aCAqIHIyLmhlaWdodCAqIHRocmVzaG9sZDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmxhcC53aWR0aCA+IHRocmVzaG9sZCAmJiBvdmVybGFwLmhlaWdodCA+IHRocmVzaG9sZDtcbiAgfTtcblxuICByZXR1cm4gRHJhZ2dhYmxlO1xufShFdmVudERpc3BhdGNoZXIpO1xuXG5fc2V0RGVmYXVsdHMoRHJhZ2dhYmxlLnByb3RvdHlwZSwge1xuICBwb2ludGVyWDogMCxcbiAgcG9pbnRlclk6IDAsXG4gIHN0YXJ0WDogMCxcbiAgc3RhcnRZOiAwLFxuICBkZWx0YVg6IDAsXG4gIGRlbHRhWTogMCxcbiAgaXNEcmFnZ2luZzogZmFsc2UsXG4gIGlzUHJlc3NlZDogZmFsc2Vcbn0pO1xuXG5EcmFnZ2FibGUuekluZGV4ID0gMTAwMDtcbkRyYWdnYWJsZS52ZXJzaW9uID0gXCIzLjExLjJcIjtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihEcmFnZ2FibGUpO1xuZXhwb3J0IHsgRHJhZ2dhYmxlIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/Draggable.js\n"));

/***/ }),

/***/ "./node_modules/gsap/EasePack.js":
/*!***************************************!*\
  !*** ./node_modules/gsap/EasePack.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EasePack\": function() { return /* binding */ EasePack; },\n/* harmony export */   \"ExpoScaleEase\": function() { return /* binding */ ExpoScaleEase; },\n/* harmony export */   \"RoughEase\": function() { return /* binding */ RoughEase; },\n/* harmony export */   \"SlowMo\": function() { return /* binding */ SlowMo; },\n/* harmony export */   \"default\": function() { return /* binding */ EasePack; }\n/* harmony export */ });\n/*!\n * EasePack 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _registerEase,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _boolean = function _boolean(value, defaultValue) {\n  return !!(typeof value === \"undefined\" ? defaultValue : value && !~(value + \"\").indexOf(\"false\"));\n},\n    _initCore = function _initCore(core) {\n  gsap = core || _getGSAP();\n\n  if (gsap) {\n    _registerEase = gsap.registerEase; //add weighted ease capabilities to standard eases so users can do \"power2.inOut(0.8)\" for example to push everything toward the \"out\", or (-0.8) to push it toward the \"in\" (0 is neutral)\n\n    var eases = gsap.parseEase(),\n        createConfig = function createConfig(ease) {\n      return function (ratio) {\n        var y = 0.5 + ratio / 2;\n\n        ease.config = function (p) {\n          return ease(2 * (1 - p) * p * y + p * p);\n        };\n      };\n    },\n        p;\n\n    for (p in eases) {\n      if (!eases[p].config) {\n        createConfig(eases[p]);\n      }\n    }\n\n    _registerEase(\"slow\", SlowMo);\n\n    _registerEase(\"expoScale\", ExpoScaleEase);\n\n    _registerEase(\"rough\", RoughEase);\n\n    for (p in EasePack) {\n      p !== \"version\" && gsap.core.globals(p, EasePack[p]);\n    }\n\n    _coreInitted = 1;\n  }\n},\n    _createSlowMo = function _createSlowMo(linearRatio, power, yoyoMode) {\n  linearRatio = Math.min(1, linearRatio || 0.7);\n\n  var pow = linearRatio < 1 ? power || power === 0 ? power : 0.7 : 0,\n      p1 = (1 - linearRatio) / 2,\n      p3 = p1 + linearRatio,\n      calcEnd = _boolean(yoyoMode);\n\n  return function (p) {\n    var r = p + (0.5 - p) * pow;\n    return p < p1 ? calcEnd ? 1 - (p = 1 - p / p1) * p : r - (p = 1 - p / p1) * p * p * p * r : p > p3 ? calcEnd ? p === 1 ? 0 : 1 - (p = (p - p3) / p1) * p : r + (p - r) * (p = (p - p3) / p1) * p * p * p : calcEnd ? 1 : r;\n  };\n},\n    _createExpoScale = function _createExpoScale(start, end, ease) {\n  var p1 = Math.log(end / start),\n      p2 = end - start;\n  ease && (ease = gsap.parseEase(ease));\n  return function (p) {\n    return (start * Math.exp(p1 * (ease ? ease(p) : p)) - start) / p2;\n  };\n},\n    EasePoint = function EasePoint(time, value, next) {\n  this.t = time;\n  this.v = value;\n\n  if (next) {\n    this.next = next;\n    next.prev = this;\n    this.c = next.v - value;\n    this.gap = next.t - time;\n  }\n},\n    _createRoughEase = function _createRoughEase(vars) {\n  if (typeof vars !== \"object\") {\n    //users may pass in via a string, like \"rough(30)\"\n    vars = {\n      points: +vars || 20\n    };\n  }\n\n  var taper = vars.taper || \"none\",\n      a = [],\n      cnt = 0,\n      points = (+vars.points || 20) | 0,\n      i = points,\n      randomize = _boolean(vars.randomize, true),\n      clamp = _boolean(vars.clamp),\n      template = gsap ? gsap.parseEase(vars.template) : 0,\n      strength = (+vars.strength || 1) * 0.4,\n      x,\n      y,\n      bump,\n      invX,\n      obj,\n      pnt,\n      recent;\n\n  while (--i > -1) {\n    x = randomize ? Math.random() : 1 / points * i;\n    y = template ? template(x) : x;\n\n    if (taper === \"none\") {\n      bump = strength;\n    } else if (taper === \"out\") {\n      invX = 1 - x;\n      bump = invX * invX * strength;\n    } else if (taper === \"in\") {\n      bump = x * x * strength;\n    } else if (x < 0.5) {\n      //\"both\" (start)\n      invX = x * 2;\n      bump = invX * invX * 0.5 * strength;\n    } else {\n      //\"both\" (end)\n      invX = (1 - x) * 2;\n      bump = invX * invX * 0.5 * strength;\n    }\n\n    if (randomize) {\n      y += Math.random() * bump - bump * 0.5;\n    } else if (i % 2) {\n      y += bump * 0.5;\n    } else {\n      y -= bump * 0.5;\n    }\n\n    if (clamp) {\n      if (y > 1) {\n        y = 1;\n      } else if (y < 0) {\n        y = 0;\n      }\n    }\n\n    a[cnt++] = {\n      x: x,\n      y: y\n    };\n  }\n\n  a.sort(function (a, b) {\n    return a.x - b.x;\n  });\n  pnt = new EasePoint(1, 1, null);\n  i = points;\n\n  while (i--) {\n    obj = a[i];\n    pnt = new EasePoint(obj.x, obj.y, pnt);\n  }\n\n  recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);\n  return function (p) {\n    var pnt = recent;\n\n    if (p > pnt.t) {\n      while (pnt.next && p >= pnt.t) {\n        pnt = pnt.next;\n      }\n\n      pnt = pnt.prev;\n    } else {\n      while (pnt.prev && p <= pnt.t) {\n        pnt = pnt.prev;\n      }\n    }\n\n    recent = pnt;\n    return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;\n  };\n};\n\nvar SlowMo = _createSlowMo(0.7);\nSlowMo.ease = SlowMo; //for backward compatibility\n\nSlowMo.config = _createSlowMo;\nvar ExpoScaleEase = _createExpoScale(1, 2);\nExpoScaleEase.config = _createExpoScale;\nvar RoughEase = _createRoughEase();\nRoughEase.ease = RoughEase; //for backward compatibility\n\nRoughEase.config = _createRoughEase;\nvar EasePack = {\n  SlowMo: SlowMo,\n  RoughEase: RoughEase,\n  ExpoScaleEase: ExpoScaleEase\n};\n\nfor (var p in EasePack) {\n  EasePack[p].register = _initCore;\n  EasePack[p].version = \"3.11.2\";\n}\n\n_getGSAP() && gsap.registerPlugin(SlowMo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxzQkFBc0I7O0FBRXRCO0FBQ087QUFDUDtBQUNPO0FBQ1AsNEJBQTRCOztBQUU1QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvRWFzZVBhY2suanM/YjdhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEVhc2VQYWNrIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfcmVnaXN0ZXJFYXNlLFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfYm9vbGVhbiA9IGZ1bmN0aW9uIF9ib29sZWFuKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuICEhKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlICYmICF+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImZhbHNlXCIpKTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoZ3NhcCkge1xuICAgIF9yZWdpc3RlckVhc2UgPSBnc2FwLnJlZ2lzdGVyRWFzZTsgLy9hZGQgd2VpZ2h0ZWQgZWFzZSBjYXBhYmlsaXRpZXMgdG8gc3RhbmRhcmQgZWFzZXMgc28gdXNlcnMgY2FuIGRvIFwicG93ZXIyLmluT3V0KDAuOClcIiBmb3IgZXhhbXBsZSB0byBwdXNoIGV2ZXJ5dGhpbmcgdG93YXJkIHRoZSBcIm91dFwiLCBvciAoLTAuOCkgdG8gcHVzaCBpdCB0b3dhcmQgdGhlIFwiaW5cIiAoMCBpcyBuZXV0cmFsKVxuXG4gICAgdmFyIGVhc2VzID0gZ3NhcC5wYXJzZUVhc2UoKSxcbiAgICAgICAgY3JlYXRlQ29uZmlnID0gZnVuY3Rpb24gY3JlYXRlQ29uZmlnKGVhc2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgICAgdmFyIHkgPSAwLjUgKyByYXRpbyAvIDI7XG5cbiAgICAgICAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBlYXNlKDIgKiAoMSAtIHApICogcCAqIHkgKyBwICogcCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gZWFzZXMpIHtcbiAgICAgIGlmICghZWFzZXNbcF0uY29uZmlnKSB7XG4gICAgICAgIGNyZWF0ZUNvbmZpZyhlYXNlc1twXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyRWFzZShcInNsb3dcIiwgU2xvd01vKTtcblxuICAgIF9yZWdpc3RlckVhc2UoXCJleHBvU2NhbGVcIiwgRXhwb1NjYWxlRWFzZSk7XG5cbiAgICBfcmVnaXN0ZXJFYXNlKFwicm91Z2hcIiwgUm91Z2hFYXNlKTtcblxuICAgIGZvciAocCBpbiBFYXNlUGFjaykge1xuICAgICAgcCAhPT0gXCJ2ZXJzaW9uXCIgJiYgZ3NhcC5jb3JlLmdsb2JhbHMocCwgRWFzZVBhY2tbcF0pO1xuICAgIH1cblxuICAgIF9jb3JlSW5pdHRlZCA9IDE7XG4gIH1cbn0sXG4gICAgX2NyZWF0ZVNsb3dNbyA9IGZ1bmN0aW9uIF9jcmVhdGVTbG93TW8obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkge1xuICBsaW5lYXJSYXRpbyA9IE1hdGgubWluKDEsIGxpbmVhclJhdGlvIHx8IDAuNyk7XG5cbiAgdmFyIHBvdyA9IGxpbmVhclJhdGlvIDwgMSA/IHBvd2VyIHx8IHBvd2VyID09PSAwID8gcG93ZXIgOiAwLjcgOiAwLFxuICAgICAgcDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDIsXG4gICAgICBwMyA9IHAxICsgbGluZWFyUmF0aW8sXG4gICAgICBjYWxjRW5kID0gX2Jvb2xlYW4oeW95b01vZGUpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHZhciByID0gcCArICgwLjUgLSBwKSAqIHBvdztcbiAgICByZXR1cm4gcCA8IHAxID8gY2FsY0VuZCA/IDEgLSAocCA9IDEgLSBwIC8gcDEpICogcCA6IHIgLSAocCA9IDEgLSBwIC8gcDEpICogcCAqIHAgKiBwICogciA6IHAgPiBwMyA/IGNhbGNFbmQgPyBwID09PSAxID8gMCA6IDEgLSAocCA9IChwIC0gcDMpIC8gcDEpICogcCA6IHIgKyAocCAtIHIpICogKHAgPSAocCAtIHAzKSAvIHAxKSAqIHAgKiBwICogcCA6IGNhbGNFbmQgPyAxIDogcjtcbiAgfTtcbn0sXG4gICAgX2NyZWF0ZUV4cG9TY2FsZSA9IGZ1bmN0aW9uIF9jcmVhdGVFeHBvU2NhbGUoc3RhcnQsIGVuZCwgZWFzZSkge1xuICB2YXIgcDEgPSBNYXRoLmxvZyhlbmQgLyBzdGFydCksXG4gICAgICBwMiA9IGVuZCAtIHN0YXJ0O1xuICBlYXNlICYmIChlYXNlID0gZ3NhcC5wYXJzZUVhc2UoZWFzZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gKHN0YXJ0ICogTWF0aC5leHAocDEgKiAoZWFzZSA/IGVhc2UocCkgOiBwKSkgLSBzdGFydCkgLyBwMjtcbiAgfTtcbn0sXG4gICAgRWFzZVBvaW50ID0gZnVuY3Rpb24gRWFzZVBvaW50KHRpbWUsIHZhbHVlLCBuZXh0KSB7XG4gIHRoaXMudCA9IHRpbWU7XG4gIHRoaXMudiA9IHZhbHVlO1xuXG4gIGlmIChuZXh0KSB7XG4gICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICBuZXh0LnByZXYgPSB0aGlzO1xuICAgIHRoaXMuYyA9IG5leHQudiAtIHZhbHVlO1xuICAgIHRoaXMuZ2FwID0gbmV4dC50IC0gdGltZTtcbiAgfVxufSxcbiAgICBfY3JlYXRlUm91Z2hFYXNlID0gZnVuY3Rpb24gX2NyZWF0ZVJvdWdoRWFzZSh2YXJzKSB7XG4gIGlmICh0eXBlb2YgdmFycyAhPT0gXCJvYmplY3RcIikge1xuICAgIC8vdXNlcnMgbWF5IHBhc3MgaW4gdmlhIGEgc3RyaW5nLCBsaWtlIFwicm91Z2goMzApXCJcbiAgICB2YXJzID0ge1xuICAgICAgcG9pbnRzOiArdmFycyB8fCAyMFxuICAgIH07XG4gIH1cblxuICB2YXIgdGFwZXIgPSB2YXJzLnRhcGVyIHx8IFwibm9uZVwiLFxuICAgICAgYSA9IFtdLFxuICAgICAgY250ID0gMCxcbiAgICAgIHBvaW50cyA9ICgrdmFycy5wb2ludHMgfHwgMjApIHwgMCxcbiAgICAgIGkgPSBwb2ludHMsXG4gICAgICByYW5kb21pemUgPSBfYm9vbGVhbih2YXJzLnJhbmRvbWl6ZSwgdHJ1ZSksXG4gICAgICBjbGFtcCA9IF9ib29sZWFuKHZhcnMuY2xhbXApLFxuICAgICAgdGVtcGxhdGUgPSBnc2FwID8gZ3NhcC5wYXJzZUVhc2UodmFycy50ZW1wbGF0ZSkgOiAwLFxuICAgICAgc3RyZW5ndGggPSAoK3ZhcnMuc3RyZW5ndGggfHwgMSkgKiAwLjQsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGJ1bXAsXG4gICAgICBpbnZYLFxuICAgICAgb2JqLFxuICAgICAgcG50LFxuICAgICAgcmVjZW50O1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIHggPSByYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpIDogMSAvIHBvaW50cyAqIGk7XG4gICAgeSA9IHRlbXBsYXRlID8gdGVtcGxhdGUoeCkgOiB4O1xuXG4gICAgaWYgKHRhcGVyID09PSBcIm5vbmVcIikge1xuICAgICAgYnVtcCA9IHN0cmVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodGFwZXIgPT09IFwib3V0XCIpIHtcbiAgICAgIGludlggPSAxIC0geDtcbiAgICAgIGJ1bXAgPSBpbnZYICogaW52WCAqIHN0cmVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodGFwZXIgPT09IFwiaW5cIikge1xuICAgICAgYnVtcCA9IHggKiB4ICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh4IDwgMC41KSB7XG4gICAgICAvL1wiYm90aFwiIChzdGFydClcbiAgICAgIGludlggPSB4ICogMjtcbiAgICAgIGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL1wiYm90aFwiIChlbmQpXG4gICAgICBpbnZYID0gKDEgLSB4KSAqIDI7XG4gICAgICBidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmFuZG9taXplKSB7XG4gICAgICB5ICs9IE1hdGgucmFuZG9tKCkgKiBidW1wIC0gYnVtcCAqIDAuNTtcbiAgICB9IGVsc2UgaWYgKGkgJSAyKSB7XG4gICAgICB5ICs9IGJ1bXAgKiAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgLT0gYnVtcCAqIDAuNTtcbiAgICB9XG5cbiAgICBpZiAoY2xhbXApIHtcbiAgICAgIGlmICh5ID4gMSkge1xuICAgICAgICB5ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeSA8IDApIHtcbiAgICAgICAgeSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYVtjbnQrK10gPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cblxuICBhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xuICB9KTtcbiAgcG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcbiAgaSA9IHBvaW50cztcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgb2JqID0gYVtpXTtcbiAgICBwbnQgPSBuZXcgRWFzZVBvaW50KG9iai54LCBvYmoueSwgcG50KTtcbiAgfVxuXG4gIHJlY2VudCA9IG5ldyBFYXNlUG9pbnQoMCwgMCwgcG50LnQgPyBwbnQgOiBwbnQubmV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHZhciBwbnQgPSByZWNlbnQ7XG5cbiAgICBpZiAocCA+IHBudC50KSB7XG4gICAgICB3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuICAgICAgICBwbnQgPSBwbnQubmV4dDtcbiAgICAgIH1cblxuICAgICAgcG50ID0gcG50LnByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChwbnQucHJldiAmJiBwIDw9IHBudC50KSB7XG4gICAgICAgIHBudCA9IHBudC5wcmV2O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlY2VudCA9IHBudDtcbiAgICByZXR1cm4gcG50LnYgKyAocCAtIHBudC50KSAvIHBudC5nYXAgKiBwbnQuYztcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgU2xvd01vID0gX2NyZWF0ZVNsb3dNbygwLjcpO1xuU2xvd01vLmVhc2UgPSBTbG93TW87IC8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuU2xvd01vLmNvbmZpZyA9IF9jcmVhdGVTbG93TW87XG5leHBvcnQgdmFyIEV4cG9TY2FsZUVhc2UgPSBfY3JlYXRlRXhwb1NjYWxlKDEsIDIpO1xuRXhwb1NjYWxlRWFzZS5jb25maWcgPSBfY3JlYXRlRXhwb1NjYWxlO1xuZXhwb3J0IHZhciBSb3VnaEVhc2UgPSBfY3JlYXRlUm91Z2hFYXNlKCk7XG5Sb3VnaEVhc2UuZWFzZSA9IFJvdWdoRWFzZTsgLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5Sb3VnaEVhc2UuY29uZmlnID0gX2NyZWF0ZVJvdWdoRWFzZTtcbmV4cG9ydCB2YXIgRWFzZVBhY2sgPSB7XG4gIFNsb3dNbzogU2xvd01vLFxuICBSb3VnaEVhc2U6IFJvdWdoRWFzZSxcbiAgRXhwb1NjYWxlRWFzZTogRXhwb1NjYWxlRWFzZVxufTtcblxuZm9yICh2YXIgcCBpbiBFYXNlUGFjaykge1xuICBFYXNlUGFja1twXS5yZWdpc3RlciA9IF9pbml0Q29yZTtcbiAgRWFzZVBhY2tbcF0udmVyc2lvbiA9IFwiMy4xMS4yXCI7XG59XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTbG93TW8pO1xuZXhwb3J0IHsgRWFzZVBhY2sgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/EasePack.js\n"));

/***/ }),

/***/ "./node_modules/gsap/EaselPlugin.js":
/*!******************************************!*\
  !*** ./node_modules/gsap/EaselPlugin.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EaselPlugin\": function() { return /* binding */ EaselPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ EaselPlugin; }\n/* harmony export */ });\n/*!\n * EaselPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _win,\n    _createJS,\n    _ColorFilter,\n    _ColorMatrixFilter,\n    _colorProps = \"redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset\".split(\",\"),\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _getCreateJS = function _getCreateJS() {\n  return _createJS || _win && _win.createjs || _win || {};\n},\n    _warn = function _warn(message) {\n  return console.warn(message);\n},\n    _cache = function _cache(target) {\n  var b = target.getBounds && target.getBounds();\n\n  if (!b) {\n    b = target.nominalBounds || {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 100\n    };\n    target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);\n  }\n\n  target.cache && target.cache(b.x, b.y, b.width, b.height);\n\n  _warn(\"EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. \" + target);\n},\n    _parseColorFilter = function _parseColorFilter(target, v, plugin) {\n  if (!_ColorFilter) {\n    _ColorFilter = _getCreateJS().ColorFilter;\n\n    if (!_ColorFilter) {\n      _warn(\"EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.\");\n    }\n  }\n\n  var filters = target.filters || [],\n      i = filters.length,\n      c,\n      s,\n      e,\n      a,\n      p,\n      pt;\n\n  while (i--) {\n    if (filters[i] instanceof _ColorFilter) {\n      s = filters[i];\n      break;\n    }\n  }\n\n  if (!s) {\n    s = new _ColorFilter();\n    filters.push(s);\n    target.filters = filters;\n  }\n\n  e = s.clone();\n\n  if (v.tint != null) {\n    c = gsap.utils.splitColor(v.tint);\n    a = v.tintAmount != null ? +v.tintAmount : 1;\n    e.redOffset = +c[0] * a;\n    e.greenOffset = +c[1] * a;\n    e.blueOffset = +c[2] * a;\n    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;\n  } else {\n    for (p in v) {\n      if (p !== \"exposure\") if (p !== \"brightness\") {\n        e[p] = +v[p];\n      }\n    }\n  }\n\n  if (v.exposure != null) {\n    e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);\n    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;\n  } else if (v.brightness != null) {\n    a = +v.brightness - 1;\n    e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;\n    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);\n  }\n\n  i = 8;\n\n  while (i--) {\n    p = _colorProps[i];\n\n    if (s[p] !== e[p]) {\n      pt = plugin.add(s, p, s[p], e[p], 0, 0, 0, 0, 0, 1);\n\n      if (pt) {\n        pt.op = \"easel_colorFilter\";\n      }\n    }\n  }\n\n  plugin._props.push(\"easel_colorFilter\");\n\n  if (!target.cacheID) {\n    _cache(target);\n  }\n},\n    _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n    _lumR = 0.212671,\n    _lumG = 0.715160,\n    _lumB = 0.072169,\n    _applyMatrix = function _applyMatrix(m, m2) {\n  if (!(m instanceof Array) || !(m2 instanceof Array)) {\n    return m2;\n  }\n\n  var temp = [],\n      i = 0,\n      z = 0,\n      y,\n      x;\n\n  for (y = 0; y < 4; y++) {\n    for (x = 0; x < 5; x++) {\n      z = x === 4 ? m[i + 4] : 0;\n      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n    }\n\n    i += 5;\n  }\n\n  return temp;\n},\n    _setSaturation = function _setSaturation(m, n) {\n  if (isNaN(n)) {\n    return m;\n  }\n\n  var inv = 1 - n,\n      r = inv * _lumR,\n      g = inv * _lumG,\n      b = inv * _lumB;\n  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);\n},\n    _colorize = function _colorize(m, color, amount) {\n  if (isNaN(amount)) {\n    amount = 1;\n  }\n\n  var c = gsap.utils.splitColor(color),\n      r = c[0] / 255,\n      g = c[1] / 255,\n      b = c[2] / 255,\n      inv = 1 - amount;\n  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);\n},\n    _setHue = function _setHue(m, n) {\n  if (isNaN(n)) {\n    return m;\n  }\n\n  n *= Math.PI / 180;\n  var c = Math.cos(n),\n      s = Math.sin(n);\n  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);\n},\n    _setContrast = function _setContrast(m, n) {\n  if (isNaN(n)) {\n    return m;\n  }\n\n  n += 0.01;\n  return _applyMatrix([n, 0, 0, 0, 128 * (1 - n), 0, n, 0, 0, 128 * (1 - n), 0, 0, n, 0, 128 * (1 - n), 0, 0, 0, 1, 0], m);\n},\n    _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, plugin) {\n  if (!_ColorMatrixFilter) {\n    _ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;\n\n    if (!_ColorMatrixFilter) {\n      _warn(\"EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.\");\n    }\n  }\n\n  var filters = target.filters || [],\n      i = filters.length,\n      matrix,\n      startMatrix,\n      s,\n      pg;\n\n  while (--i > -1) {\n    if (filters[i] instanceof _ColorMatrixFilter) {\n      s = filters[i];\n      break;\n    }\n  }\n\n  if (!s) {\n    s = new _ColorMatrixFilter(_idMatrix.slice());\n    filters.push(s);\n    target.filters = filters;\n  }\n\n  startMatrix = s.matrix;\n  matrix = _idMatrix.slice();\n\n  if (v.colorize != null) {\n    matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));\n  }\n\n  if (v.contrast != null) {\n    matrix = _setContrast(matrix, Number(v.contrast));\n  }\n\n  if (v.hue != null) {\n    matrix = _setHue(matrix, Number(v.hue));\n  }\n\n  if (v.saturation != null) {\n    matrix = _setSaturation(matrix, Number(v.saturation));\n  }\n\n  i = matrix.length;\n\n  while (--i > -1) {\n    if (matrix[i] !== startMatrix[i]) {\n      pg = plugin.add(startMatrix, i, startMatrix[i], matrix[i], 0, 0, 0, 0, 0, 1);\n\n      if (pg) {\n        pg.op = \"easel_colorMatrixFilter\";\n      }\n    }\n  }\n\n  plugin._props.push(\"easel_colorMatrixFilter\");\n\n  if (!target.cacheID) {\n    _cache();\n  }\n\n  plugin._matrix = startMatrix;\n},\n    _initCore = function _initCore(core) {\n  gsap = core || _getGSAP();\n\n  if (_windowExists()) {\n    _win = window;\n  }\n\n  if (gsap) {\n    _coreInitted = 1;\n  }\n};\n\nvar EaselPlugin = {\n  version: \"3.11.2\",\n  name: \"easel\",\n  init: function init(target, value, tween, index, targets) {\n    if (!_coreInitted) {\n      _initCore();\n\n      if (!gsap) {\n        _warn(\"Please gsap.registerPlugin(EaselPlugin)\");\n      }\n    }\n\n    this.target = target;\n    var p, pt, tint, colorMatrix, end, labels, i;\n\n    for (p in value) {\n      end = value[p];\n\n      if (p === \"colorFilter\" || p === \"tint\" || p === \"tintAmount\" || p === \"exposure\" || p === \"brightness\") {\n        if (!tint) {\n          _parseColorFilter(target, value.colorFilter || value, this);\n\n          tint = true;\n        }\n      } else if (p === \"saturation\" || p === \"contrast\" || p === \"hue\" || p === \"colorize\" || p === \"colorizeAmount\") {\n        if (!colorMatrix) {\n          _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);\n\n          colorMatrix = true;\n        }\n      } else if (p === \"frame\") {\n        if (typeof end === \"string\" && end.charAt(1) !== \"=\" && (labels = target.labels)) {\n          for (i = 0; i < labels.length; i++) {\n            if (labels[i].label === end) {\n              end = labels[i].position;\n            }\n          }\n        }\n\n        pt = this.add(target, \"gotoAndStop\", target.currentFrame, end, index, targets, Math.round, 0, 0, 1);\n\n        if (pt) {\n          pt.op = p;\n        }\n      } else if (target[p] != null) {\n        this.add(target, p, \"get\", end);\n      }\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    if (data.target.cacheID) {\n      data.target.updateCache();\n    }\n  },\n  register: _initCore\n};\n\nEaselPlugin.registerCreateJS = function (createjs) {\n  _createJS = createjs;\n};\n\n_getGSAP() && gsap.registerPlugin(EaselPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlbFBsdWdpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlbFBsdWdpbi5qcz8wYmI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRWFzZWxQbHVnaW4gMy4xMS4yXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2NyZWF0ZUpTLFxuICAgIF9Db2xvckZpbHRlcixcbiAgICBfQ29sb3JNYXRyaXhGaWx0ZXIsXG4gICAgX2NvbG9yUHJvcHMgPSBcInJlZE11bHRpcGxpZXIsZ3JlZW5NdWx0aXBsaWVyLGJsdWVNdWx0aXBsaWVyLGFscGhhTXVsdGlwbGllcixyZWRPZmZzZXQsZ3JlZW5PZmZzZXQsYmx1ZU9mZnNldCxhbHBoYU9mZnNldFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9nZXRDcmVhdGVKUyA9IGZ1bmN0aW9uIF9nZXRDcmVhdGVKUygpIHtcbiAgcmV0dXJuIF9jcmVhdGVKUyB8fCBfd2luICYmIF93aW4uY3JlYXRlanMgfHwgX3dpbiB8fCB7fTtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59LFxuICAgIF9jYWNoZSA9IGZ1bmN0aW9uIF9jYWNoZSh0YXJnZXQpIHtcbiAgdmFyIGIgPSB0YXJnZXQuZ2V0Qm91bmRzICYmIHRhcmdldC5nZXRCb3VuZHMoKTtcblxuICBpZiAoIWIpIHtcbiAgICBiID0gdGFyZ2V0Lm5vbWluYWxCb3VuZHMgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiAxMDBcbiAgICB9O1xuICAgIHRhcmdldC5zZXRCb3VuZHMgJiYgdGFyZ2V0LnNldEJvdW5kcyhiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICB9XG5cbiAgdGFyZ2V0LmNhY2hlICYmIHRhcmdldC5jYWNoZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuXG4gIF93YXJuKFwiRWFzZWxQbHVnaW46IGZvciBmaWx0ZXJzIHRvIGRpc3BsYXkgaW4gRWFzZWxKUywgeW91IG11c3QgY2FsbCB0aGUgb2JqZWN0J3MgY2FjaGUoKSBtZXRob2QgZmlyc3QuIEdTQVAgYXR0ZW1wdGVkIHRvIHVzZSB0aGUgdGFyZ2V0J3MgZ2V0Qm91bmRzKCkgZm9yIHRoZSBjYWNoZSBidXQgdGhhdCBtYXkgbm90IGJlIGNvbXBsZXRlbHkgYWNjdXJhdGUuIFwiICsgdGFyZ2V0KTtcbn0sXG4gICAgX3BhcnNlQ29sb3JGaWx0ZXIgPSBmdW5jdGlvbiBfcGFyc2VDb2xvckZpbHRlcih0YXJnZXQsIHYsIHBsdWdpbikge1xuICBpZiAoIV9Db2xvckZpbHRlcikge1xuICAgIF9Db2xvckZpbHRlciA9IF9nZXRDcmVhdGVKUygpLkNvbG9yRmlsdGVyO1xuXG4gICAgaWYgKCFfQ29sb3JGaWx0ZXIpIHtcbiAgICAgIF93YXJuKFwiRWFzZWxQbHVnaW4gZXJyb3I6IFRoZSBFYXNlbEpTIENvbG9yRmlsdGVyIEphdmFTY3JpcHQgZmlsZSB3YXNuJ3QgbG9hZGVkLlwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmlsdGVycyA9IHRhcmdldC5maWx0ZXJzIHx8IFtdLFxuICAgICAgaSA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgYyxcbiAgICAgIHMsXG4gICAgICBlLFxuICAgICAgYSxcbiAgICAgIHAsXG4gICAgICBwdDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGZpbHRlcnNbaV0gaW5zdGFuY2VvZiBfQ29sb3JGaWx0ZXIpIHtcbiAgICAgIHMgPSBmaWx0ZXJzW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzKSB7XG4gICAgcyA9IG5ldyBfQ29sb3JGaWx0ZXIoKTtcbiAgICBmaWx0ZXJzLnB1c2gocyk7XG4gICAgdGFyZ2V0LmZpbHRlcnMgPSBmaWx0ZXJzO1xuICB9XG5cbiAgZSA9IHMuY2xvbmUoKTtcblxuICBpZiAodi50aW50ICE9IG51bGwpIHtcbiAgICBjID0gZ3NhcC51dGlscy5zcGxpdENvbG9yKHYudGludCk7XG4gICAgYSA9IHYudGludEFtb3VudCAhPSBudWxsID8gK3YudGludEFtb3VudCA6IDE7XG4gICAgZS5yZWRPZmZzZXQgPSArY1swXSAqIGE7XG4gICAgZS5ncmVlbk9mZnNldCA9ICtjWzFdICogYTtcbiAgICBlLmJsdWVPZmZzZXQgPSArY1syXSAqIGE7XG4gICAgZS5yZWRNdWx0aXBsaWVyID0gZS5ncmVlbk11bHRpcGxpZXIgPSBlLmJsdWVNdWx0aXBsaWVyID0gMSAtIGE7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChwIGluIHYpIHtcbiAgICAgIGlmIChwICE9PSBcImV4cG9zdXJlXCIpIGlmIChwICE9PSBcImJyaWdodG5lc3NcIikge1xuICAgICAgICBlW3BdID0gK3ZbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHYuZXhwb3N1cmUgIT0gbnVsbCkge1xuICAgIGUucmVkT2Zmc2V0ID0gZS5ncmVlbk9mZnNldCA9IGUuYmx1ZU9mZnNldCA9IDI1NSAqICgrdi5leHBvc3VyZSAtIDEpO1xuICAgIGUucmVkTXVsdGlwbGllciA9IGUuZ3JlZW5NdWx0aXBsaWVyID0gZS5ibHVlTXVsdGlwbGllciA9IDE7XG4gIH0gZWxzZSBpZiAodi5icmlnaHRuZXNzICE9IG51bGwpIHtcbiAgICBhID0gK3YuYnJpZ2h0bmVzcyAtIDE7XG4gICAgZS5yZWRPZmZzZXQgPSBlLmdyZWVuT2Zmc2V0ID0gZS5ibHVlT2Zmc2V0ID0gYSA+IDAgPyBhICogMjU1IDogMDtcbiAgICBlLnJlZE11bHRpcGxpZXIgPSBlLmdyZWVuTXVsdGlwbGllciA9IGUuYmx1ZU11bHRpcGxpZXIgPSAxIC0gTWF0aC5hYnMoYSk7XG4gIH1cblxuICBpID0gODtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcCA9IF9jb2xvclByb3BzW2ldO1xuXG4gICAgaWYgKHNbcF0gIT09IGVbcF0pIHtcbiAgICAgIHB0ID0gcGx1Z2luLmFkZChzLCBwLCBzW3BdLCBlW3BdLCAwLCAwLCAwLCAwLCAwLCAxKTtcblxuICAgICAgaWYgKHB0KSB7XG4gICAgICAgIHB0Lm9wID0gXCJlYXNlbF9jb2xvckZpbHRlclwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChcImVhc2VsX2NvbG9yRmlsdGVyXCIpO1xuXG4gIGlmICghdGFyZ2V0LmNhY2hlSUQpIHtcbiAgICBfY2FjaGUodGFyZ2V0KTtcbiAgfVxufSxcbiAgICBfaWRNYXRyaXggPSBbMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sXG4gICAgX2x1bVIgPSAwLjIxMjY3MSxcbiAgICBfbHVtRyA9IDAuNzE1MTYwLFxuICAgIF9sdW1CID0gMC4wNzIxNjksXG4gICAgX2FwcGx5TWF0cml4ID0gZnVuY3Rpb24gX2FwcGx5TWF0cml4KG0sIG0yKSB7XG4gIGlmICghKG0gaW5zdGFuY2VvZiBBcnJheSkgfHwgIShtMiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHJldHVybiBtMjtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW10sXG4gICAgICBpID0gMCxcbiAgICAgIHogPSAwLFxuICAgICAgeSxcbiAgICAgIHg7XG5cbiAgZm9yICh5ID0gMDsgeSA8IDQ7IHkrKykge1xuICAgIGZvciAoeCA9IDA7IHggPCA1OyB4KyspIHtcbiAgICAgIHogPSB4ID09PSA0ID8gbVtpICsgNF0gOiAwO1xuICAgICAgdGVtcFtpICsgeF0gPSBtW2ldICogbTJbeF0gKyBtW2kgKyAxXSAqIG0yW3ggKyA1XSArIG1baSArIDJdICogbTJbeCArIDEwXSArIG1baSArIDNdICogbTJbeCArIDE1XSArIHo7XG4gICAgfVxuXG4gICAgaSArPSA1O1xuICB9XG5cbiAgcmV0dXJuIHRlbXA7XG59LFxuICAgIF9zZXRTYXR1cmF0aW9uID0gZnVuY3Rpb24gX3NldFNhdHVyYXRpb24obSwgbikge1xuICBpZiAoaXNOYU4obikpIHtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIHZhciBpbnYgPSAxIC0gbixcbiAgICAgIHIgPSBpbnYgKiBfbHVtUixcbiAgICAgIGcgPSBpbnYgKiBfbHVtRyxcbiAgICAgIGIgPSBpbnYgKiBfbHVtQjtcbiAgcmV0dXJuIF9hcHBseU1hdHJpeChbciArIG4sIGcsIGIsIDAsIDAsIHIsIGcgKyBuLCBiLCAwLCAwLCByLCBnLCBiICsgbiwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sIG0pO1xufSxcbiAgICBfY29sb3JpemUgPSBmdW5jdGlvbiBfY29sb3JpemUobSwgY29sb3IsIGFtb3VudCkge1xuICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgIGFtb3VudCA9IDE7XG4gIH1cblxuICB2YXIgYyA9IGdzYXAudXRpbHMuc3BsaXRDb2xvcihjb2xvciksXG4gICAgICByID0gY1swXSAvIDI1NSxcbiAgICAgIGcgPSBjWzFdIC8gMjU1LFxuICAgICAgYiA9IGNbMl0gLyAyNTUsXG4gICAgICBpbnYgPSAxIC0gYW1vdW50O1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9zZXRIdWUgPSBmdW5jdGlvbiBfc2V0SHVlKG0sIG4pIHtcbiAgaWYgKGlzTmFOKG4pKSB7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBuICo9IE1hdGguUEkgLyAxODA7XG4gIHZhciBjID0gTWF0aC5jb3MobiksXG4gICAgICBzID0gTWF0aC5zaW4obik7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW19sdW1SICsgYyAqICgxIC0gX2x1bVIpICsgcyAqIC1fbHVtUiwgX2x1bUcgKyBjICogLV9sdW1HICsgcyAqIC1fbHVtRywgX2x1bUIgKyBjICogLV9sdW1CICsgcyAqICgxIC0gX2x1bUIpLCAwLCAwLCBfbHVtUiArIGMgKiAtX2x1bVIgKyBzICogMC4xNDMsIF9sdW1HICsgYyAqICgxIC0gX2x1bUcpICsgcyAqIDAuMTQsIF9sdW1CICsgYyAqIC1fbHVtQiArIHMgKiAtMC4yODMsIDAsIDAsIF9sdW1SICsgYyAqIC1fbHVtUiArIHMgKiAtKDEgLSBfbHVtUiksIF9sdW1HICsgYyAqIC1fbHVtRyArIHMgKiBfbHVtRywgX2x1bUIgKyBjICogKDEgLSBfbHVtQikgKyBzICogX2x1bUIsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdLCBtKTtcbn0sXG4gICAgX3NldENvbnRyYXN0ID0gZnVuY3Rpb24gX3NldENvbnRyYXN0KG0sIG4pIHtcbiAgaWYgKGlzTmFOKG4pKSB7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBuICs9IDAuMDE7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW24sIDAsIDAsIDAsIDEyOCAqICgxIC0gbiksIDAsIG4sIDAsIDAsIDEyOCAqICgxIC0gbiksIDAsIDAsIG4sIDAsIDEyOCAqICgxIC0gbiksIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIgPSBmdW5jdGlvbiBfcGFyc2VDb2xvck1hdHJpeEZpbHRlcih0YXJnZXQsIHYsIHBsdWdpbikge1xuICBpZiAoIV9Db2xvck1hdHJpeEZpbHRlcikge1xuICAgIF9Db2xvck1hdHJpeEZpbHRlciA9IF9nZXRDcmVhdGVKUygpLkNvbG9yTWF0cml4RmlsdGVyO1xuXG4gICAgaWYgKCFfQ29sb3JNYXRyaXhGaWx0ZXIpIHtcbiAgICAgIF93YXJuKFwiRWFzZWxQbHVnaW46IFRoZSBFYXNlbEpTIENvbG9yTWF0cml4RmlsdGVyIEphdmFTY3JpcHQgZmlsZSB3YXNuJ3QgbG9hZGVkLlwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmlsdGVycyA9IHRhcmdldC5maWx0ZXJzIHx8IFtdLFxuICAgICAgaSA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgbWF0cml4LFxuICAgICAgc3RhcnRNYXRyaXgsXG4gICAgICBzLFxuICAgICAgcGc7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKGZpbHRlcnNbaV0gaW5zdGFuY2VvZiBfQ29sb3JNYXRyaXhGaWx0ZXIpIHtcbiAgICAgIHMgPSBmaWx0ZXJzW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzKSB7XG4gICAgcyA9IG5ldyBfQ29sb3JNYXRyaXhGaWx0ZXIoX2lkTWF0cml4LnNsaWNlKCkpO1xuICAgIGZpbHRlcnMucHVzaChzKTtcbiAgICB0YXJnZXQuZmlsdGVycyA9IGZpbHRlcnM7XG4gIH1cblxuICBzdGFydE1hdHJpeCA9IHMubWF0cml4O1xuICBtYXRyaXggPSBfaWRNYXRyaXguc2xpY2UoKTtcblxuICBpZiAodi5jb2xvcml6ZSAhPSBudWxsKSB7XG4gICAgbWF0cml4ID0gX2NvbG9yaXplKG1hdHJpeCwgdi5jb2xvcml6ZSwgTnVtYmVyKHYuY29sb3JpemVBbW91bnQpKTtcbiAgfVxuXG4gIGlmICh2LmNvbnRyYXN0ICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfc2V0Q29udHJhc3QobWF0cml4LCBOdW1iZXIodi5jb250cmFzdCkpO1xuICB9XG5cbiAgaWYgKHYuaHVlICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfc2V0SHVlKG1hdHJpeCwgTnVtYmVyKHYuaHVlKSk7XG4gIH1cblxuICBpZiAodi5zYXR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfc2V0U2F0dXJhdGlvbihtYXRyaXgsIE51bWJlcih2LnNhdHVyYXRpb24pKTtcbiAgfVxuXG4gIGkgPSBtYXRyaXgubGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGlmIChtYXRyaXhbaV0gIT09IHN0YXJ0TWF0cml4W2ldKSB7XG4gICAgICBwZyA9IHBsdWdpbi5hZGQoc3RhcnRNYXRyaXgsIGksIHN0YXJ0TWF0cml4W2ldLCBtYXRyaXhbaV0sIDAsIDAsIDAsIDAsIDAsIDEpO1xuXG4gICAgICBpZiAocGcpIHtcbiAgICAgICAgcGcub3AgPSBcImVhc2VsX2NvbG9yTWF0cml4RmlsdGVyXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKFwiZWFzZWxfY29sb3JNYXRyaXhGaWx0ZXJcIik7XG5cbiAgaWYgKCF0YXJnZXQuY2FjaGVJRCkge1xuICAgIF9jYWNoZSgpO1xuICB9XG5cbiAgcGx1Z2luLl9tYXRyaXggPSBzdGFydE1hdHJpeDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgfVxuXG4gIGlmIChnc2FwKSB7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBFYXNlbFBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjExLjJcIixcbiAgbmFtZTogXCJlYXNlbFwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIGlmICghX2NvcmVJbml0dGVkKSB7XG4gICAgICBfaW5pdENvcmUoKTtcblxuICAgICAgaWYgKCFnc2FwKSB7XG4gICAgICAgIF93YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oRWFzZWxQbHVnaW4pXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHZhciBwLCBwdCwgdGludCwgY29sb3JNYXRyaXgsIGVuZCwgbGFiZWxzLCBpO1xuXG4gICAgZm9yIChwIGluIHZhbHVlKSB7XG4gICAgICBlbmQgPSB2YWx1ZVtwXTtcblxuICAgICAgaWYgKHAgPT09IFwiY29sb3JGaWx0ZXJcIiB8fCBwID09PSBcInRpbnRcIiB8fCBwID09PSBcInRpbnRBbW91bnRcIiB8fCBwID09PSBcImV4cG9zdXJlXCIgfHwgcCA9PT0gXCJicmlnaHRuZXNzXCIpIHtcbiAgICAgICAgaWYgKCF0aW50KSB7XG4gICAgICAgICAgX3BhcnNlQ29sb3JGaWx0ZXIodGFyZ2V0LCB2YWx1ZS5jb2xvckZpbHRlciB8fCB2YWx1ZSwgdGhpcyk7XG5cbiAgICAgICAgICB0aW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwID09PSBcInNhdHVyYXRpb25cIiB8fCBwID09PSBcImNvbnRyYXN0XCIgfHwgcCA9PT0gXCJodWVcIiB8fCBwID09PSBcImNvbG9yaXplXCIgfHwgcCA9PT0gXCJjb2xvcml6ZUFtb3VudFwiKSB7XG4gICAgICAgIGlmICghY29sb3JNYXRyaXgpIHtcbiAgICAgICAgICBfcGFyc2VDb2xvck1hdHJpeEZpbHRlcih0YXJnZXQsIHZhbHVlLmNvbG9yTWF0cml4RmlsdGVyIHx8IHZhbHVlLCB0aGlzKTtcblxuICAgICAgICAgIGNvbG9yTWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwID09PSBcImZyYW1lXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09IFwic3RyaW5nXCIgJiYgZW5kLmNoYXJBdCgxKSAhPT0gXCI9XCIgJiYgKGxhYmVscyA9IHRhcmdldC5sYWJlbHMpKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxhYmVsc1tpXS5sYWJlbCA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgIGVuZCA9IGxhYmVsc1tpXS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJnb3RvQW5kU3RvcFwiLCB0YXJnZXQuY3VycmVudEZyYW1lLCBlbmQsIGluZGV4LCB0YXJnZXRzLCBNYXRoLnJvdW5kLCAwLCAwLCAxKTtcblxuICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICBwdC5vcCA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0W3BdICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBwLCBcImdldFwiLCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIGlmIChkYXRhLnRhcmdldC5jYWNoZUlEKSB7XG4gICAgICBkYXRhLnRhcmdldC51cGRhdGVDYWNoZSgpO1xuICAgIH1cbiAgfSxcbiAgcmVnaXN0ZXI6IF9pbml0Q29yZVxufTtcblxuRWFzZWxQbHVnaW4ucmVnaXN0ZXJDcmVhdGVKUyA9IGZ1bmN0aW9uIChjcmVhdGVqcykge1xuICBfY3JlYXRlSlMgPSBjcmVhdGVqcztcbn07XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihFYXNlbFBsdWdpbik7XG5leHBvcnQgeyBFYXNlbFBsdWdpbiBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/EaselPlugin.js\n"));

/***/ }),

/***/ "./node_modules/gsap/Flip.js":
/*!***********************************!*\
  !*** ./node_modules/gsap/Flip.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Flip\": function() { return /* binding */ Flip; },\n/* harmony export */   \"default\": function() { return /* binding */ Flip; }\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"./node_modules/gsap/utils/matrix.js\");\n/*!\n * Flip 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar _id = 1,\n    _toArray,\n    gsap,\n    _batch,\n    _batchAction,\n    _body,\n    _closestTenth,\n    _forEachBatch = function _forEachBatch(batch, name) {\n  return batch.actions.forEach(function (a) {\n    return a.vars[name] && a.vars[name](a);\n  });\n},\n    _batchLookup = {},\n    _RAD2DEG = 180 / Math.PI,\n    _DEG2RAD = Math.PI / 180,\n    _emptyObj = {},\n    _dashedNameLookup = {},\n    _memoizedRemoveProps = {},\n    _listToArray = function _listToArray(list) {\n  return typeof list === \"string\" ? list.split(\" \").join(\"\").split(\",\") : list;\n},\n    // removes extra spaces contaminating the names, returns an Array.\n_callbacks = _listToArray(\"onStart,onUpdate,onComplete,onReverseComplete,onInterrupt\"),\n    _removeProps = _listToArray(\"transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight\"),\n    _getEl = function _getEl(target) {\n  return _toArray(target)[0] || console.warn(\"Element not found:\", target);\n},\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000 || 0;\n},\n    _toggleClass = function _toggleClass(targets, className, action) {\n  return targets.forEach(function (el) {\n    return el.classList[action](className);\n  });\n},\n    _reserved = {\n  zIndex: 1,\n  kill: 1,\n  simple: 1,\n  spin: 1,\n  clearProps: 1,\n  targets: 1,\n  toggleClass: 1,\n  onComplete: 1,\n  onUpdate: 1,\n  onInterrupt: 1,\n  onStart: 1,\n  delay: 1,\n  repeat: 1,\n  repeatDelay: 1,\n  yoyo: 1,\n  scale: 1,\n  fade: 1,\n  absolute: 1,\n  props: 1,\n  onEnter: 1,\n  onLeave: 1,\n  custom: 1,\n  paused: 1,\n  nested: 1,\n  prune: 1,\n  absoluteOnLeave: 1\n},\n    _fitReserved = {\n  zIndex: 1,\n  simple: 1,\n  clearProps: 1,\n  scale: 1,\n  absolute: 1,\n  fitChild: 1,\n  getVars: 1,\n  props: 1\n},\n    _camelToDashed = function _camelToDashed(p) {\n  return p.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n},\n    _copy = function _copy(obj, exclude) {\n  var result = {},\n      p;\n\n  for (p in obj) {\n    exclude[p] || (result[p] = obj[p]);\n  }\n\n  return result;\n},\n    _memoizedProps = {},\n    _memoizeProps = function _memoizeProps(props) {\n  var p = _memoizedProps[props] = _listToArray(props);\n\n  _memoizedRemoveProps[props] = p.concat(_removeProps);\n  return p;\n},\n    _getInverseGlobalMatrix = function _getInverseGlobalMatrix(el) {\n  // integrates caching for improved performance\n  var cache = el._gsap || gsap.core.getCache(el);\n\n  if (cache.gmCache === gsap.ticker.frame) {\n    return cache.gMatrix;\n  }\n\n  cache.gmCache = gsap.ticker.frame;\n  return cache.gMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, true, false, true);\n},\n    _getDOMDepth = function _getDOMDepth(el, invert, level) {\n  if (level === void 0) {\n    level = 0;\n  }\n\n  // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.\n  var parent = el.parentNode,\n      inc = 1000 * Math.pow(10, level) * (invert ? -1 : 1),\n      l = invert ? -inc * 900 : 0;\n\n  while (el) {\n    l += inc;\n    el = el.previousSibling;\n  }\n\n  return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n},\n    _orderByDOMDepth = function _orderByDOMDepth(comps, invert, isElStates) {\n  comps.forEach(function (comp) {\n    return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);\n  });\n  comps.sort(function (c1, c2) {\n    return c1.d - c2.d;\n  });\n  return comps;\n},\n    _recordInlineStyles = function _recordInlineStyles(elState, props) {\n  // records the current inline CSS properties into an Array in alternating name/value pairs that's stored in a \"css\" property on the state object so that we can revert later.\n  var style = elState.element.style,\n      a = elState.css = elState.css || [],\n      i = props.length,\n      p,\n      v;\n\n  while (i--) {\n    p = props[i];\n    v = style[p] || style.getPropertyValue(p);\n    a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n  }\n\n  return style;\n},\n    _applyInlineStyles = function _applyInlineStyles(state) {\n  var css = state.css,\n      style = state.element.style,\n      i = 0;\n  state.cache.uncache = 1;\n\n  for (; i < css.length; i += 2) {\n    css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);\n  }\n},\n    _setFinalStates = function _setFinalStates(comps, onlyTransforms) {\n  comps.forEach(function (c) {\n    return c.a.cache.uncache = 1;\n  });\n  onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n},\n    _absoluteProps = \"paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition\".split(\",\"),\n    // properties that we must record just\n_makeAbsolute = function _makeAbsolute(elState, fallbackNode, ignoreBatch) {\n  var element = elState.element,\n      width = elState.width,\n      height = elState.height,\n      uncache = elState.uncache,\n      getProp = elState.getProp,\n      style = element.style,\n      i = 4,\n      result,\n      displayIsNone,\n      cs;\n  typeof fallbackNode !== \"object\" && (fallbackNode = elState);\n\n  if (_batch && ignoreBatch !== 1) {\n    _batch._abs.push({\n      t: element,\n      b: elState,\n      a: elState,\n      sd: 0\n    });\n\n    _batch._final.push(function () {\n      return (elState.cache.uncache = 1) && _applyInlineStyles(elState);\n    });\n\n    return element;\n  }\n\n  displayIsNone = getProp(\"display\") === \"none\";\n\n  if (!elState.isVisible || displayIsNone) {\n    displayIsNone && (_recordInlineStyles(elState, [\"display\"]).display = fallbackNode.display);\n    elState.matrix = fallbackNode.matrix;\n    elState.width = width = elState.width || fallbackNode.width;\n    elState.height = height = elState.height || fallbackNode.height;\n  }\n\n  _recordInlineStyles(elState, _absoluteProps);\n\n  cs = window.getComputedStyle(element);\n\n  while (i--) {\n    style[_absoluteProps[i]] = cs[_absoluteProps[i]]; // record paddings as px-based because if removed from grid, percentage-based ones could be altered.\n  }\n\n  style.gridArea = \"1 / 1 / 1 / 1\";\n  style.transition = \"none\";\n  style.position = \"absolute\";\n  style.width = width + \"px\";\n  style.height = height + \"px\";\n  style.top || (style.top = \"0px\");\n  style.left || (style.left = \"0px\");\n\n  if (uncache) {\n    result = new ElementState(element);\n  } else {\n    // better performance\n    result = _copy(elState, _emptyObj);\n    result.position = \"absolute\";\n\n    if (elState.simple) {\n      var bounds = element.getBoundingClientRect();\n      result.matrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)());\n    } else {\n      result.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n    }\n  }\n\n  result = _fit(result, elState, true);\n  elState.x = _closestTenth(result.x, 0.01);\n  elState.y = _closestTenth(result.y, 0.01);\n  return element;\n},\n    _filterComps = function _filterComps(comps, targets) {\n  if (targets !== true) {\n    targets = _toArray(targets);\n    comps = comps.filter(function (c) {\n      if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {\n        return true;\n      } else {\n        c.t._gsap.renderTransform(1); // we must force transforms to render on anything that isn't being made position: absolute, otherwise the absolute position happens and then when animation begins it applies transforms which can create a new stacking context, throwing off positioning!\n\n\n        if (c.b.isVisible) {\n          c.t.style.width = c.b.width + \"px\"; // otherwise things can collapse when contents are made position: absolute.\n\n          c.t.style.height = c.b.height + \"px\";\n        }\n      }\n    });\n  }\n\n  return comps;\n},\n    _makeCompsAbsolute = function _makeCompsAbsolute(comps) {\n  return _orderByDOMDepth(comps, true).forEach(function (c) {\n    return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);\n  });\n},\n    _findElStateInState = function _findElStateInState(state, other) {\n  return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];\n},\n    _parseElementState = function _parseElementState(elOrNode, props, simple, other) {\n  return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === \"string\" ? _getEl(elOrNode) || console.warn(elOrNode + \" not found\") : elOrNode, props, simple);\n},\n    _recordProps = function _recordProps(elState, props) {\n  var getProp = gsap.getProperty(elState.element, null, \"native\"),\n      obj = elState.props = {},\n      i = props.length;\n\n  while (i--) {\n    obj[props[i]] = (getProp(props[i]) + \"\").trim();\n  }\n\n  obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n  return elState;\n},\n    _applyProps = function _applyProps(element, props) {\n  var style = element.style || element,\n      // could pass in a vars object.\n  p;\n\n  for (p in props) {\n    style[p] = props[p];\n  }\n},\n    _getID = function _getID(el) {\n  var id = el.getAttribute(\"data-flip-id\");\n  id || el.setAttribute(\"data-flip-id\", id = \"auto-\" + _id++);\n  return id;\n},\n    _elementsFromElementStates = function _elementsFromElementStates(elStates) {\n  return elStates.map(function (elState) {\n    return elState.element;\n  });\n},\n    _handleCallback = function _handleCallback(callback, elStates, tl) {\n  return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);\n},\n    _fit = function _fit(fromState, toState, scale, applyProps, fitChild, vars) {\n  var element = fromState.element,\n      cache = fromState.cache,\n      parent = fromState.parent,\n      x = fromState.x,\n      y = fromState.y,\n      width = toState.width,\n      height = toState.height,\n      scaleX = toState.scaleX,\n      scaleY = toState.scaleY,\n      rotation = toState.rotation,\n      bounds = toState.bounds,\n      cssText = vars && element.style.cssText,\n      transform = vars && element.getBBox && element.getAttribute(\"transform\"),\n      dimensionState = fromState,\n      _toState$matrix = toState.matrix,\n      e = _toState$matrix.e,\n      f = _toState$matrix.f,\n      deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation,\n      simple = !deep && fromState.simple && toState.simple && !fitChild,\n      skewX,\n      fromPoint,\n      toPoint,\n      getProp,\n      parentMatrix,\n      matrix,\n      bbox;\n\n  if (simple || !parent) {\n    scaleX = scaleY = 1;\n    rotation = skewX = 0;\n  } else {\n    parentMatrix = _getInverseGlobalMatrix(parent);\n    matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:\"0 0 94 94\" with a width of 200px would scale the internals by 2.127 but when we're matching the size of the root <svg> element itself, that scaling shouldn't factor in!)\n\n    rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n    skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.\n\n    scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));\n    scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD);\n\n    if (fitChild) {\n      fitChild = _toArray(fitChild)[0];\n      getProp = gsap.getProperty(fitChild);\n      bbox = fitChild.getBBox && typeof fitChild.getBBox === \"function\" && fitChild.getBBox();\n      dimensionState = {\n        scaleX: getProp(\"scaleX\"),\n        scaleY: getProp(\"scaleY\"),\n        width: bbox ? bbox.width : Math.ceil(parseFloat(getProp(\"width\", \"px\"))),\n        height: bbox ? bbox.height : parseFloat(getProp(\"height\", \"px\"))\n      };\n    }\n\n    cache.rotation = rotation + \"deg\";\n    cache.skewX = skewX + \"deg\";\n  }\n\n  if (scale) {\n    scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width; // note if widths are both 0, we should make scaleX 1 - some elements have box-sizing that incorporates padding, etc. and we don't want it to collapse in that case.\n\n    scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;\n    cache.scaleX = scaleX;\n    cache.scaleY = scaleY;\n  } else {\n    width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);\n    height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);\n    element.style.width = width + \"px\";\n    element.style.height = height + \"px\";\n  } // if (fromState.isFixed) { // commented out because it's now taken care of in getGlobalMatrix() with a flag at the end.\n  // \te -= _getDocScrollLeft();\n  // \tf -= _getDocScrollTop();\n  // }\n\n\n  applyProps && _applyProps(element, toState.props);\n\n  if (simple || !parent) {\n    x += e - fromState.matrix.e;\n    y += f - fromState.matrix.f;\n  } else if (deep || parent !== toState.parent) {\n    cache.renderTransform(1, cache);\n    matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fitChild || element, false, false, true);\n    fromPoint = parentMatrix.apply({\n      x: matrix.e,\n      y: matrix.f\n    });\n    toPoint = parentMatrix.apply({\n      x: e,\n      y: f\n    });\n    x += toPoint.x - fromPoint.x;\n    y += toPoint.y - fromPoint.y;\n  } else {\n    // use a faster/cheaper algorithm if we're just moving x/y\n    parentMatrix.e = parentMatrix.f = 0;\n    toPoint = parentMatrix.apply({\n      x: e - fromState.matrix.e,\n      y: f - fromState.matrix.f\n    });\n    x += toPoint.x;\n    y += toPoint.y;\n  }\n\n  x = _closestTenth(x, 0.02);\n  y = _closestTenth(y, 0.02);\n\n  if (vars && !(vars instanceof ElementState)) {\n    // revert\n    element.style.cssText = cssText;\n    element.getBBox && element.setAttribute(\"transform\", transform || \"\");\n    cache.uncache = 1;\n  } else {\n    // or apply the transform immediately\n    cache.x = x + \"px\";\n    cache.y = y + \"px\";\n    cache.renderTransform(1, cache);\n  }\n\n  if (vars) {\n    vars.x = x;\n    vars.y = y;\n    vars.rotation = rotation;\n    vars.skewX = skewX;\n\n    if (scale) {\n      vars.scaleX = scaleX;\n      vars.scaleY = scaleY;\n    } else {\n      vars.width = width;\n      vars.height = height;\n    }\n  }\n\n  return vars || cache;\n},\n    _parseState = function _parseState(targetsOrState, vars) {\n  return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);\n},\n    _getChangingElState = function _getChangingElState(toState, fromState, id) {\n  var to1 = toState.idLookup[id],\n      to2 = toState.alt[id];\n  return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n},\n    _bodyMetrics = [],\n    _bodyProps = \"width,height,overflowX,overflowY\".split(\",\"),\n    _bodyLocked,\n    _lockBodyScroll = function _lockBodyScroll(lock) {\n  // if there's no scrollbar, we should lock that so that measurements don't get affected by temporary repositioning, like if something is centered in the window.\n  if (lock !== _bodyLocked) {\n    var s = _body.style,\n        w = _body.clientWidth === window.outerWidth,\n        h = _body.clientHeight === window.outerHeight,\n        i = 4;\n\n    if (lock && (w || h)) {\n      while (i--) {\n        _bodyMetrics[i] = s[_bodyProps[i]];\n      }\n\n      if (w) {\n        s.width = _body.clientWidth + \"px\";\n        s.overflowY = \"hidden\";\n      }\n\n      if (h) {\n        s.height = _body.clientHeight + \"px\";\n        s.overflowX = \"hidden\";\n      }\n\n      _bodyLocked = lock;\n    } else if (_bodyLocked) {\n      while (i--) {\n        _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));\n      }\n\n      _bodyLocked = lock;\n    }\n  }\n},\n    _fromTo = function _fromTo(fromState, toState, vars, relative) {\n  // relative is -1 if \"from()\", and 1 if \"to()\"\n  fromState instanceof FlipState && toState instanceof FlipState || console.warn(\"Not a valid state object.\");\n  vars = vars || {};\n\n  var _vars = vars,\n      clearProps = _vars.clearProps,\n      onEnter = _vars.onEnter,\n      onLeave = _vars.onLeave,\n      absolute = _vars.absolute,\n      absoluteOnLeave = _vars.absoluteOnLeave,\n      custom = _vars.custom,\n      delay = _vars.delay,\n      paused = _vars.paused,\n      repeat = _vars.repeat,\n      repeatDelay = _vars.repeatDelay,\n      yoyo = _vars.yoyo,\n      toggleClass = _vars.toggleClass,\n      nested = _vars.nested,\n      _zIndex = _vars.zIndex,\n      scale = _vars.scale,\n      fade = _vars.fade,\n      stagger = _vars.stagger,\n      spin = _vars.spin,\n      prune = _vars.prune,\n      props = (\"props\" in vars ? vars : fromState).props,\n      tweenVars = _copy(vars, _reserved),\n      animation = gsap.timeline({\n    delay: delay,\n    paused: paused,\n    repeat: repeat,\n    repeatDelay: repeatDelay,\n    yoyo: yoyo,\n    data: \"isFlip\"\n  }),\n      remainingProps = tweenVars,\n      entering = [],\n      leaving = [],\n      comps = [],\n      swapOutTargets = [],\n      spinNum = spin === true ? 1 : spin || 0,\n      spinFunc = typeof spin === \"function\" ? spin : function () {\n    return spinNum;\n  },\n      interrupted = fromState.interrupted || toState.interrupted,\n      addFunc = animation[relative !== 1 ? \"to\" : \"from\"],\n      v,\n      p,\n      endTime,\n      i,\n      el,\n      comp,\n      state,\n      targets,\n      finalStates,\n      fromNode,\n      toNode,\n      run,\n      a,\n      b; //relative || (toState = (new FlipState(toState.targets, {props: props})).fit(toState, scale));\n\n\n  for (p in toState.idLookup) {\n    toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n    el = toNode.element;\n    fromNode = fromState.idLookup[p];\n    fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);\n\n    if (fromNode) {\n      comp = {\n        t: el,\n        b: fromNode,\n        a: toNode,\n        sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1\n      };\n      comps.push(comp);\n\n      if (comp.sd) {\n        if (comp.sd < 0) {\n          comp.b = toNode;\n          comp.a = fromNode;\n        } // for swapping elements that got interrupted, we must re-record the inline styles to ensure they're not tainted. Remember, .batch() permits getState() not to force in-progress flips to their end state.\n\n\n        interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);\n        fade && comps.push(comp.swap = {\n          t: fromNode.element,\n          b: comp.b,\n          a: comp.a,\n          sd: -comp.sd,\n          swap: comp\n        });\n      }\n\n      el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;\n    } else if (toNode.isVisible) {\n      comps.push({\n        t: el,\n        b: _copy(toNode, {\n          isVisible: 1\n        }),\n        a: toNode,\n        sd: 0,\n        entering: 1\n      }); // to include it in the \"entering\" Array and do absolute positioning if necessary\n\n      el._flip = _batch ? _batch.timeline : animation;\n    }\n  }\n\n  props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function (p) {\n    return tweenVars[p] = function (i) {\n      return comps[i].a.props[p];\n    };\n  });\n  comps.finalStates = finalStates = [];\n\n  run = function run() {\n    _orderByDOMDepth(comps);\n\n    _lockBodyScroll(true); // otherwise, measurements may get thrown off when things get fit.\n    // TODO: cache the matrix, especially for parent because it'll probably get reused quite a bit, but lock it to a particular cycle(?).\n\n\n    for (i = 0; i < comps.length; i++) {\n      comp = comps[i];\n      a = comp.a;\n      b = comp.b;\n\n      if (prune && !a.isDifferent(b) && !comp.entering) {\n        // only flip if things changed! Don't omit it from comps initially because that'd prevent the element from being positioned absolutely (if necessary)\n        comps.splice(i--, 1);\n      } else {\n        el = comp.t;\n        nested && !(comp.sd < 0) && i && (a.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true)); // moving a parent affects the position of children\n\n        if (b.isVisible && a.isVisible) {\n          if (comp.sd < 0) {\n            // swapping OUT (swap direction of -1 is out)\n            state = new ElementState(el, props, fromState.simple);\n\n            _fit(state, a, scale, 0, 0, state);\n\n            state.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true);\n            state.css = comp.b.css;\n            comp.a = a = state;\n            fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);\n            stagger && swapOutTargets.push(el);\n          } else if (comp.sd > 0 && fade) {\n            // swapping IN (swap direction of 1 is in)\n            el.style.opacity = interrupted ? a.opacity - b.opacity : \"0\";\n          }\n\n          _fit(a, b, scale, props);\n        } else if (b.isVisible !== a.isVisible) {\n          // either entering or leaving (one side is invisible)\n          if (!b.isVisible) {\n            // entering\n            a.isVisible && entering.push(a);\n            comps.splice(i--, 1);\n          } else if (!a.isVisible) {\n            // leaving\n            b.css = a.css;\n            leaving.push(b);\n            comps.splice(i--, 1);\n            absolute && nested && _fit(a, b, scale, props);\n          }\n        }\n\n        if (!scale) {\n          el.style.maxWidth = Math.max(a.width, b.width) + \"px\";\n          el.style.maxHeight = Math.max(a.height, b.height) + \"px\";\n          el.style.minWidth = Math.min(a.width, b.width) + \"px\";\n          el.style.minHeight = Math.min(a.height, b.height) + \"px\";\n        }\n\n        nested && toggleClass && el.classList.add(toggleClass);\n      }\n\n      finalStates.push(a);\n    }\n\n    var classTargets;\n\n    if (toggleClass) {\n      classTargets = finalStates.map(function (s) {\n        return s.element;\n      });\n      nested && classTargets.forEach(function (e) {\n        return e.classList.remove(toggleClass);\n      }); // there could be a delay, so don't leave the classes applied (we'll do it in a timeline callback)\n    }\n\n    _lockBodyScroll(false);\n\n    if (scale) {\n      tweenVars.scaleX = function (i) {\n        return comps[i].a.scaleX;\n      };\n\n      tweenVars.scaleY = function (i) {\n        return comps[i].a.scaleY;\n      };\n    } else {\n      tweenVars.width = function (i) {\n        return comps[i].a.width + \"px\";\n      };\n\n      tweenVars.height = function (i) {\n        return comps[i].a.height + \"px\";\n      };\n\n      tweenVars.autoRound = vars.autoRound || false;\n    }\n\n    tweenVars.x = function (i) {\n      return comps[i].a.x + \"px\";\n    };\n\n    tweenVars.y = function (i) {\n      return comps[i].a.y + \"px\";\n    };\n\n    tweenVars.rotation = function (i) {\n      return comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n    };\n\n    tweenVars.skewX = function (i) {\n      return comps[i].a.skewX;\n    };\n\n    targets = comps.map(function (c) {\n      return c.t;\n    });\n\n    if (_zIndex || _zIndex === 0) {\n      tweenVars.modifiers = {\n        zIndex: function zIndex() {\n          return _zIndex;\n        }\n      };\n      tweenVars.zIndex = _zIndex;\n      tweenVars.immediateRender = vars.immediateRender !== false;\n    }\n\n    fade && (tweenVars.opacity = function (i) {\n      return comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : \"+=0\";\n    });\n\n    if (swapOutTargets.length) {\n      stagger = gsap.utils.distribute(stagger);\n      var dummyArray = targets.slice(swapOutTargets.length);\n\n      tweenVars.stagger = function (i, el) {\n        return stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n      };\n    } // // for testing...\n    // gsap.delayedCall(vars.data ? 50 : 1, function() {\n    // \tanimation.eventCallback(\"onComplete\", () => _setFinalStates(comps, !clearProps));\n    // \taddFunc.call(animation, targets, tweenVars, 0).play();\n    // });\n    // return;\n\n\n    _callbacks.forEach(function (name) {\n      return vars[name] && animation.eventCallback(name, vars[name], vars[name + \"Params\"]);\n    }); // apply callbacks to the timeline, not tweens (because \"custom\" timing can make multiple tweens)\n\n\n    if (custom && targets.length) {\n      // bust out the custom properties as their own tweens so they can use different eases, durations, etc.\n      remainingProps = _copy(tweenVars, _reserved);\n\n      if (\"scale\" in custom) {\n        custom.scaleX = custom.scaleY = custom.scale;\n        delete custom.scale;\n      }\n\n      for (p in custom) {\n        v = _copy(custom[p], _fitReserved);\n        v[p] = tweenVars[p];\n        !(\"duration\" in v) && \"duration\" in tweenVars && (v.duration = tweenVars.duration);\n        v.stagger = tweenVars.stagger;\n        addFunc.call(animation, targets, v, 0);\n        delete remainingProps[p];\n      }\n    }\n\n    if (targets.length || leaving.length || entering.length) {\n      toggleClass && animation.add(function () {\n        return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? \"remove\" : \"add\");\n      }, 0) && !paused && _toggleClass(classTargets, toggleClass, \"add\");\n      targets.length && addFunc.call(animation, targets, remainingProps, 0);\n    }\n\n    _handleCallback(onEnter, entering, animation);\n\n    _handleCallback(onLeave, leaving, animation);\n\n    var batchTl = _batch && _batch.timeline;\n\n    if (batchTl) {\n      batchTl.add(animation, 0);\n\n      _batch._final.push(function () {\n        return _setFinalStates(comps, !clearProps);\n      });\n    }\n\n    endTime = animation.duration();\n    animation.call(function () {\n      var forward = animation.time() >= endTime;\n      forward && !batchTl && _setFinalStates(comps, !clearProps);\n      toggleClass && _toggleClass(classTargets, toggleClass, forward ? \"remove\" : \"add\");\n    });\n  };\n\n  absoluteOnLeave && (absolute = comps.filter(function (comp) {\n    return !comp.sd && !comp.a.isVisible && comp.b.isVisible;\n  }).map(function (comp) {\n    return comp.a.element;\n  }));\n\n  if (_batch) {\n    var _batch$_abs;\n\n    absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));\n\n    _batch._run.push(run);\n  } else {\n    absolute && _makeCompsAbsolute(_filterComps(comps, absolute)); // when making absolute, we must go in a very particular order so that document flow changes don't affect things. Don't make it visible if both the before and after states are invisible! There's no point, and it could make things appear visible during the flip that shouldn't be.\n\n    run();\n  }\n\n  var anim = _batch ? _batch.timeline : animation;\n\n  anim.revert = function () {\n    return _killFlip(anim, 1);\n  }; // a Flip timeline should behave very different when reverting - it should actually jump to the end so that styles get cleared out.\n\n\n  return anim;\n},\n    _interrupt = function _interrupt(tl) {\n  tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n  tl.getChildren(true, false, true).forEach(_interrupt);\n},\n    _killFlip = function _killFlip(tl, action) {\n  // action: 0 = nothing, 1 = complete, 2 = only kill (don't complete)\n  if (tl && tl.progress() < 1 && !tl.paused()) {\n    if (action) {\n      _interrupt(tl);\n\n      action < 2 && tl.progress(1); // we should also kill it in case it was added to a parent timeline.\n\n      tl.kill();\n    }\n\n    return true;\n  }\n},\n    _createLookup = function _createLookup(state) {\n  var lookup = state.idLookup = {},\n      alt = state.alt = {},\n      elStates = state.elementStates,\n      i = elStates.length,\n      elState;\n\n  while (i--) {\n    elState = elStates[i];\n    lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;\n  }\n};\n\nvar FlipState = /*#__PURE__*/function () {\n  function FlipState(targets, vars, targetsAreElementStates) {\n    this.props = vars && vars.props;\n    this.simple = !!(vars && vars.simple);\n\n    if (targetsAreElementStates) {\n      this.targets = _elementsFromElementStates(targets);\n      this.elementStates = targets;\n\n      _createLookup(this);\n    } else {\n      this.targets = _toArray(targets);\n      var soft = vars && (vars.kill === false || vars.batch && !vars.kill);\n      _batch && !soft && _batch._kill.push(this);\n      this.update(soft || !!_batch); // when batching, don't force in-progress flips to their end; we need to do that AFTER all getStates() are called.\n    }\n  }\n\n  var _proto = FlipState.prototype;\n\n  _proto.update = function update(soft) {\n    var _this = this;\n\n    this.elementStates = this.targets.map(function (el) {\n      return new ElementState(el, _this.props, _this.simple);\n    });\n\n    _createLookup(this);\n\n    this.interrupt(soft);\n    this.recordInlineStyles();\n    return this;\n  };\n\n  _proto.clear = function clear() {\n    this.targets.length = this.elementStates.length = 0;\n\n    _createLookup(this);\n\n    return this;\n  };\n\n  _proto.fit = function fit(state, scale, nested) {\n    var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true),\n        toElStates = (state || this).idLookup,\n        i = 0,\n        fromNode,\n        toNode;\n\n    for (; i < elStatesInOrder.length; i++) {\n      fromNode = elStatesInOrder[i];\n      nested && (fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true)); // moving a parent affects the position of children\n\n      toNode = toElStates[fromNode.id];\n      toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n      fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true);\n    }\n\n    return this;\n  };\n\n  _proto.getProperty = function getProperty(element, property) {\n    var es = this.getElementState(element) || _emptyObj;\n\n    return (property in es ? es : es.props || _emptyObj)[property];\n  };\n\n  _proto.add = function add(state) {\n    var i = state.targets.length,\n        lookup = this.idLookup,\n        alt = this.alt,\n        index,\n        es,\n        es2;\n\n    while (i--) {\n      es = state.elementStates[i];\n      es2 = lookup[es.id];\n\n      if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {\n        // if the flip id is already in this FlipState, replace it!\n        index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);\n        this.targets.splice(index, 1, state.targets[i]);\n        this.elementStates.splice(index, 1, es);\n      } else {\n        this.targets.push(state.targets[i]);\n        this.elementStates.push(es);\n      }\n    }\n\n    state.interrupted && (this.interrupted = true);\n    state.simple || (this.simple = false);\n\n    _createLookup(this);\n\n    return this;\n  };\n\n  _proto.compare = function compare(state) {\n    var l1 = state.idLookup,\n        l2 = this.idLookup,\n        unchanged = [],\n        changed = [],\n        enter = [],\n        leave = [],\n        targets = [],\n        a1 = state.alt,\n        a2 = this.alt,\n        place = function place(s1, s2, el) {\n      return (s1.isVisible !== s2.isVisible ? s1.isVisible ? enter : leave : s1.isVisible ? changed : unchanged).push(el) && targets.push(el);\n    },\n        placeIfDoesNotExist = function placeIfDoesNotExist(s1, s2, el) {\n      return targets.indexOf(el) < 0 && place(s1, s2, el);\n    },\n        s1,\n        s2,\n        p,\n        el,\n        s1Alt,\n        s2Alt,\n        c1,\n        c2;\n\n    for (p in l1) {\n      s1Alt = a1[p];\n      s2Alt = a2[p];\n      s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);\n      el = s1.element;\n      s2 = l2[p];\n\n      if (s2Alt) {\n        c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;\n        c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1; //c1.element !== c2.element && c1.element === s2.element && (c2 = s2);\n\n        if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {\n          // swapping, so force into \"changed\" array\n          (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);\n          targets.push(c1.element, c2.element);\n        } else {\n          place(c1, c2, c1.element);\n        }\n\n        s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);\n        placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);\n        placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);\n        s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);\n      } else {\n        !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);\n        s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);\n      }\n    }\n\n    for (p in l2) {\n      if (!l1[p]) {\n        leave.push(l2[p].element);\n        a2[p] && leave.push(a2[p].element);\n      }\n    }\n\n    return {\n      changed: changed,\n      unchanged: unchanged,\n      enter: enter,\n      leave: leave\n    };\n  };\n\n  _proto.recordInlineStyles = function recordInlineStyles() {\n    var props = _memoizedRemoveProps[this.props] || _removeProps,\n        i = this.elementStates.length;\n\n    while (i--) {\n      _recordInlineStyles(this.elementStates[i], props);\n    }\n  };\n\n  _proto.interrupt = function interrupt(soft) {\n    var _this2 = this;\n\n    // soft = DON'T force in-progress flip animations to completion (like when running a batch, we can't immediately kill flips when getting states because it could contaminate positioning and other .getState() calls that will run in the batch (we kill AFTER all the .getState() calls complete).\n    var timelines = [];\n    this.targets.forEach(function (t) {\n      var tl = t._flip,\n          foundInProgress = _killFlip(tl, soft ? 0 : 1);\n\n      soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function () {\n        return _this2.updateVisibility();\n      });\n      foundInProgress && timelines.push(tl);\n    });\n    !soft && timelines.length && this.updateVisibility(); // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.\n\n    this.interrupted || (this.interrupted = !!timelines.length);\n  };\n\n  _proto.updateVisibility = function updateVisibility() {\n    this.elementStates.forEach(function (es) {\n      var b = es.element.getBoundingClientRect();\n      es.isVisible = !!(b.width || b.height || b.top || b.left);\n      es.uncache = 1;\n    });\n  };\n\n  _proto.getElementState = function getElementState(element) {\n    return this.elementStates[this.targets.indexOf(_getEl(element))];\n  };\n\n  _proto.makeAbsolute = function makeAbsolute() {\n    return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n  };\n\n  return FlipState;\n}();\n\nvar ElementState = /*#__PURE__*/function () {\n  function ElementState(element, props, simple) {\n    this.element = element;\n    this.update(props, simple);\n  }\n\n  var _proto2 = ElementState.prototype;\n\n  _proto2.isDifferent = function isDifferent(state) {\n    var b1 = this.bounds,\n        b2 = state.bounds;\n    return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);\n  };\n\n  _proto2.update = function update(props, simple) {\n    var self = this,\n        element = self.element,\n        getProp = gsap.getProperty(element),\n        cache = gsap.core.getCache(element),\n        bounds = element.getBoundingClientRect(),\n        bbox = element.getBBox && typeof element.getBBox === \"function\" && element.nodeName.toLowerCase() !== \"svg\" && element.getBBox(),\n        m = simple ? new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)()) : (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n    self.getProp = getProp;\n    self.element = element;\n    self.id = _getID(element);\n    self.matrix = m;\n    self.cache = cache;\n    self.bounds = bounds;\n    self.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n    self.display = getProp(\"display\");\n    self.position = getProp(\"position\");\n    self.parent = element.parentNode;\n    self.x = getProp(\"x\");\n    self.y = getProp(\"y\");\n    self.scaleX = cache.scaleX;\n    self.scaleY = cache.scaleY;\n    self.rotation = getProp(\"rotation\");\n    self.skewX = getProp(\"skewX\");\n    self.opacity = getProp(\"opacity\");\n    self.width = bbox ? bbox.width : _closestTenth(getProp(\"width\", \"px\"), 0.04); // round up to the closest 0.1 so that text doesn't wrap.\n\n    self.height = bbox ? bbox.height : _closestTenth(getProp(\"height\", \"px\"), 0.04);\n    props && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));\n    self.ctm = element.getCTM && element.nodeName.toLowerCase() === \"svg\" && (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getCTM)(element).inverse();\n    self.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1; // allows us to speed through some other tasks if it's not scale/rotated\n\n    self.uncache = 0;\n  };\n\n  return ElementState;\n}();\n\nvar FlipAction = /*#__PURE__*/function () {\n  function FlipAction(vars, batch) {\n    this.vars = vars;\n    this.batch = batch;\n    this.states = [];\n    this.timeline = batch.timeline;\n  }\n\n  var _proto3 = FlipAction.prototype;\n\n  _proto3.getStateById = function getStateById(id) {\n    var i = this.states.length;\n\n    while (i--) {\n      if (this.states[i].idLookup[id]) {\n        return this.states[i];\n      }\n    }\n  };\n\n  _proto3.kill = function kill() {\n    this.batch.remove(this);\n  };\n\n  return FlipAction;\n}();\n\nvar FlipBatch = /*#__PURE__*/function () {\n  function FlipBatch(id) {\n    this.id = id;\n    this.actions = [];\n    this._kill = [];\n    this._final = [];\n    this._abs = [];\n    this._run = [];\n    this.data = {};\n    this.state = new FlipState();\n    this.timeline = gsap.timeline();\n  }\n\n  var _proto4 = FlipBatch.prototype;\n\n  _proto4.add = function add(config) {\n    var result = this.actions.filter(function (action) {\n      return action.vars === config;\n    });\n\n    if (result.length) {\n      return result[0];\n    }\n\n    result = new FlipAction(typeof config === \"function\" ? {\n      animate: config\n    } : config, this);\n    this.actions.push(result);\n    return result;\n  };\n\n  _proto4.remove = function remove(action) {\n    var i = this.actions.indexOf(action);\n    i >= 0 && this.actions.splice(i, 1);\n    return this;\n  };\n\n  _proto4.getState = function getState(merge) {\n    var _this3 = this;\n\n    var prevBatch = _batch,\n        prevAction = _batchAction;\n    _batch = this;\n    this.state.clear();\n    this._kill.length = 0;\n    this.actions.forEach(function (action) {\n      if (action.vars.getState) {\n        action.states.length = 0;\n        _batchAction = action;\n        action.state = action.vars.getState(action);\n      }\n\n      merge && action.states.forEach(function (s) {\n        return _this3.state.add(s);\n      });\n    });\n    _batchAction = prevAction;\n    _batch = prevBatch;\n    this.killConflicts();\n    return this;\n  };\n\n  _proto4.animate = function animate() {\n    var _this4 = this;\n\n    var prevBatch = _batch,\n        tl = this.timeline,\n        i = this.actions.length,\n        finalStates,\n        endTime;\n    _batch = this;\n    tl.clear();\n    this._abs.length = this._final.length = this._run.length = 0;\n    this.actions.forEach(function (a) {\n      a.vars.animate && a.vars.animate(a);\n      var onEnter = a.vars.onEnter,\n          onLeave = a.vars.onLeave,\n          targets = a.targets,\n          s,\n          result;\n\n      if (targets && targets.length && (onEnter || onLeave)) {\n        s = new FlipState();\n        a.states.forEach(function (state) {\n          return s.add(state);\n        });\n        result = s.compare(Flip.getState(targets));\n        result.enter.length && onEnter && onEnter(result.enter);\n        result.leave.length && onLeave && onLeave(result.leave);\n      }\n    });\n\n    _makeCompsAbsolute(this._abs);\n\n    this._run.forEach(function (f) {\n      return f();\n    });\n\n    endTime = tl.duration();\n    finalStates = this._final.slice(0);\n    tl.add(function () {\n      if (endTime <= tl.time()) {\n        // only call if moving forward in the timeline (in case it's nested in a timeline that gets reversed)\n        finalStates.forEach(function (f) {\n          return f();\n        });\n\n        _forEachBatch(_this4, \"onComplete\");\n      }\n    });\n    _batch = prevBatch;\n\n    while (i--) {\n      this.actions[i].vars.once && this.actions[i].kill();\n    }\n\n    _forEachBatch(this, \"onStart\");\n\n    tl.restart();\n    return this;\n  };\n\n  _proto4.loadState = function loadState(done) {\n    done || (done = function done() {\n      return 0;\n    });\n    var queue = [];\n    this.actions.forEach(function (c) {\n      if (c.vars.loadState) {\n        var i,\n            f = function f(targets) {\n          targets && (c.targets = targets);\n          i = queue.indexOf(f);\n\n          if (~i) {\n            queue.splice(i, 1);\n            queue.length || done();\n          }\n        };\n\n        queue.push(f);\n        c.vars.loadState(f);\n      }\n    });\n    queue.length || done();\n    return this;\n  };\n\n  _proto4.setState = function setState() {\n    this.actions.forEach(function (c) {\n      return c.targets = c.vars.setState && c.vars.setState(c);\n    });\n    return this;\n  };\n\n  _proto4.killConflicts = function killConflicts(soft) {\n    this.state.interrupt(soft);\n\n    this._kill.forEach(function (state) {\n      return state.interrupt(soft);\n    });\n\n    return this;\n  };\n\n  _proto4.run = function run(skipGetState, merge) {\n    var _this5 = this;\n\n    if (this !== _batch) {\n      skipGetState || this.getState(merge);\n      this.loadState(function () {\n        if (!_this5._killed) {\n          _this5.setState();\n\n          _this5.animate();\n        }\n      });\n    }\n\n    return this;\n  };\n\n  _proto4.clear = function clear(stateOnly) {\n    this.state.clear();\n    stateOnly || (this.actions.length = 0);\n  };\n\n  _proto4.getStateById = function getStateById(id) {\n    var i = this.actions.length,\n        s;\n\n    while (i--) {\n      s = this.actions[i].getStateById(id);\n\n      if (s) {\n        return s;\n      }\n    }\n\n    return this.state.idLookup[id] && this.state;\n  };\n\n  _proto4.kill = function kill() {\n    this._killed = 1;\n    this.clear();\n    delete _batchLookup[this.id];\n  };\n\n  return FlipBatch;\n}();\n\nvar Flip = /*#__PURE__*/function () {\n  function Flip() {}\n\n  Flip.getState = function getState(targets, vars) {\n    var state = _parseState(targets, vars);\n\n    _batchAction && _batchAction.states.push(state);\n    vars && vars.batch && Flip.batch(vars.batch).state.add(state);\n    return state;\n  };\n\n  Flip.from = function from(state, vars) {\n    vars = vars || {};\n    \"clearProps\" in vars || (vars.clearProps = true);\n    return _fromTo(state, _parseState(vars.targets || state.targets, {\n      props: vars.props || state.props,\n      simple: vars.simple,\n      kill: !!vars.kill\n    }), vars, -1);\n  };\n\n  Flip.to = function to(state, vars) {\n    return _fromTo(state, _parseState(vars.targets || state.targets, {\n      props: vars.props || state.props,\n      simple: vars.simple,\n      kill: !!vars.kill\n    }), vars, 1);\n  };\n\n  Flip.fromTo = function fromTo(fromState, toState, vars) {\n    return _fromTo(fromState, toState, vars);\n  };\n\n  Flip.fit = function fit(fromEl, toEl, vars) {\n    var v = vars ? _copy(vars, _fitReserved) : {},\n        _ref = vars || v,\n        absolute = _ref.absolute,\n        scale = _ref.scale,\n        getVars = _ref.getVars,\n        props = _ref.props,\n        runBackwards = _ref.runBackwards,\n        onComplete = _ref.onComplete,\n        simple = _ref.simple,\n        fitChild = vars && vars.fitChild && _getEl(vars.fitChild),\n        before = _parseElementState(toEl, props, simple, fromEl),\n        after = _parseElementState(fromEl, 0, simple, before),\n        inlineProps = props ? _memoizedRemoveProps[props] : _removeProps;\n\n    props && _applyProps(v, before.props);\n\n    if (runBackwards) {\n      _recordInlineStyles(after, inlineProps);\n\n      \"immediateRender\" in v || (v.immediateRender = true);\n\n      v.onComplete = function () {\n        _applyInlineStyles(after);\n\n        onComplete && onComplete.apply(this, arguments);\n      };\n    }\n\n    absolute && _makeAbsolute(after, before);\n    v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n    return getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n  };\n\n  Flip.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {\n    return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n  };\n\n  Flip.batch = function batch(id) {\n    id || (id = \"default\");\n    return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));\n  };\n\n  Flip.killFlipsOf = function killFlipsOf(targets, complete) {\n    (targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(function (t) {\n      return t && _killFlip(t._flip, complete !== false ? 1 : 2);\n    });\n  };\n\n  Flip.isFlipping = function isFlipping(target) {\n    var f = Flip.getByTarget(target);\n    return !!f && f.isActive();\n  };\n\n  Flip.getByTarget = function getByTarget(target) {\n    return (_getEl(target) || _emptyObj)._flip;\n  };\n\n  Flip.getElementState = function getElementState(target, props) {\n    return new ElementState(_getEl(target), props);\n  };\n\n  Flip.convertCoordinates = function convertCoordinates(fromElement, toElement, point) {\n    var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromElement));\n    return point ? m.apply(point) : m;\n  };\n\n  Flip.register = function register(core) {\n    _body = typeof document !== \"undefined\" && document.body;\n\n    if (_body) {\n      gsap = core;\n\n      (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._setDoc)(_body);\n\n      _toArray = gsap.utils.toArray;\n      var snap = gsap.utils.snap(0.1);\n\n      _closestTenth = function _closestTenth(value, add) {\n        return snap(parseFloat(value) + add);\n      };\n    }\n  };\n\n  return Flip;\n}();\nFlip.version = \"3.11.2\"; // function whenImagesLoad(el, func) {\n// \tlet pending = [],\n// \t\tonLoad = e => {\n// \t\t\tpending.splice(pending.indexOf(e.target), 1);\n// \t\t\te.target.removeEventListener(\"load\", onLoad);\n// \t\t\tpending.length || func();\n// \t\t};\n// \tgsap.utils.toArray(el.tagName.toLowerCase() === \"img\" ? el : el.querySelectorAll(\"img\")).forEach(img => img.complete || img.addEventListener(\"load\", onLoad) || pending.push(img));\n// \tpending.length || func();\n// }\n\ntypeof window !== \"undefined\" && window.gsap && window.gsap.registerPlugin(Flip);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9GbGlwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNxSDs7QUFFckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixpRUFBZTtBQUN4QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFRLDJCQUEyQixtRUFBaUIsaUJBQWlCLGtFQUFnQjtBQUMvRyxNQUFNO0FBQ04sc0JBQXNCLGlFQUFlO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNDQUFzQzs7O0FBR3RDO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5SEFBeUg7O0FBRXpIO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGFBQWEsaUVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBMEQsYUFBYTs7O0FBR2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7OztBQUdBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFEQUFxRCxpRUFBZSwyQkFBMkI7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixpRUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0osbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtDQUFrQztBQUNsQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4REFBOEQ7QUFDbkc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxtQ0FBbUMsaUVBQWUseUNBQXlDOztBQUUzRjtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFlO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0dBQXNHOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFRLDJCQUEyQixtRUFBaUIsaUJBQWlCLGtFQUFnQixNQUFNLGlFQUFlO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQSw2RUFBNkUseURBQU87QUFDcEYsb0dBQW9HOztBQUVwRztBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpRUFBZSxpQ0FBaUMsaUVBQWU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSx5REFBTzs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9GbGlwLmpzP2ZkM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGbGlwIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdldEdsb2JhbE1hdHJpeCwgX2dldERvY1Njcm9sbFRvcCwgX2dldERvY1Njcm9sbExlZnQsIE1hdHJpeDJELCBfc2V0RG9jLCBfZ2V0Q1RNIH0gZnJvbSBcIi4vdXRpbHMvbWF0cml4LmpzXCI7XG5cbnZhciBfaWQgPSAxLFxuICAgIF90b0FycmF5LFxuICAgIGdzYXAsXG4gICAgX2JhdGNoLFxuICAgIF9iYXRjaEFjdGlvbixcbiAgICBfYm9keSxcbiAgICBfY2xvc2VzdFRlbnRoLFxuICAgIF9mb3JFYWNoQmF0Y2ggPSBmdW5jdGlvbiBfZm9yRWFjaEJhdGNoKGJhdGNoLCBuYW1lKSB7XG4gIHJldHVybiBiYXRjaC5hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYS52YXJzW25hbWVdICYmIGEudmFyc1tuYW1lXShhKTtcbiAgfSk7XG59LFxuICAgIF9iYXRjaExvb2t1cCA9IHt9LFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX2VtcHR5T2JqID0ge30sXG4gICAgX2Rhc2hlZE5hbWVMb29rdXAgPSB7fSxcbiAgICBfbWVtb2l6ZWRSZW1vdmVQcm9wcyA9IHt9LFxuICAgIF9saXN0VG9BcnJheSA9IGZ1bmN0aW9uIF9saXN0VG9BcnJheShsaXN0KSB7XG4gIHJldHVybiB0eXBlb2YgbGlzdCA9PT0gXCJzdHJpbmdcIiA/IGxpc3Quc3BsaXQoXCIgXCIpLmpvaW4oXCJcIikuc3BsaXQoXCIsXCIpIDogbGlzdDtcbn0sXG4gICAgLy8gcmVtb3ZlcyBleHRyYSBzcGFjZXMgY29udGFtaW5hdGluZyB0aGUgbmFtZXMsIHJldHVybnMgYW4gQXJyYXkuXG5fY2FsbGJhY2tzID0gX2xpc3RUb0FycmF5KFwib25TdGFydCxvblVwZGF0ZSxvbkNvbXBsZXRlLG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIpLFxuICAgIF9yZW1vdmVQcm9wcyA9IF9saXN0VG9BcnJheShcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sd2lkdGgsaGVpZ2h0LHBvc2l0aW9uLHRvcCxsZWZ0LG9wYWNpdHksekluZGV4LG1heFdpZHRoLG1heEhlaWdodCxtaW5XaWR0aCxtaW5IZWlnaHRcIiksXG4gICAgX2dldEVsID0gZnVuY3Rpb24gX2dldEVsKHRhcmdldCkge1xuICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0KVswXSB8fCBjb25zb2xlLndhcm4oXCJFbGVtZW50IG5vdCBmb3VuZDpcIiwgdGFyZ2V0KTtcbn0sXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDApIC8gMTAwMDAgfHwgMDtcbn0sXG4gICAgX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gX3RvZ2dsZUNsYXNzKHRhcmdldHMsIGNsYXNzTmFtZSwgYWN0aW9uKSB7XG4gIHJldHVybiB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLmNsYXNzTGlzdFthY3Rpb25dKGNsYXNzTmFtZSk7XG4gIH0pO1xufSxcbiAgICBfcmVzZXJ2ZWQgPSB7XG4gIHpJbmRleDogMSxcbiAga2lsbDogMSxcbiAgc2ltcGxlOiAxLFxuICBzcGluOiAxLFxuICBjbGVhclByb3BzOiAxLFxuICB0YXJnZXRzOiAxLFxuICB0b2dnbGVDbGFzczogMSxcbiAgb25Db21wbGV0ZTogMSxcbiAgb25VcGRhdGU6IDEsXG4gIG9uSW50ZXJydXB0OiAxLFxuICBvblN0YXJ0OiAxLFxuICBkZWxheTogMSxcbiAgcmVwZWF0OiAxLFxuICByZXBlYXREZWxheTogMSxcbiAgeW95bzogMSxcbiAgc2NhbGU6IDEsXG4gIGZhZGU6IDEsXG4gIGFic29sdXRlOiAxLFxuICBwcm9wczogMSxcbiAgb25FbnRlcjogMSxcbiAgb25MZWF2ZTogMSxcbiAgY3VzdG9tOiAxLFxuICBwYXVzZWQ6IDEsXG4gIG5lc3RlZDogMSxcbiAgcHJ1bmU6IDEsXG4gIGFic29sdXRlT25MZWF2ZTogMVxufSxcbiAgICBfZml0UmVzZXJ2ZWQgPSB7XG4gIHpJbmRleDogMSxcbiAgc2ltcGxlOiAxLFxuICBjbGVhclByb3BzOiAxLFxuICBzY2FsZTogMSxcbiAgYWJzb2x1dGU6IDEsXG4gIGZpdENoaWxkOiAxLFxuICBnZXRWYXJzOiAxLFxuICBwcm9wczogMVxufSxcbiAgICBfY2FtZWxUb0Rhc2hlZCA9IGZ1bmN0aW9uIF9jYW1lbFRvRGFzaGVkKHApIHtcbiAgcmV0dXJuIHAucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xufSxcbiAgICBfY29weSA9IGZ1bmN0aW9uIF9jb3B5KG9iaiwgZXhjbHVkZSkge1xuICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBleGNsdWRlW3BdIHx8IChyZXN1bHRbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0sXG4gICAgX21lbW9pemVkUHJvcHMgPSB7fSxcbiAgICBfbWVtb2l6ZVByb3BzID0gZnVuY3Rpb24gX21lbW9pemVQcm9wcyhwcm9wcykge1xuICB2YXIgcCA9IF9tZW1vaXplZFByb3BzW3Byb3BzXSA9IF9saXN0VG9BcnJheShwcm9wcyk7XG5cbiAgX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdID0gcC5jb25jYXQoX3JlbW92ZVByb3BzKTtcbiAgcmV0dXJuIHA7XG59LFxuICAgIF9nZXRJbnZlcnNlR2xvYmFsTWF0cml4ID0gZnVuY3Rpb24gX2dldEludmVyc2VHbG9iYWxNYXRyaXgoZWwpIHtcbiAgLy8gaW50ZWdyYXRlcyBjYWNoaW5nIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZVxuICB2YXIgY2FjaGUgPSBlbC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWwpO1xuXG4gIGlmIChjYWNoZS5nbUNhY2hlID09PSBnc2FwLnRpY2tlci5mcmFtZSkge1xuICAgIHJldHVybiBjYWNoZS5nTWF0cml4O1xuICB9XG5cbiAgY2FjaGUuZ21DYWNoZSA9IGdzYXAudGlja2VyLmZyYW1lO1xuICByZXR1cm4gY2FjaGUuZ01hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChlbCwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xufSxcbiAgICBfZ2V0RE9NRGVwdGggPSBmdW5jdGlvbiBfZ2V0RE9NRGVwdGgoZWwsIGludmVydCwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsID09PSB2b2lkIDApIHtcbiAgICBsZXZlbCA9IDA7XG4gIH1cblxuICAvLyBJbiBpbnZlcnQgaXMgdHJ1ZSwgdGhlIHNpYmxpbmcgZGVwdGggaXMgaW5jcmVtZW50cyBvZiAxLCBhbmQgcGFyZW50L25lc3RpbmcgZGVwdGggaXMgaW5jcmVtZW50cyBvZiAxMDAwLiBUaGlzIGxldHMgdXMgb3JkZXIgZWxlbWVudHMgaW4gYW4gQXJyYXkgdG8gcmVmbGVjdCBkb2N1bWVudCBmbG93LlxuICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZSxcbiAgICAgIGluYyA9IDEwMDAgKiBNYXRoLnBvdygxMCwgbGV2ZWwpICogKGludmVydCA/IC0xIDogMSksXG4gICAgICBsID0gaW52ZXJ0ID8gLWluYyAqIDkwMCA6IDA7XG5cbiAgd2hpbGUgKGVsKSB7XG4gICAgbCArPSBpbmM7XG4gICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gcGFyZW50ID8gbCArIF9nZXRET01EZXB0aChwYXJlbnQsIGludmVydCwgbGV2ZWwgKyAxKSA6IGw7XG59LFxuICAgIF9vcmRlckJ5RE9NRGVwdGggPSBmdW5jdGlvbiBfb3JkZXJCeURPTURlcHRoKGNvbXBzLCBpbnZlcnQsIGlzRWxTdGF0ZXMpIHtcbiAgY29tcHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiBjb21wLmQgPSBfZ2V0RE9NRGVwdGgoaXNFbFN0YXRlcyA/IGNvbXAuZWxlbWVudCA6IGNvbXAudCwgaW52ZXJ0KTtcbiAgfSk7XG4gIGNvbXBzLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xuICAgIHJldHVybiBjMS5kIC0gYzIuZDtcbiAgfSk7XG4gIHJldHVybiBjb21wcztcbn0sXG4gICAgX3JlY29yZElubGluZVN0eWxlcyA9IGZ1bmN0aW9uIF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgcHJvcHMpIHtcbiAgLy8gcmVjb3JkcyB0aGUgY3VycmVudCBpbmxpbmUgQ1NTIHByb3BlcnRpZXMgaW50byBhbiBBcnJheSBpbiBhbHRlcm5hdGluZyBuYW1lL3ZhbHVlIHBhaXJzIHRoYXQncyBzdG9yZWQgaW4gYSBcImNzc1wiIHByb3BlcnR5IG9uIHRoZSBzdGF0ZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IGxhdGVyLlxuICB2YXIgc3R5bGUgPSBlbFN0YXRlLmVsZW1lbnQuc3R5bGUsXG4gICAgICBhID0gZWxTdGF0ZS5jc3MgPSBlbFN0YXRlLmNzcyB8fCBbXSxcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGgsXG4gICAgICBwLFxuICAgICAgdjtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcCA9IHByb3BzW2ldO1xuICAgIHYgPSBzdHlsZVtwXSB8fCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHApO1xuICAgIGEucHVzaCh2ID8gcCA6IF9kYXNoZWROYW1lTG9va3VwW3BdIHx8IChfZGFzaGVkTmFtZUxvb2t1cFtwXSA9IF9jYW1lbFRvRGFzaGVkKHApKSwgdik7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59LFxuICAgIF9hcHBseUlubGluZVN0eWxlcyA9IGZ1bmN0aW9uIF9hcHBseUlubGluZVN0eWxlcyhzdGF0ZSkge1xuICB2YXIgY3NzID0gc3RhdGUuY3NzLFxuICAgICAgc3R5bGUgPSBzdGF0ZS5lbGVtZW50LnN0eWxlLFxuICAgICAgaSA9IDA7XG4gIHN0YXRlLmNhY2hlLnVuY2FjaGUgPSAxO1xuXG4gIGZvciAoOyBpIDwgY3NzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY3NzW2kgKyAxXSA/IHN0eWxlW2Nzc1tpXV0gPSBjc3NbaSArIDFdIDogc3R5bGUucmVtb3ZlUHJvcGVydHkoY3NzW2ldKTtcbiAgfVxufSxcbiAgICBfc2V0RmluYWxTdGF0ZXMgPSBmdW5jdGlvbiBfc2V0RmluYWxTdGF0ZXMoY29tcHMsIG9ubHlUcmFuc2Zvcm1zKSB7XG4gIGNvbXBzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5hLmNhY2hlLnVuY2FjaGUgPSAxO1xuICB9KTtcbiAgb25seVRyYW5zZm9ybXMgfHwgY29tcHMuZmluYWxTdGF0ZXMuZm9yRWFjaChfYXBwbHlJbmxpbmVTdHlsZXMpO1xufSxcbiAgICBfYWJzb2x1dGVQcm9wcyA9IFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdCxncmlkQXJlYSx0cmFuc2l0aW9uXCIuc3BsaXQoXCIsXCIpLFxuICAgIC8vIHByb3BlcnRpZXMgdGhhdCB3ZSBtdXN0IHJlY29yZCBqdXN0XG5fbWFrZUFic29sdXRlID0gZnVuY3Rpb24gX21ha2VBYnNvbHV0ZShlbFN0YXRlLCBmYWxsYmFja05vZGUsIGlnbm9yZUJhdGNoKSB7XG4gIHZhciBlbGVtZW50ID0gZWxTdGF0ZS5lbGVtZW50LFxuICAgICAgd2lkdGggPSBlbFN0YXRlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZWxTdGF0ZS5oZWlnaHQsXG4gICAgICB1bmNhY2hlID0gZWxTdGF0ZS51bmNhY2hlLFxuICAgICAgZ2V0UHJvcCA9IGVsU3RhdGUuZ2V0UHJvcCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIGkgPSA0LFxuICAgICAgcmVzdWx0LFxuICAgICAgZGlzcGxheUlzTm9uZSxcbiAgICAgIGNzO1xuICB0eXBlb2YgZmFsbGJhY2tOb2RlICE9PSBcIm9iamVjdFwiICYmIChmYWxsYmFja05vZGUgPSBlbFN0YXRlKTtcblxuICBpZiAoX2JhdGNoICYmIGlnbm9yZUJhdGNoICE9PSAxKSB7XG4gICAgX2JhdGNoLl9hYnMucHVzaCh7XG4gICAgICB0OiBlbGVtZW50LFxuICAgICAgYjogZWxTdGF0ZSxcbiAgICAgIGE6IGVsU3RhdGUsXG4gICAgICBzZDogMFxuICAgIH0pO1xuXG4gICAgX2JhdGNoLl9maW5hbC5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoZWxTdGF0ZS5jYWNoZS51bmNhY2hlID0gMSkgJiYgX2FwcGx5SW5saW5lU3R5bGVzKGVsU3RhdGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBkaXNwbGF5SXNOb25lID0gZ2V0UHJvcChcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xuXG4gIGlmICghZWxTdGF0ZS5pc1Zpc2libGUgfHwgZGlzcGxheUlzTm9uZSkge1xuICAgIGRpc3BsYXlJc05vbmUgJiYgKF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgW1wiZGlzcGxheVwiXSkuZGlzcGxheSA9IGZhbGxiYWNrTm9kZS5kaXNwbGF5KTtcbiAgICBlbFN0YXRlLm1hdHJpeCA9IGZhbGxiYWNrTm9kZS5tYXRyaXg7XG4gICAgZWxTdGF0ZS53aWR0aCA9IHdpZHRoID0gZWxTdGF0ZS53aWR0aCB8fCBmYWxsYmFja05vZGUud2lkdGg7XG4gICAgZWxTdGF0ZS5oZWlnaHQgPSBoZWlnaHQgPSBlbFN0YXRlLmhlaWdodCB8fCBmYWxsYmFja05vZGUuaGVpZ2h0O1xuICB9XG5cbiAgX3JlY29yZElubGluZVN0eWxlcyhlbFN0YXRlLCBfYWJzb2x1dGVQcm9wcyk7XG5cbiAgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3R5bGVbX2Fic29sdXRlUHJvcHNbaV1dID0gY3NbX2Fic29sdXRlUHJvcHNbaV1dOyAvLyByZWNvcmQgcGFkZGluZ3MgYXMgcHgtYmFzZWQgYmVjYXVzZSBpZiByZW1vdmVkIGZyb20gZ3JpZCwgcGVyY2VudGFnZS1iYXNlZCBvbmVzIGNvdWxkIGJlIGFsdGVyZWQuXG4gIH1cblxuICBzdHlsZS5ncmlkQXJlYSA9IFwiMSAvIDEgLyAxIC8gMVwiO1xuICBzdHlsZS50cmFuc2l0aW9uID0gXCJub25lXCI7XG4gIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICBzdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gIHN0eWxlLnRvcCB8fCAoc3R5bGUudG9wID0gXCIwcHhcIik7XG4gIHN0eWxlLmxlZnQgfHwgKHN0eWxlLmxlZnQgPSBcIjBweFwiKTtcblxuICBpZiAodW5jYWNoZSkge1xuICAgIHJlc3VsdCA9IG5ldyBFbGVtZW50U3RhdGUoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgcmVzdWx0ID0gX2NvcHkoZWxTdGF0ZSwgX2VtcHR5T2JqKTtcbiAgICByZXN1bHQucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICBpZiAoZWxTdGF0ZS5zaW1wbGUpIHtcbiAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmVzdWx0Lm1hdHJpeCA9IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQubWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gX2ZpdChyZXN1bHQsIGVsU3RhdGUsIHRydWUpO1xuICBlbFN0YXRlLnggPSBfY2xvc2VzdFRlbnRoKHJlc3VsdC54LCAwLjAxKTtcbiAgZWxTdGF0ZS55ID0gX2Nsb3Nlc3RUZW50aChyZXN1bHQueSwgMC4wMSk7XG4gIHJldHVybiBlbGVtZW50O1xufSxcbiAgICBfZmlsdGVyQ29tcHMgPSBmdW5jdGlvbiBfZmlsdGVyQ29tcHMoY29tcHMsIHRhcmdldHMpIHtcbiAgaWYgKHRhcmdldHMgIT09IHRydWUpIHtcbiAgICB0YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgY29tcHMgPSBjb21wcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0YXJnZXRzLmluZGV4T2YoKGMuc2QgPCAwID8gYy5iIDogYy5hKS5lbGVtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjLnQuX2dzYXAucmVuZGVyVHJhbnNmb3JtKDEpOyAvLyB3ZSBtdXN0IGZvcmNlIHRyYW5zZm9ybXMgdG8gcmVuZGVyIG9uIGFueXRoaW5nIHRoYXQgaXNuJ3QgYmVpbmcgbWFkZSBwb3NpdGlvbjogYWJzb2x1dGUsIG90aGVyd2lzZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gaGFwcGVucyBhbmQgdGhlbiB3aGVuIGFuaW1hdGlvbiBiZWdpbnMgaXQgYXBwbGllcyB0cmFuc2Zvcm1zIHdoaWNoIGNhbiBjcmVhdGUgYSBuZXcgc3RhY2tpbmcgY29udGV4dCwgdGhyb3dpbmcgb2ZmIHBvc2l0aW9uaW5nIVxuXG5cbiAgICAgICAgaWYgKGMuYi5pc1Zpc2libGUpIHtcbiAgICAgICAgICBjLnQuc3R5bGUud2lkdGggPSBjLmIud2lkdGggKyBcInB4XCI7IC8vIG90aGVyd2lzZSB0aGluZ3MgY2FuIGNvbGxhcHNlIHdoZW4gY29udGVudHMgYXJlIG1hZGUgcG9zaXRpb246IGFic29sdXRlLlxuXG4gICAgICAgICAgYy50LnN0eWxlLmhlaWdodCA9IGMuYi5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb21wcztcbn0sXG4gICAgX21ha2VDb21wc0Fic29sdXRlID0gZnVuY3Rpb24gX21ha2VDb21wc0Fic29sdXRlKGNvbXBzKSB7XG4gIHJldHVybiBfb3JkZXJCeURPTURlcHRoKGNvbXBzLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIChjLmEuaXNWaXNpYmxlIHx8IGMuYi5pc1Zpc2libGUpICYmIF9tYWtlQWJzb2x1dGUoYy5zZCA8IDAgPyBjLmIgOiBjLmEsIGMuYiwgMSk7XG4gIH0pO1xufSxcbiAgICBfZmluZEVsU3RhdGVJblN0YXRlID0gZnVuY3Rpb24gX2ZpbmRFbFN0YXRlSW5TdGF0ZShzdGF0ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIG90aGVyICYmIHN0YXRlLmlkTG9va3VwW19wYXJzZUVsZW1lbnRTdGF0ZShvdGhlcikuaWRdIHx8IHN0YXRlLmVsZW1lbnRTdGF0ZXNbMF07XG59LFxuICAgIF9wYXJzZUVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIF9wYXJzZUVsZW1lbnRTdGF0ZShlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGVsT3JOb2RlIGluc3RhbmNlb2YgRWxlbWVudFN0YXRlID8gZWxPck5vZGUgOiBlbE9yTm9kZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IF9maW5kRWxTdGF0ZUluU3RhdGUoZWxPck5vZGUsIG90aGVyKSA6IG5ldyBFbGVtZW50U3RhdGUodHlwZW9mIGVsT3JOb2RlID09PSBcInN0cmluZ1wiID8gX2dldEVsKGVsT3JOb2RlKSB8fCBjb25zb2xlLndhcm4oZWxPck5vZGUgKyBcIiBub3QgZm91bmRcIikgOiBlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSk7XG59LFxuICAgIF9yZWNvcmRQcm9wcyA9IGZ1bmN0aW9uIF9yZWNvcmRQcm9wcyhlbFN0YXRlLCBwcm9wcykge1xuICB2YXIgZ2V0UHJvcCA9IGdzYXAuZ2V0UHJvcGVydHkoZWxTdGF0ZS5lbGVtZW50LCBudWxsLCBcIm5hdGl2ZVwiKSxcbiAgICAgIG9iaiA9IGVsU3RhdGUucHJvcHMgPSB7fSxcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9ialtwcm9wc1tpXV0gPSAoZ2V0UHJvcChwcm9wc1tpXSkgKyBcIlwiKS50cmltKCk7XG4gIH1cblxuICBvYmouekluZGV4ICYmIChvYmouekluZGV4ID0gcGFyc2VGbG9hdChvYmouekluZGV4KSB8fCAwKTtcbiAgcmV0dXJuIGVsU3RhdGU7XG59LFxuICAgIF9hcHBseVByb3BzID0gZnVuY3Rpb24gX2FwcGx5UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZSB8fCBlbGVtZW50LFxuICAgICAgLy8gY291bGQgcGFzcyBpbiBhIHZhcnMgb2JqZWN0LlxuICBwO1xuXG4gIGZvciAocCBpbiBwcm9wcykge1xuICAgIHN0eWxlW3BdID0gcHJvcHNbcF07XG4gIH1cbn0sXG4gICAgX2dldElEID0gZnVuY3Rpb24gX2dldElEKGVsKSB7XG4gIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtZmxpcC1pZFwiKTtcbiAgaWQgfHwgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1mbGlwLWlkXCIsIGlkID0gXCJhdXRvLVwiICsgX2lkKyspO1xuICByZXR1cm4gaWQ7XG59LFxuICAgIF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzID0gZnVuY3Rpb24gX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMoZWxTdGF0ZXMpIHtcbiAgcmV0dXJuIGVsU3RhdGVzLm1hcChmdW5jdGlvbiAoZWxTdGF0ZSkge1xuICAgIHJldHVybiBlbFN0YXRlLmVsZW1lbnQ7XG4gIH0pO1xufSxcbiAgICBfaGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiBfaGFuZGxlQ2FsbGJhY2soY2FsbGJhY2ssIGVsU3RhdGVzLCB0bCkge1xuICByZXR1cm4gY2FsbGJhY2sgJiYgZWxTdGF0ZXMubGVuZ3RoICYmIHRsLmFkZChjYWxsYmFjayhfZWxlbWVudHNGcm9tRWxlbWVudFN0YXRlcyhlbFN0YXRlcyksIHRsLCBuZXcgRmxpcFN0YXRlKGVsU3RhdGVzLCAwLCB0cnVlKSksIDApO1xufSxcbiAgICBfZml0ID0gZnVuY3Rpb24gX2ZpdChmcm9tU3RhdGUsIHRvU3RhdGUsIHNjYWxlLCBhcHBseVByb3BzLCBmaXRDaGlsZCwgdmFycykge1xuICB2YXIgZWxlbWVudCA9IGZyb21TdGF0ZS5lbGVtZW50LFxuICAgICAgY2FjaGUgPSBmcm9tU3RhdGUuY2FjaGUsXG4gICAgICBwYXJlbnQgPSBmcm9tU3RhdGUucGFyZW50LFxuICAgICAgeCA9IGZyb21TdGF0ZS54LFxuICAgICAgeSA9IGZyb21TdGF0ZS55LFxuICAgICAgd2lkdGggPSB0b1N0YXRlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdG9TdGF0ZS5oZWlnaHQsXG4gICAgICBzY2FsZVggPSB0b1N0YXRlLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IHRvU3RhdGUuc2NhbGVZLFxuICAgICAgcm90YXRpb24gPSB0b1N0YXRlLnJvdGF0aW9uLFxuICAgICAgYm91bmRzID0gdG9TdGF0ZS5ib3VuZHMsXG4gICAgICBjc3NUZXh0ID0gdmFycyAmJiBlbGVtZW50LnN0eWxlLmNzc1RleHQsXG4gICAgICB0cmFuc2Zvcm0gPSB2YXJzICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSxcbiAgICAgIGRpbWVuc2lvblN0YXRlID0gZnJvbVN0YXRlLFxuICAgICAgX3RvU3RhdGUkbWF0cml4ID0gdG9TdGF0ZS5tYXRyaXgsXG4gICAgICBlID0gX3RvU3RhdGUkbWF0cml4LmUsXG4gICAgICBmID0gX3RvU3RhdGUkbWF0cml4LmYsXG4gICAgICBkZWVwID0gZnJvbVN0YXRlLmJvdW5kcy53aWR0aCAhPT0gYm91bmRzLndpZHRoIHx8IGZyb21TdGF0ZS5ib3VuZHMuaGVpZ2h0ICE9PSBib3VuZHMuaGVpZ2h0IHx8IGZyb21TdGF0ZS5zY2FsZVggIT09IHNjYWxlWCB8fCBmcm9tU3RhdGUuc2NhbGVZICE9PSBzY2FsZVkgfHwgZnJvbVN0YXRlLnJvdGF0aW9uICE9PSByb3RhdGlvbixcbiAgICAgIHNpbXBsZSA9ICFkZWVwICYmIGZyb21TdGF0ZS5zaW1wbGUgJiYgdG9TdGF0ZS5zaW1wbGUgJiYgIWZpdENoaWxkLFxuICAgICAgc2tld1gsXG4gICAgICBmcm9tUG9pbnQsXG4gICAgICB0b1BvaW50LFxuICAgICAgZ2V0UHJvcCxcbiAgICAgIHBhcmVudE1hdHJpeCxcbiAgICAgIG1hdHJpeCxcbiAgICAgIGJib3g7XG5cbiAgaWYgKHNpbXBsZSB8fCAhcGFyZW50KSB7XG4gICAgc2NhbGVYID0gc2NhbGVZID0gMTtcbiAgICByb3RhdGlvbiA9IHNrZXdYID0gMDtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRNYXRyaXggPSBfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeChwYXJlbnQpO1xuICAgIG1hdHJpeCA9IHBhcmVudE1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRvU3RhdGUuY3RtID8gdG9TdGF0ZS5tYXRyaXguY2xvbmUoKS5tdWx0aXBseSh0b1N0YXRlLmN0bSkgOiB0b1N0YXRlLm1hdHJpeCk7IC8vIHJvb3QgU1ZHIGVsZW1lbnRzIGhhdmUgYSBjdG0gdGhhdCB3ZSBtdXN0IGZhY3RvciBvdXQgKGZvciBleGFtcGxlLCB2aWV3Qm94OlwiMCAwIDk0IDk0XCIgd2l0aCBhIHdpZHRoIG9mIDIwMHB4IHdvdWxkIHNjYWxlIHRoZSBpbnRlcm5hbHMgYnkgMi4xMjcgYnV0IHdoZW4gd2UncmUgbWF0Y2hpbmcgdGhlIHNpemUgb2YgdGhlIHJvb3QgPHN2Zz4gZWxlbWVudCBpdHNlbGYsIHRoYXQgc2NhbGluZyBzaG91bGRuJ3QgZmFjdG9yIGluISlcblxuICAgIHJvdGF0aW9uID0gX3JvdW5kKE1hdGguYXRhbjIobWF0cml4LmIsIG1hdHJpeC5hKSAqIF9SQUQyREVHKTtcbiAgICBza2V3WCA9IF9yb3VuZChNYXRoLmF0YW4yKG1hdHJpeC5jLCBtYXRyaXguZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uKSAlIDM2MDsgLy8gaW4gdmVyeSByYXJlIGNhc2VzLCBtaW5vciByb3VuZGluZyBtaWdodCBlbmQgdXAgd2l0aCAzNjAgd2hpY2ggc2hvdWxkIGJlIDAuXG5cbiAgICBzY2FsZVggPSBNYXRoLnNxcnQoTWF0aC5wb3cobWF0cml4LmEsIDIpICsgTWF0aC5wb3cobWF0cml4LmIsIDIpKTtcbiAgICBzY2FsZVkgPSBNYXRoLnNxcnQoTWF0aC5wb3cobWF0cml4LmMsIDIpICsgTWF0aC5wb3cobWF0cml4LmQsIDIpKSAqIE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpO1xuXG4gICAgaWYgKGZpdENoaWxkKSB7XG4gICAgICBmaXRDaGlsZCA9IF90b0FycmF5KGZpdENoaWxkKVswXTtcbiAgICAgIGdldFByb3AgPSBnc2FwLmdldFByb3BlcnR5KGZpdENoaWxkKTtcbiAgICAgIGJib3ggPSBmaXRDaGlsZC5nZXRCQm94ICYmIHR5cGVvZiBmaXRDaGlsZC5nZXRCQm94ID09PSBcImZ1bmN0aW9uXCIgJiYgZml0Q2hpbGQuZ2V0QkJveCgpO1xuICAgICAgZGltZW5zaW9uU3RhdGUgPSB7XG4gICAgICAgIHNjYWxlWDogZ2V0UHJvcChcInNjYWxlWFwiKSxcbiAgICAgICAgc2NhbGVZOiBnZXRQcm9wKFwic2NhbGVZXCIpLFxuICAgICAgICB3aWR0aDogYmJveCA/IGJib3gud2lkdGggOiBNYXRoLmNlaWwocGFyc2VGbG9hdChnZXRQcm9wKFwid2lkdGhcIiwgXCJweFwiKSkpLFxuICAgICAgICBoZWlnaHQ6IGJib3ggPyBiYm94LmhlaWdodCA6IHBhcnNlRmxvYXQoZ2V0UHJvcChcImhlaWdodFwiLCBcInB4XCIpKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYWNoZS5yb3RhdGlvbiA9IHJvdGF0aW9uICsgXCJkZWdcIjtcbiAgICBjYWNoZS5za2V3WCA9IHNrZXdYICsgXCJkZWdcIjtcbiAgfVxuXG4gIGlmIChzY2FsZSkge1xuICAgIHNjYWxlWCAqPSB3aWR0aCA9PT0gZGltZW5zaW9uU3RhdGUud2lkdGggfHwgIWRpbWVuc2lvblN0YXRlLndpZHRoID8gMSA6IHdpZHRoIC8gZGltZW5zaW9uU3RhdGUud2lkdGg7IC8vIG5vdGUgaWYgd2lkdGhzIGFyZSBib3RoIDAsIHdlIHNob3VsZCBtYWtlIHNjYWxlWCAxIC0gc29tZSBlbGVtZW50cyBoYXZlIGJveC1zaXppbmcgdGhhdCBpbmNvcnBvcmF0ZXMgcGFkZGluZywgZXRjLiBhbmQgd2UgZG9uJ3Qgd2FudCBpdCB0byBjb2xsYXBzZSBpbiB0aGF0IGNhc2UuXG5cbiAgICBzY2FsZVkgKj0gaGVpZ2h0ID09PSBkaW1lbnNpb25TdGF0ZS5oZWlnaHQgfHwgIWRpbWVuc2lvblN0YXRlLmhlaWdodCA/IDEgOiBoZWlnaHQgLyBkaW1lbnNpb25TdGF0ZS5oZWlnaHQ7XG4gICAgY2FjaGUuc2NhbGVYID0gc2NhbGVYO1xuICAgIGNhY2hlLnNjYWxlWSA9IHNjYWxlWTtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9IF9jbG9zZXN0VGVudGgod2lkdGggKiBzY2FsZVggLyBkaW1lbnNpb25TdGF0ZS5zY2FsZVgsIDApO1xuICAgIGhlaWdodCA9IF9jbG9zZXN0VGVudGgoaGVpZ2h0ICogc2NhbGVZIC8gZGltZW5zaW9uU3RhdGUuc2NhbGVZLCAwKTtcbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gIH0gLy8gaWYgKGZyb21TdGF0ZS5pc0ZpeGVkKSB7IC8vIGNvbW1lbnRlZCBvdXQgYmVjYXVzZSBpdCdzIG5vdyB0YWtlbiBjYXJlIG9mIGluIGdldEdsb2JhbE1hdHJpeCgpIHdpdGggYSBmbGFnIGF0IHRoZSBlbmQuXG4gIC8vIFx0ZSAtPSBfZ2V0RG9jU2Nyb2xsTGVmdCgpO1xuICAvLyBcdGYgLT0gX2dldERvY1Njcm9sbFRvcCgpO1xuICAvLyB9XG5cblxuICBhcHBseVByb3BzICYmIF9hcHBseVByb3BzKGVsZW1lbnQsIHRvU3RhdGUucHJvcHMpO1xuXG4gIGlmIChzaW1wbGUgfHwgIXBhcmVudCkge1xuICAgIHggKz0gZSAtIGZyb21TdGF0ZS5tYXRyaXguZTtcbiAgICB5ICs9IGYgLSBmcm9tU3RhdGUubWF0cml4LmY7XG4gIH0gZWxzZSBpZiAoZGVlcCB8fCBwYXJlbnQgIT09IHRvU3RhdGUucGFyZW50KSB7XG4gICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGNhY2hlKTtcbiAgICBtYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZml0Q2hpbGQgfHwgZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICBmcm9tUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuICAgICAgeDogbWF0cml4LmUsXG4gICAgICB5OiBtYXRyaXguZlxuICAgIH0pO1xuICAgIHRvUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuICAgICAgeDogZSxcbiAgICAgIHk6IGZcbiAgICB9KTtcbiAgICB4ICs9IHRvUG9pbnQueCAtIGZyb21Qb2ludC54O1xuICAgIHkgKz0gdG9Qb2ludC55IC0gZnJvbVBvaW50Lnk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGEgZmFzdGVyL2NoZWFwZXIgYWxnb3JpdGhtIGlmIHdlJ3JlIGp1c3QgbW92aW5nIHgveVxuICAgIHBhcmVudE1hdHJpeC5lID0gcGFyZW50TWF0cml4LmYgPSAwO1xuICAgIHRvUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuICAgICAgeDogZSAtIGZyb21TdGF0ZS5tYXRyaXguZSxcbiAgICAgIHk6IGYgLSBmcm9tU3RhdGUubWF0cml4LmZcbiAgICB9KTtcbiAgICB4ICs9IHRvUG9pbnQueDtcbiAgICB5ICs9IHRvUG9pbnQueTtcbiAgfVxuXG4gIHggPSBfY2xvc2VzdFRlbnRoKHgsIDAuMDIpO1xuICB5ID0gX2Nsb3Nlc3RUZW50aCh5LCAwLjAyKTtcblxuICBpZiAodmFycyAmJiAhKHZhcnMgaW5zdGFuY2VvZiBFbGVtZW50U3RhdGUpKSB7XG4gICAgLy8gcmV2ZXJ0XG4gICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xuICB9IGVsc2Uge1xuICAgIC8vIG9yIGFwcGx5IHRoZSB0cmFuc2Zvcm0gaW1tZWRpYXRlbHlcbiAgICBjYWNoZS54ID0geCArIFwicHhcIjtcbiAgICBjYWNoZS55ID0geSArIFwicHhcIjtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICB9XG5cbiAgaWYgKHZhcnMpIHtcbiAgICB2YXJzLnggPSB4O1xuICAgIHZhcnMueSA9IHk7XG4gICAgdmFycy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHZhcnMuc2tld1ggPSBza2V3WDtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdmFycy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB2YXJzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy53aWR0aCA9IHdpZHRoO1xuICAgICAgdmFycy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnMgfHwgY2FjaGU7XG59LFxuICAgIF9wYXJzZVN0YXRlID0gZnVuY3Rpb24gX3BhcnNlU3RhdGUodGFyZ2V0c09yU3RhdGUsIHZhcnMpIHtcbiAgcmV0dXJuIHRhcmdldHNPclN0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0c09yU3RhdGUgOiBuZXcgRmxpcFN0YXRlKHRhcmdldHNPclN0YXRlLCB2YXJzKTtcbn0sXG4gICAgX2dldENoYW5naW5nRWxTdGF0ZSA9IGZ1bmN0aW9uIF9nZXRDaGFuZ2luZ0VsU3RhdGUodG9TdGF0ZSwgZnJvbVN0YXRlLCBpZCkge1xuICB2YXIgdG8xID0gdG9TdGF0ZS5pZExvb2t1cFtpZF0sXG4gICAgICB0bzIgPSB0b1N0YXRlLmFsdFtpZF07XG4gIHJldHVybiB0bzIuaXNWaXNpYmxlICYmICghKGZyb21TdGF0ZS5nZXRFbGVtZW50U3RhdGUodG8yLmVsZW1lbnQpIHx8IHRvMikuaXNWaXNpYmxlIHx8ICF0bzEuaXNWaXNpYmxlKSA/IHRvMiA6IHRvMTtcbn0sXG4gICAgX2JvZHlNZXRyaWNzID0gW10sXG4gICAgX2JvZHlQcm9wcyA9IFwid2lkdGgsaGVpZ2h0LG92ZXJmbG93WCxvdmVyZmxvd1lcIi5zcGxpdChcIixcIiksXG4gICAgX2JvZHlMb2NrZWQsXG4gICAgX2xvY2tCb2R5U2Nyb2xsID0gZnVuY3Rpb24gX2xvY2tCb2R5U2Nyb2xsKGxvY2spIHtcbiAgLy8gaWYgdGhlcmUncyBubyBzY3JvbGxiYXIsIHdlIHNob3VsZCBsb2NrIHRoYXQgc28gdGhhdCBtZWFzdXJlbWVudHMgZG9uJ3QgZ2V0IGFmZmVjdGVkIGJ5IHRlbXBvcmFyeSByZXBvc2l0aW9uaW5nLCBsaWtlIGlmIHNvbWV0aGluZyBpcyBjZW50ZXJlZCBpbiB0aGUgd2luZG93LlxuICBpZiAobG9jayAhPT0gX2JvZHlMb2NrZWQpIHtcbiAgICB2YXIgcyA9IF9ib2R5LnN0eWxlLFxuICAgICAgICB3ID0gX2JvZHkuY2xpZW50V2lkdGggPT09IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgICAgICBoID0gX2JvZHkuY2xpZW50SGVpZ2h0ID09PSB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICAgIGkgPSA0O1xuXG4gICAgaWYgKGxvY2sgJiYgKHcgfHwgaCkpIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgX2JvZHlNZXRyaWNzW2ldID0gc1tfYm9keVByb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgcy53aWR0aCA9IF9ib2R5LmNsaWVudFdpZHRoICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChoKSB7XG4gICAgICAgIHMuaGVpZ2h0ID0gX2JvZHkuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIF9ib2R5TG9ja2VkID0gbG9jaztcbiAgICB9IGVsc2UgaWYgKF9ib2R5TG9ja2VkKSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIF9ib2R5TWV0cmljc1tpXSA/IHNbX2JvZHlQcm9wc1tpXV0gPSBfYm9keU1ldHJpY3NbaV0gOiBzLnJlbW92ZVByb3BlcnR5KF9jYW1lbFRvRGFzaGVkKF9ib2R5UHJvcHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgX2JvZHlMb2NrZWQgPSBsb2NrO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZnJvbVRvID0gZnVuY3Rpb24gX2Zyb21Ubyhmcm9tU3RhdGUsIHRvU3RhdGUsIHZhcnMsIHJlbGF0aXZlKSB7XG4gIC8vIHJlbGF0aXZlIGlzIC0xIGlmIFwiZnJvbSgpXCIsIGFuZCAxIGlmIFwidG8oKVwiXG4gIGZyb21TdGF0ZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSAmJiB0b1N0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlIHx8IGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIHN0YXRlIG9iamVjdC5cIik7XG4gIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gIHZhciBfdmFycyA9IHZhcnMsXG4gICAgICBjbGVhclByb3BzID0gX3ZhcnMuY2xlYXJQcm9wcyxcbiAgICAgIG9uRW50ZXIgPSBfdmFycy5vbkVudGVyLFxuICAgICAgb25MZWF2ZSA9IF92YXJzLm9uTGVhdmUsXG4gICAgICBhYnNvbHV0ZSA9IF92YXJzLmFic29sdXRlLFxuICAgICAgYWJzb2x1dGVPbkxlYXZlID0gX3ZhcnMuYWJzb2x1dGVPbkxlYXZlLFxuICAgICAgY3VzdG9tID0gX3ZhcnMuY3VzdG9tLFxuICAgICAgZGVsYXkgPSBfdmFycy5kZWxheSxcbiAgICAgIHBhdXNlZCA9IF92YXJzLnBhdXNlZCxcbiAgICAgIHJlcGVhdCA9IF92YXJzLnJlcGVhdCxcbiAgICAgIHJlcGVhdERlbGF5ID0gX3ZhcnMucmVwZWF0RGVsYXksXG4gICAgICB5b3lvID0gX3ZhcnMueW95byxcbiAgICAgIHRvZ2dsZUNsYXNzID0gX3ZhcnMudG9nZ2xlQ2xhc3MsXG4gICAgICBuZXN0ZWQgPSBfdmFycy5uZXN0ZWQsXG4gICAgICBfekluZGV4ID0gX3ZhcnMuekluZGV4LFxuICAgICAgc2NhbGUgPSBfdmFycy5zY2FsZSxcbiAgICAgIGZhZGUgPSBfdmFycy5mYWRlLFxuICAgICAgc3RhZ2dlciA9IF92YXJzLnN0YWdnZXIsXG4gICAgICBzcGluID0gX3ZhcnMuc3BpbixcbiAgICAgIHBydW5lID0gX3ZhcnMucHJ1bmUsXG4gICAgICBwcm9wcyA9IChcInByb3BzXCIgaW4gdmFycyA/IHZhcnMgOiBmcm9tU3RhdGUpLnByb3BzLFxuICAgICAgdHdlZW5WYXJzID0gX2NvcHkodmFycywgX3Jlc2VydmVkKSxcbiAgICAgIGFuaW1hdGlvbiA9IGdzYXAudGltZWxpbmUoe1xuICAgIGRlbGF5OiBkZWxheSxcbiAgICBwYXVzZWQ6IHBhdXNlZCxcbiAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICByZXBlYXREZWxheTogcmVwZWF0RGVsYXksXG4gICAgeW95bzogeW95byxcbiAgICBkYXRhOiBcImlzRmxpcFwiXG4gIH0pLFxuICAgICAgcmVtYWluaW5nUHJvcHMgPSB0d2VlblZhcnMsXG4gICAgICBlbnRlcmluZyA9IFtdLFxuICAgICAgbGVhdmluZyA9IFtdLFxuICAgICAgY29tcHMgPSBbXSxcbiAgICAgIHN3YXBPdXRUYXJnZXRzID0gW10sXG4gICAgICBzcGluTnVtID0gc3BpbiA9PT0gdHJ1ZSA/IDEgOiBzcGluIHx8IDAsXG4gICAgICBzcGluRnVuYyA9IHR5cGVvZiBzcGluID09PSBcImZ1bmN0aW9uXCIgPyBzcGluIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzcGluTnVtO1xuICB9LFxuICAgICAgaW50ZXJydXB0ZWQgPSBmcm9tU3RhdGUuaW50ZXJydXB0ZWQgfHwgdG9TdGF0ZS5pbnRlcnJ1cHRlZCxcbiAgICAgIGFkZEZ1bmMgPSBhbmltYXRpb25bcmVsYXRpdmUgIT09IDEgPyBcInRvXCIgOiBcImZyb21cIl0sXG4gICAgICB2LFxuICAgICAgcCxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBpLFxuICAgICAgZWwsXG4gICAgICBjb21wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXRzLFxuICAgICAgZmluYWxTdGF0ZXMsXG4gICAgICBmcm9tTm9kZSxcbiAgICAgIHRvTm9kZSxcbiAgICAgIHJ1bixcbiAgICAgIGEsXG4gICAgICBiOyAvL3JlbGF0aXZlIHx8ICh0b1N0YXRlID0gKG5ldyBGbGlwU3RhdGUodG9TdGF0ZS50YXJnZXRzLCB7cHJvcHM6IHByb3BzfSkpLmZpdCh0b1N0YXRlLCBzY2FsZSkpO1xuXG5cbiAgZm9yIChwIGluIHRvU3RhdGUuaWRMb29rdXApIHtcbiAgICB0b05vZGUgPSAhdG9TdGF0ZS5hbHRbcF0gPyB0b1N0YXRlLmlkTG9va3VwW3BdIDogX2dldENoYW5naW5nRWxTdGF0ZSh0b1N0YXRlLCBmcm9tU3RhdGUsIHApO1xuICAgIGVsID0gdG9Ob2RlLmVsZW1lbnQ7XG4gICAgZnJvbU5vZGUgPSBmcm9tU3RhdGUuaWRMb29rdXBbcF07XG4gICAgZnJvbVN0YXRlLmFsdFtwXSAmJiBlbCA9PT0gZnJvbU5vZGUuZWxlbWVudCAmJiAoZnJvbVN0YXRlLmFsdFtwXS5pc1Zpc2libGUgfHwgIXRvTm9kZS5pc1Zpc2libGUpICYmIChmcm9tTm9kZSA9IGZyb21TdGF0ZS5hbHRbcF0pO1xuXG4gICAgaWYgKGZyb21Ob2RlKSB7XG4gICAgICBjb21wID0ge1xuICAgICAgICB0OiBlbCxcbiAgICAgICAgYjogZnJvbU5vZGUsXG4gICAgICAgIGE6IHRvTm9kZSxcbiAgICAgICAgc2Q6IGZyb21Ob2RlLmVsZW1lbnQgPT09IGVsID8gMCA6IHRvTm9kZS5pc1Zpc2libGUgPyAxIDogLTFcbiAgICAgIH07XG4gICAgICBjb21wcy5wdXNoKGNvbXApO1xuXG4gICAgICBpZiAoY29tcC5zZCkge1xuICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcbiAgICAgICAgICBjb21wLmIgPSB0b05vZGU7XG4gICAgICAgICAgY29tcC5hID0gZnJvbU5vZGU7XG4gICAgICAgIH0gLy8gZm9yIHN3YXBwaW5nIGVsZW1lbnRzIHRoYXQgZ290IGludGVycnVwdGVkLCB3ZSBtdXN0IHJlLXJlY29yZCB0aGUgaW5saW5lIHN0eWxlcyB0byBlbnN1cmUgdGhleSdyZSBub3QgdGFpbnRlZC4gUmVtZW1iZXIsIC5iYXRjaCgpIHBlcm1pdHMgZ2V0U3RhdGUoKSBub3QgdG8gZm9yY2UgaW4tcHJvZ3Jlc3MgZmxpcHMgdG8gdGhlaXIgZW5kIHN0YXRlLlxuXG5cbiAgICAgICAgaW50ZXJydXB0ZWQgJiYgX3JlY29yZElubGluZVN0eWxlcyhjb21wLmIsIHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzKTtcbiAgICAgICAgZmFkZSAmJiBjb21wcy5wdXNoKGNvbXAuc3dhcCA9IHtcbiAgICAgICAgICB0OiBmcm9tTm9kZS5lbGVtZW50LFxuICAgICAgICAgIGI6IGNvbXAuYixcbiAgICAgICAgICBhOiBjb21wLmEsXG4gICAgICAgICAgc2Q6IC1jb21wLnNkLFxuICAgICAgICAgIHN3YXA6IGNvbXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9mbGlwID0gZnJvbU5vZGUuZWxlbWVudC5fZmxpcCA9IF9iYXRjaCA/IF9iYXRjaC50aW1lbGluZSA6IGFuaW1hdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRvTm9kZS5pc1Zpc2libGUpIHtcbiAgICAgIGNvbXBzLnB1c2goe1xuICAgICAgICB0OiBlbCxcbiAgICAgICAgYjogX2NvcHkodG9Ob2RlLCB7XG4gICAgICAgICAgaXNWaXNpYmxlOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBhOiB0b05vZGUsXG4gICAgICAgIHNkOiAwLFxuICAgICAgICBlbnRlcmluZzogMVxuICAgICAgfSk7IC8vIHRvIGluY2x1ZGUgaXQgaW4gdGhlIFwiZW50ZXJpbmdcIiBBcnJheSBhbmQgZG8gYWJzb2x1dGUgcG9zaXRpb25pbmcgaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGVsLl9mbGlwID0gX2JhdGNoID8gX2JhdGNoLnRpbWVsaW5lIDogYW5pbWF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByb3BzICYmIChfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gdHdlZW5WYXJzW3BdID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnByb3BzW3BdO1xuICAgIH07XG4gIH0pO1xuICBjb21wcy5maW5hbFN0YXRlcyA9IGZpbmFsU3RhdGVzID0gW107XG5cbiAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIF9vcmRlckJ5RE9NRGVwdGgoY29tcHMpO1xuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKHRydWUpOyAvLyBvdGhlcndpc2UsIG1lYXN1cmVtZW50cyBtYXkgZ2V0IHRocm93biBvZmYgd2hlbiB0aGluZ3MgZ2V0IGZpdC5cbiAgICAvLyBUT0RPOiBjYWNoZSB0aGUgbWF0cml4LCBlc3BlY2lhbGx5IGZvciBwYXJlbnQgYmVjYXVzZSBpdCdsbCBwcm9iYWJseSBnZXQgcmV1c2VkIHF1aXRlIGEgYml0LCBidXQgbG9jayBpdCB0byBhIHBhcnRpY3VsYXIgY3ljbGUoPykuXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcCA9IGNvbXBzW2ldO1xuICAgICAgYSA9IGNvbXAuYTtcbiAgICAgIGIgPSBjb21wLmI7XG5cbiAgICAgIGlmIChwcnVuZSAmJiAhYS5pc0RpZmZlcmVudChiKSAmJiAhY29tcC5lbnRlcmluZykge1xuICAgICAgICAvLyBvbmx5IGZsaXAgaWYgdGhpbmdzIGNoYW5nZWQhIERvbid0IG9taXQgaXQgZnJvbSBjb21wcyBpbml0aWFsbHkgYmVjYXVzZSB0aGF0J2QgcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgYWJzb2x1dGVseSAoaWYgbmVjZXNzYXJ5KVxuICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gY29tcC50O1xuICAgICAgICBuZXN0ZWQgJiYgIShjb21wLnNkIDwgMCkgJiYgaSAmJiAoYS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpOyAvLyBtb3ZpbmcgYSBwYXJlbnQgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgY2hpbGRyZW5cblxuICAgICAgICBpZiAoYi5pc1Zpc2libGUgJiYgYS5pc1Zpc2libGUpIHtcbiAgICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcbiAgICAgICAgICAgIC8vIHN3YXBwaW5nIE9VVCAoc3dhcCBkaXJlY3Rpb24gb2YgLTEgaXMgb3V0KVxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgRWxlbWVudFN0YXRlKGVsLCBwcm9wcywgZnJvbVN0YXRlLnNpbXBsZSk7XG5cbiAgICAgICAgICAgIF9maXQoc3RhdGUsIGEsIHNjYWxlLCAwLCAwLCBzdGF0ZSk7XG5cbiAgICAgICAgICAgIHN0YXRlLm1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChlbCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHN0YXRlLmNzcyA9IGNvbXAuYi5jc3M7XG4gICAgICAgICAgICBjb21wLmEgPSBhID0gc3RhdGU7XG4gICAgICAgICAgICBmYWRlICYmIChlbC5zdHlsZS5vcGFjaXR5ID0gaW50ZXJydXB0ZWQgPyBiLm9wYWNpdHkgOiBhLm9wYWNpdHkpO1xuICAgICAgICAgICAgc3RhZ2dlciAmJiBzd2FwT3V0VGFyZ2V0cy5wdXNoKGVsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAuc2QgPiAwICYmIGZhZGUpIHtcbiAgICAgICAgICAgIC8vIHN3YXBwaW5nIElOIChzd2FwIGRpcmVjdGlvbiBvZiAxIGlzIGluKVxuICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IGludGVycnVwdGVkID8gYS5vcGFjaXR5IC0gYi5vcGFjaXR5IDogXCIwXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2ZpdChhLCBiLCBzY2FsZSwgcHJvcHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGIuaXNWaXNpYmxlICE9PSBhLmlzVmlzaWJsZSkge1xuICAgICAgICAgIC8vIGVpdGhlciBlbnRlcmluZyBvciBsZWF2aW5nIChvbmUgc2lkZSBpcyBpbnZpc2libGUpXG4gICAgICAgICAgaWYgKCFiLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gZW50ZXJpbmdcbiAgICAgICAgICAgIGEuaXNWaXNpYmxlICYmIGVudGVyaW5nLnB1c2goYSk7XG4gICAgICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gbGVhdmluZ1xuICAgICAgICAgICAgYi5jc3MgPSBhLmNzcztcbiAgICAgICAgICAgIGxlYXZpbmcucHVzaChiKTtcbiAgICAgICAgICAgIGNvbXBzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgYWJzb2x1dGUgJiYgbmVzdGVkICYmIF9maXQoYSwgYiwgc2NhbGUsIHByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgICAgZWwuc3R5bGUubWF4V2lkdGggPSBNYXRoLm1heChhLndpZHRoLCBiLndpZHRoKSArIFwicHhcIjtcbiAgICAgICAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBNYXRoLm1heChhLmhlaWdodCwgYi5oZWlnaHQpICsgXCJweFwiO1xuICAgICAgICAgIGVsLnN0eWxlLm1pbldpZHRoID0gTWF0aC5taW4oYS53aWR0aCwgYi53aWR0aCkgKyBcInB4XCI7XG4gICAgICAgICAgZWwuc3R5bGUubWluSGVpZ2h0ID0gTWF0aC5taW4oYS5oZWlnaHQsIGIuaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5lc3RlZCAmJiB0b2dnbGVDbGFzcyAmJiBlbC5jbGFzc0xpc3QuYWRkKHRvZ2dsZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgZmluYWxTdGF0ZXMucHVzaChhKTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NUYXJnZXRzO1xuXG4gICAgaWYgKHRvZ2dsZUNsYXNzKSB7XG4gICAgICBjbGFzc1RhcmdldHMgPSBmaW5hbFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgbmVzdGVkICYmIGNsYXNzVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5yZW1vdmUodG9nZ2xlQ2xhc3MpO1xuICAgICAgfSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgZGVsYXksIHNvIGRvbid0IGxlYXZlIHRoZSBjbGFzc2VzIGFwcGxpZWQgKHdlJ2xsIGRvIGl0IGluIGEgdGltZWxpbmUgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKGZhbHNlKTtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdHdlZW5WYXJzLnNjYWxlWCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBjb21wc1tpXS5hLnNjYWxlWDtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5zY2FsZVkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS5zY2FsZVk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0d2VlblZhcnMud2lkdGggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS53aWR0aCArIFwicHhcIjtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5oZWlnaHQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICB9O1xuXG4gICAgICB0d2VlblZhcnMuYXV0b1JvdW5kID0gdmFycy5hdXRvUm91bmQgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgdHdlZW5WYXJzLnggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEueCArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdHdlZW5WYXJzLnkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEueSArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdHdlZW5WYXJzLnJvdGF0aW9uID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnJvdGF0aW9uICsgKHNwaW4gPyBzcGluRnVuYyhpLCB0YXJnZXRzW2ldLCB0YXJnZXRzKSAqIDM2MCA6IDApO1xuICAgIH07XG5cbiAgICB0d2VlblZhcnMuc2tld1ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEuc2tld1g7XG4gICAgfTtcblxuICAgIHRhcmdldHMgPSBjb21wcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLnQ7XG4gICAgfSk7XG5cbiAgICBpZiAoX3pJbmRleCB8fCBfekluZGV4ID09PSAwKSB7XG4gICAgICB0d2VlblZhcnMubW9kaWZpZXJzID0ge1xuICAgICAgICB6SW5kZXg6IGZ1bmN0aW9uIHpJbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gX3pJbmRleDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHR3ZWVuVmFycy56SW5kZXggPSBfekluZGV4O1xuICAgICAgdHdlZW5WYXJzLmltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmYWRlICYmICh0d2VlblZhcnMub3BhY2l0eSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY29tcHNbaV0uc2QgPCAwID8gMCA6IGNvbXBzW2ldLnNkID4gMCA/IGNvbXBzW2ldLmEub3BhY2l0eSA6IFwiKz0wXCI7XG4gICAgfSk7XG5cbiAgICBpZiAoc3dhcE91dFRhcmdldHMubGVuZ3RoKSB7XG4gICAgICBzdGFnZ2VyID0gZ3NhcC51dGlscy5kaXN0cmlidXRlKHN0YWdnZXIpO1xuICAgICAgdmFyIGR1bW15QXJyYXkgPSB0YXJnZXRzLnNsaWNlKHN3YXBPdXRUYXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHR3ZWVuVmFycy5zdGFnZ2VyID0gZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgIHJldHVybiBzdGFnZ2VyKH5zd2FwT3V0VGFyZ2V0cy5pbmRleE9mKGVsKSA/IHRhcmdldHMuaW5kZXhPZihjb21wc1tpXS5zd2FwLnQpIDogaSwgZWwsIGR1bW15QXJyYXkpO1xuICAgICAgfTtcbiAgICB9IC8vIC8vIGZvciB0ZXN0aW5nLi4uXG4gICAgLy8gZ3NhcC5kZWxheWVkQ2FsbCh2YXJzLmRhdGEgPyA1MCA6IDEsIGZ1bmN0aW9uKCkge1xuICAgIC8vIFx0YW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvbkNvbXBsZXRlXCIsICgpID0+IF9zZXRGaW5hbFN0YXRlcyhjb21wcywgIWNsZWFyUHJvcHMpKTtcbiAgICAvLyBcdGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHR3ZWVuVmFycywgMCkucGxheSgpO1xuICAgIC8vIH0pO1xuICAgIC8vIHJldHVybjtcblxuXG4gICAgX2NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gdmFyc1tuYW1lXSAmJiBhbmltYXRpb24uZXZlbnRDYWxsYmFjayhuYW1lLCB2YXJzW25hbWVdLCB2YXJzW25hbWUgKyBcIlBhcmFtc1wiXSk7XG4gICAgfSk7IC8vIGFwcGx5IGNhbGxiYWNrcyB0byB0aGUgdGltZWxpbmUsIG5vdCB0d2VlbnMgKGJlY2F1c2UgXCJjdXN0b21cIiB0aW1pbmcgY2FuIG1ha2UgbXVsdGlwbGUgdHdlZW5zKVxuXG5cbiAgICBpZiAoY3VzdG9tICYmIHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAvLyBidXN0IG91dCB0aGUgY3VzdG9tIHByb3BlcnRpZXMgYXMgdGhlaXIgb3duIHR3ZWVucyBzbyB0aGV5IGNhbiB1c2UgZGlmZmVyZW50IGVhc2VzLCBkdXJhdGlvbnMsIGV0Yy5cbiAgICAgIHJlbWFpbmluZ1Byb3BzID0gX2NvcHkodHdlZW5WYXJzLCBfcmVzZXJ2ZWQpO1xuXG4gICAgICBpZiAoXCJzY2FsZVwiIGluIGN1c3RvbSkge1xuICAgICAgICBjdXN0b20uc2NhbGVYID0gY3VzdG9tLnNjYWxlWSA9IGN1c3RvbS5zY2FsZTtcbiAgICAgICAgZGVsZXRlIGN1c3RvbS5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChwIGluIGN1c3RvbSkge1xuICAgICAgICB2ID0gX2NvcHkoY3VzdG9tW3BdLCBfZml0UmVzZXJ2ZWQpO1xuICAgICAgICB2W3BdID0gdHdlZW5WYXJzW3BdO1xuICAgICAgICAhKFwiZHVyYXRpb25cIiBpbiB2KSAmJiBcImR1cmF0aW9uXCIgaW4gdHdlZW5WYXJzICYmICh2LmR1cmF0aW9uID0gdHdlZW5WYXJzLmR1cmF0aW9uKTtcbiAgICAgICAgdi5zdGFnZ2VyID0gdHdlZW5WYXJzLnN0YWdnZXI7XG4gICAgICAgIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHYsIDApO1xuICAgICAgICBkZWxldGUgcmVtYWluaW5nUHJvcHNbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldHMubGVuZ3RoIHx8IGxlYXZpbmcubGVuZ3RoIHx8IGVudGVyaW5nLmxlbmd0aCkge1xuICAgICAgdG9nZ2xlQ2xhc3MgJiYgYW5pbWF0aW9uLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdG9nZ2xlQ2xhc3MoY2xhc3NUYXJnZXRzLCB0b2dnbGVDbGFzcywgYW5pbWF0aW9uLl96VGltZSA8IDAgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG4gICAgICB9LCAwKSAmJiAhcGF1c2VkICYmIF90b2dnbGVDbGFzcyhjbGFzc1RhcmdldHMsIHRvZ2dsZUNsYXNzLCBcImFkZFwiKTtcbiAgICAgIHRhcmdldHMubGVuZ3RoICYmIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHJlbWFpbmluZ1Byb3BzLCAwKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlQ2FsbGJhY2sob25FbnRlciwgZW50ZXJpbmcsIGFuaW1hdGlvbik7XG5cbiAgICBfaGFuZGxlQ2FsbGJhY2sob25MZWF2ZSwgbGVhdmluZywgYW5pbWF0aW9uKTtcblxuICAgIHZhciBiYXRjaFRsID0gX2JhdGNoICYmIF9iYXRjaC50aW1lbGluZTtcblxuICAgIGlmIChiYXRjaFRsKSB7XG4gICAgICBiYXRjaFRsLmFkZChhbmltYXRpb24sIDApO1xuXG4gICAgICBfYmF0Y2guX2ZpbmFsLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NldEZpbmFsU3RhdGVzKGNvbXBzLCAhY2xlYXJQcm9wcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBlbmRUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uKCk7XG4gICAgYW5pbWF0aW9uLmNhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZvcndhcmQgPSBhbmltYXRpb24udGltZSgpID49IGVuZFRpbWU7XG4gICAgICBmb3J3YXJkICYmICFiYXRjaFRsICYmIF9zZXRGaW5hbFN0YXRlcyhjb21wcywgIWNsZWFyUHJvcHMpO1xuICAgICAgdG9nZ2xlQ2xhc3MgJiYgX3RvZ2dsZUNsYXNzKGNsYXNzVGFyZ2V0cywgdG9nZ2xlQ2xhc3MsIGZvcndhcmQgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG4gICAgfSk7XG4gIH07XG5cbiAgYWJzb2x1dGVPbkxlYXZlICYmIChhYnNvbHV0ZSA9IGNvbXBzLmZpbHRlcihmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiAhY29tcC5zZCAmJiAhY29tcC5hLmlzVmlzaWJsZSAmJiBjb21wLmIuaXNWaXNpYmxlO1xuICB9KS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5hLmVsZW1lbnQ7XG4gIH0pKTtcblxuICBpZiAoX2JhdGNoKSB7XG4gICAgdmFyIF9iYXRjaCRfYWJzO1xuXG4gICAgYWJzb2x1dGUgJiYgKF9iYXRjaCRfYWJzID0gX2JhdGNoLl9hYnMpLnB1c2guYXBwbHkoX2JhdGNoJF9hYnMsIF9maWx0ZXJDb21wcyhjb21wcywgYWJzb2x1dGUpKTtcblxuICAgIF9iYXRjaC5fcnVuLnB1c2gocnVuKTtcbiAgfSBlbHNlIHtcbiAgICBhYnNvbHV0ZSAmJiBfbWFrZUNvbXBzQWJzb2x1dGUoX2ZpbHRlckNvbXBzKGNvbXBzLCBhYnNvbHV0ZSkpOyAvLyB3aGVuIG1ha2luZyBhYnNvbHV0ZSwgd2UgbXVzdCBnbyBpbiBhIHZlcnkgcGFydGljdWxhciBvcmRlciBzbyB0aGF0IGRvY3VtZW50IGZsb3cgY2hhbmdlcyBkb24ndCBhZmZlY3QgdGhpbmdzLiBEb24ndCBtYWtlIGl0IHZpc2libGUgaWYgYm90aCB0aGUgYmVmb3JlIGFuZCBhZnRlciBzdGF0ZXMgYXJlIGludmlzaWJsZSEgVGhlcmUncyBubyBwb2ludCwgYW5kIGl0IGNvdWxkIG1ha2UgdGhpbmdzIGFwcGVhciB2aXNpYmxlIGR1cmluZyB0aGUgZmxpcCB0aGF0IHNob3VsZG4ndCBiZS5cblxuICAgIHJ1bigpO1xuICB9XG5cbiAgdmFyIGFuaW0gPSBfYmF0Y2ggPyBfYmF0Y2gudGltZWxpbmUgOiBhbmltYXRpb247XG5cbiAgYW5pbS5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9raWxsRmxpcChhbmltLCAxKTtcbiAgfTsgLy8gYSBGbGlwIHRpbWVsaW5lIHNob3VsZCBiZWhhdmUgdmVyeSBkaWZmZXJlbnQgd2hlbiByZXZlcnRpbmcgLSBpdCBzaG91bGQgYWN0dWFsbHkganVtcCB0byB0aGUgZW5kIHNvIHRoYXQgc3R5bGVzIGdldCBjbGVhcmVkIG91dC5cblxuXG4gIHJldHVybiBhbmltO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdCh0bCkge1xuICB0bC52YXJzLm9uSW50ZXJydXB0ICYmIHRsLnZhcnMub25JbnRlcnJ1cHQuYXBwbHkodGwsIHRsLnZhcnMub25JbnRlcnJ1cHRQYXJhbXMgfHwgW10pO1xuICB0bC5nZXRDaGlsZHJlbih0cnVlLCBmYWxzZSwgdHJ1ZSkuZm9yRWFjaChfaW50ZXJydXB0KTtcbn0sXG4gICAgX2tpbGxGbGlwID0gZnVuY3Rpb24gX2tpbGxGbGlwKHRsLCBhY3Rpb24pIHtcbiAgLy8gYWN0aW9uOiAwID0gbm90aGluZywgMSA9IGNvbXBsZXRlLCAyID0gb25seSBraWxsIChkb24ndCBjb21wbGV0ZSlcbiAgaWYgKHRsICYmIHRsLnByb2dyZXNzKCkgPCAxICYmICF0bC5wYXVzZWQoKSkge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIF9pbnRlcnJ1cHQodGwpO1xuXG4gICAgICBhY3Rpb24gPCAyICYmIHRsLnByb2dyZXNzKDEpOyAvLyB3ZSBzaG91bGQgYWxzbyBraWxsIGl0IGluIGNhc2UgaXQgd2FzIGFkZGVkIHRvIGEgcGFyZW50IHRpbWVsaW5lLlxuXG4gICAgICB0bC5raWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG4gICAgX2NyZWF0ZUxvb2t1cCA9IGZ1bmN0aW9uIF9jcmVhdGVMb29rdXAoc3RhdGUpIHtcbiAgdmFyIGxvb2t1cCA9IHN0YXRlLmlkTG9va3VwID0ge30sXG4gICAgICBhbHQgPSBzdGF0ZS5hbHQgPSB7fSxcbiAgICAgIGVsU3RhdGVzID0gc3RhdGUuZWxlbWVudFN0YXRlcyxcbiAgICAgIGkgPSBlbFN0YXRlcy5sZW5ndGgsXG4gICAgICBlbFN0YXRlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbFN0YXRlID0gZWxTdGF0ZXNbaV07XG4gICAgbG9va3VwW2VsU3RhdGUuaWRdID8gYWx0W2VsU3RhdGUuaWRdID0gZWxTdGF0ZSA6IGxvb2t1cFtlbFN0YXRlLmlkXSA9IGVsU3RhdGU7XG4gIH1cbn07XG5cbnZhciBGbGlwU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGbGlwU3RhdGUodGFyZ2V0cywgdmFycywgdGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICB0aGlzLnByb3BzID0gdmFycyAmJiB2YXJzLnByb3BzO1xuICAgIHRoaXMuc2ltcGxlID0gISEodmFycyAmJiB2YXJzLnNpbXBsZSk7XG5cbiAgICBpZiAodGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICAgIHRoaXMudGFyZ2V0cyA9IF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzKHRhcmdldHMpO1xuICAgICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGFyZ2V0cztcblxuICAgICAgX2NyZWF0ZUxvb2t1cCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgICB2YXIgc29mdCA9IHZhcnMgJiYgKHZhcnMua2lsbCA9PT0gZmFsc2UgfHwgdmFycy5iYXRjaCAmJiAhdmFycy5raWxsKTtcbiAgICAgIF9iYXRjaCAmJiAhc29mdCAmJiBfYmF0Y2guX2tpbGwucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlKHNvZnQgfHwgISFfYmF0Y2gpOyAvLyB3aGVuIGJhdGNoaW5nLCBkb24ndCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwcyB0byB0aGVpciBlbmQ7IHdlIG5lZWQgdG8gZG8gdGhhdCBBRlRFUiBhbGwgZ2V0U3RhdGVzKCkgYXJlIGNhbGxlZC5cbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRmxpcFN0YXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNvZnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGhpcy50YXJnZXRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFN0YXRlKGVsLCBfdGhpcy5wcm9wcywgX3RoaXMuc2ltcGxlKTtcbiAgICB9KTtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICB0aGlzLmludGVycnVwdChzb2Z0KTtcbiAgICB0aGlzLnJlY29yZElubGluZVN0eWxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMudGFyZ2V0cy5sZW5ndGggPSB0aGlzLmVsZW1lbnRTdGF0ZXMubGVuZ3RoID0gMDtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZml0ID0gZnVuY3Rpb24gZml0KHN0YXRlLCBzY2FsZSwgbmVzdGVkKSB7XG4gICAgdmFyIGVsU3RhdGVzSW5PcmRlciA9IF9vcmRlckJ5RE9NRGVwdGgodGhpcy5lbGVtZW50U3RhdGVzLnNsaWNlKDApLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHRvRWxTdGF0ZXMgPSAoc3RhdGUgfHwgdGhpcykuaWRMb29rdXAsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBmcm9tTm9kZSxcbiAgICAgICAgdG9Ob2RlO1xuXG4gICAgZm9yICg7IGkgPCBlbFN0YXRlc0luT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyb21Ob2RlID0gZWxTdGF0ZXNJbk9yZGVyW2ldO1xuICAgICAgbmVzdGVkICYmIChmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKSk7IC8vIG1vdmluZyBhIHBhcmVudCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiBjaGlsZHJlblxuXG4gICAgICB0b05vZGUgPSB0b0VsU3RhdGVzW2Zyb21Ob2RlLmlkXTtcbiAgICAgIHRvTm9kZSAmJiBfZml0KGZyb21Ob2RlLCB0b05vZGUsIHNjYWxlLCB0cnVlLCAwLCBmcm9tTm9kZSk7XG4gICAgICBmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgIHZhciBlcyA9IHRoaXMuZ2V0RWxlbWVudFN0YXRlKGVsZW1lbnQpIHx8IF9lbXB0eU9iajtcblxuICAgIHJldHVybiAocHJvcGVydHkgaW4gZXMgPyBlcyA6IGVzLnByb3BzIHx8IF9lbXB0eU9iailbcHJvcGVydHldO1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3RhdGUpIHtcbiAgICB2YXIgaSA9IHN0YXRlLnRhcmdldHMubGVuZ3RoLFxuICAgICAgICBsb29rdXAgPSB0aGlzLmlkTG9va3VwLFxuICAgICAgICBhbHQgPSB0aGlzLmFsdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGVzLFxuICAgICAgICBlczI7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlcyA9IHN0YXRlLmVsZW1lbnRTdGF0ZXNbaV07XG4gICAgICBlczIgPSBsb29rdXBbZXMuaWRdO1xuXG4gICAgICBpZiAoZXMyICYmIChlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCB8fCBhbHRbZXMuaWRdICYmIGFsdFtlcy5pZF0uZWxlbWVudCA9PT0gZXMuZWxlbWVudCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZsaXAgaWQgaXMgYWxyZWFkeSBpbiB0aGlzIEZsaXBTdGF0ZSwgcmVwbGFjZSBpdCFcbiAgICAgICAgaW5kZXggPSB0aGlzLmVsZW1lbnRTdGF0ZXMuaW5kZXhPZihlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCA/IGVzMiA6IGFsdFtlcy5pZF0pO1xuICAgICAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxLCBzdGF0ZS50YXJnZXRzW2ldKTtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVzLnNwbGljZShpbmRleCwgMSwgZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnB1c2goc3RhdGUudGFyZ2V0c1tpXSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlcy5wdXNoKGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5pbnRlcnJ1cHRlZCAmJiAodGhpcy5pbnRlcnJ1cHRlZCA9IHRydWUpO1xuICAgIHN0YXRlLnNpbXBsZSB8fCAodGhpcy5zaW1wbGUgPSBmYWxzZSk7XG5cbiAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHN0YXRlKSB7XG4gICAgdmFyIGwxID0gc3RhdGUuaWRMb29rdXAsXG4gICAgICAgIGwyID0gdGhpcy5pZExvb2t1cCxcbiAgICAgICAgdW5jaGFuZ2VkID0gW10sXG4gICAgICAgIGNoYW5nZWQgPSBbXSxcbiAgICAgICAgZW50ZXIgPSBbXSxcbiAgICAgICAgbGVhdmUgPSBbXSxcbiAgICAgICAgdGFyZ2V0cyA9IFtdLFxuICAgICAgICBhMSA9IHN0YXRlLmFsdCxcbiAgICAgICAgYTIgPSB0aGlzLmFsdCxcbiAgICAgICAgcGxhY2UgPSBmdW5jdGlvbiBwbGFjZShzMSwgczIsIGVsKSB7XG4gICAgICByZXR1cm4gKHMxLmlzVmlzaWJsZSAhPT0gczIuaXNWaXNpYmxlID8gczEuaXNWaXNpYmxlID8gZW50ZXIgOiBsZWF2ZSA6IHMxLmlzVmlzaWJsZSA/IGNoYW5nZWQgOiB1bmNoYW5nZWQpLnB1c2goZWwpICYmIHRhcmdldHMucHVzaChlbCk7XG4gICAgfSxcbiAgICAgICAgcGxhY2VJZkRvZXNOb3RFeGlzdCA9IGZ1bmN0aW9uIHBsYWNlSWZEb2VzTm90RXhpc3QoczEsIHMyLCBlbCkge1xuICAgICAgcmV0dXJuIHRhcmdldHMuaW5kZXhPZihlbCkgPCAwICYmIHBsYWNlKHMxLCBzMiwgZWwpO1xuICAgIH0sXG4gICAgICAgIHMxLFxuICAgICAgICBzMixcbiAgICAgICAgcCxcbiAgICAgICAgZWwsXG4gICAgICAgIHMxQWx0LFxuICAgICAgICBzMkFsdCxcbiAgICAgICAgYzEsXG4gICAgICAgIGMyO1xuXG4gICAgZm9yIChwIGluIGwxKSB7XG4gICAgICBzMUFsdCA9IGExW3BdO1xuICAgICAgczJBbHQgPSBhMltwXTtcbiAgICAgIHMxID0gIXMxQWx0ID8gbDFbcF0gOiBfZ2V0Q2hhbmdpbmdFbFN0YXRlKHN0YXRlLCB0aGlzLCBwKTtcbiAgICAgIGVsID0gczEuZWxlbWVudDtcbiAgICAgIHMyID0gbDJbcF07XG5cbiAgICAgIGlmIChzMkFsdCkge1xuICAgICAgICBjMiA9IHMyLmlzVmlzaWJsZSB8fCAhczJBbHQuaXNWaXNpYmxlICYmIGVsID09PSBzMi5lbGVtZW50ID8gczIgOiBzMkFsdDtcbiAgICAgICAgYzEgPSBzMUFsdCAmJiAhczEuaXNWaXNpYmxlICYmICFzMUFsdC5pc1Zpc2libGUgJiYgYzIuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMxQWx0IDogczE7IC8vYzEuZWxlbWVudCAhPT0gYzIuZWxlbWVudCAmJiBjMS5lbGVtZW50ID09PSBzMi5lbGVtZW50ICYmIChjMiA9IHMyKTtcblxuICAgICAgICBpZiAoYzEuaXNWaXNpYmxlICYmIGMyLmlzVmlzaWJsZSAmJiBjMS5lbGVtZW50ICE9PSBjMi5lbGVtZW50KSB7XG4gICAgICAgICAgLy8gc3dhcHBpbmcsIHNvIGZvcmNlIGludG8gXCJjaGFuZ2VkXCIgYXJyYXlcbiAgICAgICAgICAoYzEuaXNEaWZmZXJlbnQoYzIpID8gY2hhbmdlZCA6IHVuY2hhbmdlZCkucHVzaChjMS5lbGVtZW50LCBjMi5lbGVtZW50KTtcbiAgICAgICAgICB0YXJnZXRzLnB1c2goYzEuZWxlbWVudCwgYzIuZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2UoYzEsIGMyLCBjMS5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMxQWx0ICYmIGMxLmVsZW1lbnQgPT09IHMxQWx0LmVsZW1lbnQgJiYgKHMxQWx0ID0gbDFbcF0pO1xuICAgICAgICBwbGFjZUlmRG9lc05vdEV4aXN0KGMxLmVsZW1lbnQgIT09IHMyLmVsZW1lbnQgJiYgczFBbHQgPyBzMUFsdCA6IGMxLCBzMiwgczIuZWxlbWVudCk7XG4gICAgICAgIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQgJiYgczFBbHQuZWxlbWVudCA9PT0gczJBbHQuZWxlbWVudCA/IHMxQWx0IDogYzEsIHMyQWx0LCBzMkFsdC5lbGVtZW50KTtcbiAgICAgICAgczFBbHQgJiYgcGxhY2VJZkRvZXNOb3RFeGlzdChzMUFsdCwgczJBbHQuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMyQWx0IDogczIsIHMxQWx0LmVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIXMyID8gZW50ZXIucHVzaChlbCkgOiAhczIuaXNEaWZmZXJlbnQoczEpID8gdW5jaGFuZ2VkLnB1c2goZWwpIDogcGxhY2UoczEsIHMyLCBlbCk7XG4gICAgICAgIHMxQWx0ICYmIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQsIHMyLCBzMUFsdC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHAgaW4gbDIpIHtcbiAgICAgIGlmICghbDFbcF0pIHtcbiAgICAgICAgbGVhdmUucHVzaChsMltwXS5lbGVtZW50KTtcbiAgICAgICAgYTJbcF0gJiYgbGVhdmUucHVzaChhMltwXS5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcbiAgICAgIHVuY2hhbmdlZDogdW5jaGFuZ2VkLFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgbGVhdmU6IGxlYXZlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVjb3JkSW5saW5lU3R5bGVzID0gZnVuY3Rpb24gcmVjb3JkSW5saW5lU3R5bGVzKCkge1xuICAgIHZhciBwcm9wcyA9IF9tZW1vaXplZFJlbW92ZVByb3BzW3RoaXMucHJvcHNdIHx8IF9yZW1vdmVQcm9wcyxcbiAgICAgICAgaSA9IHRoaXMuZWxlbWVudFN0YXRlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfcmVjb3JkSW5saW5lU3R5bGVzKHRoaXMuZWxlbWVudFN0YXRlc1tpXSwgcHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW50ZXJydXB0ID0gZnVuY3Rpb24gaW50ZXJydXB0KHNvZnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIHNvZnQgPSBET04nVCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwIGFuaW1hdGlvbnMgdG8gY29tcGxldGlvbiAobGlrZSB3aGVuIHJ1bm5pbmcgYSBiYXRjaCwgd2UgY2FuJ3QgaW1tZWRpYXRlbHkga2lsbCBmbGlwcyB3aGVuIGdldHRpbmcgc3RhdGVzIGJlY2F1c2UgaXQgY291bGQgY29udGFtaW5hdGUgcG9zaXRpb25pbmcgYW5kIG90aGVyIC5nZXRTdGF0ZSgpIGNhbGxzIHRoYXQgd2lsbCBydW4gaW4gdGhlIGJhdGNoICh3ZSBraWxsIEFGVEVSIGFsbCB0aGUgLmdldFN0YXRlKCkgY2FsbHMgY29tcGxldGUpLlxuICAgIHZhciB0aW1lbGluZXMgPSBbXTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHRsID0gdC5fZmxpcCxcbiAgICAgICAgICBmb3VuZEluUHJvZ3Jlc3MgPSBfa2lsbEZsaXAodGwsIHNvZnQgPyAwIDogMSk7XG5cbiAgICAgIHNvZnQgJiYgZm91bmRJblByb2dyZXNzICYmIHRpbWVsaW5lcy5pbmRleE9mKHRsKSA8IDAgJiYgdGwuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9KTtcbiAgICAgIGZvdW5kSW5Qcm9ncmVzcyAmJiB0aW1lbGluZXMucHVzaCh0bCk7XG4gICAgfSk7XG4gICAgIXNvZnQgJiYgdGltZWxpbmVzLmxlbmd0aCAmJiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTsgLy8gaWYgd2UgZm91bmQgYW4gaW4tcHJvZ3Jlc3MgRmxpcCBhbmltYXRpb24sIHdlIG11c3QgcmVjb3JkIGFsbCB0aGUgdmFsdWVzIGluIHRoZWlyIGN1cnJlbnQgc3RhdGUgYXQgdGhhdCBwb2ludCBCVVQgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgaXNWaXNpYmxlIHZhbHVlIEFGVEVSIHB1c2hpbmcgdGhhdCBmbGlwIHRvIGNvbXBsZXRpb24gc28gdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBlbnRlcmluZyBvciBsZWF2aW5nIHdpbGwgcG9wdWxhdGUgdGhvc2UgQXJyYXlzIHByb3Blcmx5LlxuXG4gICAgdGhpcy5pbnRlcnJ1cHRlZCB8fCAodGhpcy5pbnRlcnJ1cHRlZCA9ICEhdGltZWxpbmVzLmxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZWxlbWVudFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlcykge1xuICAgICAgdmFyIGIgPSBlcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZXMuaXNWaXNpYmxlID0gISEoYi53aWR0aCB8fCBiLmhlaWdodCB8fCBiLnRvcCB8fCBiLmxlZnQpO1xuICAgICAgZXMudW5jYWNoZSA9IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIGdldEVsZW1lbnRTdGF0ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YXRlc1t0aGlzLnRhcmdldHMuaW5kZXhPZihfZ2V0RWwoZWxlbWVudCkpXTtcbiAgfTtcblxuICBfcHJvdG8ubWFrZUFic29sdXRlID0gZnVuY3Rpb24gbWFrZUFic29sdXRlKCkge1xuICAgIHJldHVybiBfb3JkZXJCeURPTURlcHRoKHRoaXMuZWxlbWVudFN0YXRlcy5zbGljZSgwKSwgdHJ1ZSwgdHJ1ZSkubWFwKF9tYWtlQWJzb2x1dGUpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwU3RhdGU7XG59KCk7XG5cbnZhciBFbGVtZW50U3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50U3RhdGUoZWxlbWVudCwgcHJvcHMsIHNpbXBsZSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGUocHJvcHMsIHNpbXBsZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEVsZW1lbnRTdGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0RpZmZlcmVudCA9IGZ1bmN0aW9uIGlzRGlmZmVyZW50KHN0YXRlKSB7XG4gICAgdmFyIGIxID0gdGhpcy5ib3VuZHMsXG4gICAgICAgIGIyID0gc3RhdGUuYm91bmRzO1xuICAgIHJldHVybiBiMS50b3AgIT09IGIyLnRvcCB8fCBiMS5sZWZ0ICE9PSBiMi5sZWZ0IHx8IGIxLndpZHRoICE9PSBiMi53aWR0aCB8fCBiMS5oZWlnaHQgIT09IGIyLmhlaWdodCB8fCAhdGhpcy5tYXRyaXguZXF1YWxzKHN0YXRlLm1hdHJpeCkgfHwgdGhpcy5vcGFjaXR5ICE9PSBzdGF0ZS5vcGFjaXR5IHx8IHRoaXMucHJvcHMgJiYgc3RhdGUucHJvcHMgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcykgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8yLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgc2ltcGxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBlbGVtZW50ID0gc2VsZi5lbGVtZW50LFxuICAgICAgICBnZXRQcm9wID0gZ3NhcC5nZXRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgICAgY2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCksXG4gICAgICAgIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3ggJiYgdHlwZW9mIGVsZW1lbnQuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBlbGVtZW50LmdldEJCb3goKSxcbiAgICAgICAgbSA9IHNpbXBsZSA/IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpIDogZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2VsZi5nZXRQcm9wID0gZ2V0UHJvcDtcbiAgICBzZWxmLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHNlbGYuaWQgPSBfZ2V0SUQoZWxlbWVudCk7XG4gICAgc2VsZi5tYXRyaXggPSBtO1xuICAgIHNlbGYuY2FjaGUgPSBjYWNoZTtcbiAgICBzZWxmLmJvdW5kcyA9IGJvdW5kcztcbiAgICBzZWxmLmlzVmlzaWJsZSA9ICEhKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0IHx8IGJvdW5kcy5sZWZ0IHx8IGJvdW5kcy50b3ApO1xuICAgIHNlbGYuZGlzcGxheSA9IGdldFByb3AoXCJkaXNwbGF5XCIpO1xuICAgIHNlbGYucG9zaXRpb24gPSBnZXRQcm9wKFwicG9zaXRpb25cIik7XG4gICAgc2VsZi5wYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgc2VsZi54ID0gZ2V0UHJvcChcInhcIik7XG4gICAgc2VsZi55ID0gZ2V0UHJvcChcInlcIik7XG4gICAgc2VsZi5zY2FsZVggPSBjYWNoZS5zY2FsZVg7XG4gICAgc2VsZi5zY2FsZVkgPSBjYWNoZS5zY2FsZVk7XG4gICAgc2VsZi5yb3RhdGlvbiA9IGdldFByb3AoXCJyb3RhdGlvblwiKTtcbiAgICBzZWxmLnNrZXdYID0gZ2V0UHJvcChcInNrZXdYXCIpO1xuICAgIHNlbGYub3BhY2l0eSA9IGdldFByb3AoXCJvcGFjaXR5XCIpO1xuICAgIHNlbGYud2lkdGggPSBiYm94ID8gYmJveC53aWR0aCA6IF9jbG9zZXN0VGVudGgoZ2V0UHJvcChcIndpZHRoXCIsIFwicHhcIiksIDAuMDQpOyAvLyByb3VuZCB1cCB0byB0aGUgY2xvc2VzdCAwLjEgc28gdGhhdCB0ZXh0IGRvZXNuJ3Qgd3JhcC5cblxuICAgIHNlbGYuaGVpZ2h0ID0gYmJveCA/IGJib3guaGVpZ2h0IDogX2Nsb3Nlc3RUZW50aChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIiksIDAuMDQpO1xuICAgIHByb3BzICYmIF9yZWNvcmRQcm9wcyhzZWxmLCBfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpO1xuICAgIHNlbGYuY3RtID0gZWxlbWVudC5nZXRDVE0gJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiICYmIF9nZXRDVE0oZWxlbWVudCkuaW52ZXJzZSgpO1xuICAgIHNlbGYuc2ltcGxlID0gc2ltcGxlIHx8IF9yb3VuZChtLmEpID09PSAxICYmICFfcm91bmQobS5iKSAmJiAhX3JvdW5kKG0uYykgJiYgX3JvdW5kKG0uZCkgPT09IDE7IC8vIGFsbG93cyB1cyB0byBzcGVlZCB0aHJvdWdoIHNvbWUgb3RoZXIgdGFza3MgaWYgaXQncyBub3Qgc2NhbGUvcm90YXRlZFxuXG4gICAgc2VsZi51bmNhY2hlID0gMDtcbiAgfTtcblxuICByZXR1cm4gRWxlbWVudFN0YXRlO1xufSgpO1xuXG52YXIgRmxpcEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZsaXBBY3Rpb24odmFycywgYmF0Y2gpIHtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgPSBiYXRjaC50aW1lbGluZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gRmxpcEFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5nZXRTdGF0ZUJ5SWQgPSBmdW5jdGlvbiBnZXRTdGF0ZUJ5SWQoaWQpIHtcbiAgICB2YXIgaSA9IHRoaXMuc3RhdGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlc1tpXS5pZExvb2t1cFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuYmF0Y2gucmVtb3ZlKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwQWN0aW9uO1xufSgpO1xuXG52YXIgRmxpcEJhdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcEJhdGNoKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2tpbGwgPSBbXTtcbiAgICB0aGlzLl9maW5hbCA9IFtdO1xuICAgIHRoaXMuX2FicyA9IFtdO1xuICAgIHRoaXMuX3J1biA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gRmxpcEJhdGNoLnByb3RvdHlwZTtcblxuICBfcHJvdG80LmFkZCA9IGZ1bmN0aW9uIGFkZChjb25maWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5hY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLnZhcnMgPT09IGNvbmZpZztcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IG5ldyBGbGlwQWN0aW9uKHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgIGFuaW1hdGU6IGNvbmZpZ1xuICAgIH0gOiBjb25maWcsIHRoaXMpO1xuICAgIHRoaXMuYWN0aW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG80LnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShhY3Rpb24pIHtcbiAgICB2YXIgaSA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XG4gICAgaSA+PSAwICYmIHRoaXMuYWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKG1lcmdlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICBwcmV2QWN0aW9uID0gX2JhdGNoQWN0aW9uO1xuICAgIF9iYXRjaCA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHRoaXMuX2tpbGwubGVuZ3RoID0gMDtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnZhcnMuZ2V0U3RhdGUpIHtcbiAgICAgICAgYWN0aW9uLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBfYmF0Y2hBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGFjdGlvbi5zdGF0ZSA9IGFjdGlvbi52YXJzLmdldFN0YXRlKGFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlICYmIGFjdGlvbi5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnN0YXRlLmFkZChzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9iYXRjaEFjdGlvbiA9IHByZXZBY3Rpb247XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuICAgIHRoaXMua2lsbENvbmZsaWN0cygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuYW5pbWF0ZSA9IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICB0bCA9IHRoaXMudGltZWxpbmUsXG4gICAgICAgIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBmaW5hbFN0YXRlcyxcbiAgICAgICAgZW5kVGltZTtcbiAgICBfYmF0Y2ggPSB0aGlzO1xuICAgIHRsLmNsZWFyKCk7XG4gICAgdGhpcy5fYWJzLmxlbmd0aCA9IHRoaXMuX2ZpbmFsLmxlbmd0aCA9IHRoaXMuX3J1bi5sZW5ndGggPSAwO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhLnZhcnMuYW5pbWF0ZSAmJiBhLnZhcnMuYW5pbWF0ZShhKTtcbiAgICAgIHZhciBvbkVudGVyID0gYS52YXJzLm9uRW50ZXIsXG4gICAgICAgICAgb25MZWF2ZSA9IGEudmFycy5vbkxlYXZlLFxuICAgICAgICAgIHRhcmdldHMgPSBhLnRhcmdldHMsXG4gICAgICAgICAgcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoICYmIChvbkVudGVyIHx8IG9uTGVhdmUpKSB7XG4gICAgICAgIHMgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgICAgIGEuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHMuYWRkKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IHMuY29tcGFyZShGbGlwLmdldFN0YXRlKHRhcmdldHMpKTtcbiAgICAgICAgcmVzdWx0LmVudGVyLmxlbmd0aCAmJiBvbkVudGVyICYmIG9uRW50ZXIocmVzdWx0LmVudGVyKTtcbiAgICAgICAgcmVzdWx0LmxlYXZlLmxlbmd0aCAmJiBvbkxlYXZlICYmIG9uTGVhdmUocmVzdWx0LmxlYXZlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9tYWtlQ29tcHNBYnNvbHV0ZSh0aGlzLl9hYnMpO1xuXG4gICAgdGhpcy5fcnVuLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKCk7XG4gICAgfSk7XG5cbiAgICBlbmRUaW1lID0gdGwuZHVyYXRpb24oKTtcbiAgICBmaW5hbFN0YXRlcyA9IHRoaXMuX2ZpbmFsLnNsaWNlKDApO1xuICAgIHRsLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kVGltZSA8PSB0bC50aW1lKCkpIHtcbiAgICAgICAgLy8gb25seSBjYWxsIGlmIG1vdmluZyBmb3J3YXJkIGluIHRoZSB0aW1lbGluZSAoaW4gY2FzZSBpdCdzIG5lc3RlZCBpbiBhIHRpbWVsaW5lIHRoYXQgZ2V0cyByZXZlcnNlZClcbiAgICAgICAgZmluYWxTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9mb3JFYWNoQmF0Y2goX3RoaXM0LCBcIm9uQ29tcGxldGVcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5hY3Rpb25zW2ldLnZhcnMub25jZSAmJiB0aGlzLmFjdGlvbnNbaV0ua2lsbCgpO1xuICAgIH1cblxuICAgIF9mb3JFYWNoQmF0Y2godGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgdGwucmVzdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQubG9hZFN0YXRlID0gZnVuY3Rpb24gbG9hZFN0YXRlKGRvbmUpIHtcbiAgICBkb25lIHx8IChkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy52YXJzLmxvYWRTdGF0ZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXRzICYmIChjLnRhcmdldHMgPSB0YXJnZXRzKTtcbiAgICAgICAgICBpID0gcXVldWUuaW5kZXhPZihmKTtcblxuICAgICAgICAgIGlmICh+aSkge1xuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcXVldWUucHVzaChmKTtcbiAgICAgICAgYy52YXJzLmxvYWRTdGF0ZShmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZS5sZW5ndGggfHwgZG9uZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMudGFyZ2V0cyA9IGMudmFycy5zZXRTdGF0ZSAmJiBjLnZhcnMuc2V0U3RhdGUoYyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5raWxsQ29uZmxpY3RzID0gZnVuY3Rpb24ga2lsbENvbmZsaWN0cyhzb2Z0KSB7XG4gICAgdGhpcy5zdGF0ZS5pbnRlcnJ1cHQoc29mdCk7XG5cbiAgICB0aGlzLl9raWxsLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuaW50ZXJydXB0KHNvZnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5ydW4gPSBmdW5jdGlvbiBydW4oc2tpcEdldFN0YXRlLCBtZXJnZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMgIT09IF9iYXRjaCkge1xuICAgICAgc2tpcEdldFN0YXRlIHx8IHRoaXMuZ2V0U3RhdGUobWVyZ2UpO1xuICAgICAgdGhpcy5sb2FkU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzNS5fa2lsbGVkKSB7XG4gICAgICAgICAgX3RoaXM1LnNldFN0YXRlKCk7XG5cbiAgICAgICAgICBfdGhpczUuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG80LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoc3RhdGVPbmx5KSB7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHN0YXRlT25seSB8fCAodGhpcy5hY3Rpb25zLmxlbmd0aCA9IDApO1xuICB9O1xuXG4gIF9wcm90bzQuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24gZ2V0U3RhdGVCeUlkKGlkKSB7XG4gICAgdmFyIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBzO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcyA9IHRoaXMuYWN0aW9uc1tpXS5nZXRTdGF0ZUJ5SWQoaWQpO1xuXG4gICAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pZExvb2t1cFtpZF0gJiYgdGhpcy5zdGF0ZTtcbiAgfTtcblxuICBfcHJvdG80LmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuX2tpbGxlZCA9IDE7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGRlbGV0ZSBfYmF0Y2hMb29rdXBbdGhpcy5pZF07XG4gIH07XG5cbiAgcmV0dXJuIEZsaXBCYXRjaDtcbn0oKTtcblxuZXhwb3J0IHZhciBGbGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcCgpIHt9XG5cbiAgRmxpcC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXIgc3RhdGUgPSBfcGFyc2VTdGF0ZSh0YXJnZXRzLCB2YXJzKTtcblxuICAgIF9iYXRjaEFjdGlvbiAmJiBfYmF0Y2hBY3Rpb24uc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHZhcnMgJiYgdmFycy5iYXRjaCAmJiBGbGlwLmJhdGNoKHZhcnMuYmF0Y2gpLnN0YXRlLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIEZsaXAuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc3RhdGUsIHZhcnMpIHtcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcbiAgICBcImNsZWFyUHJvcHNcIiBpbiB2YXJzIHx8ICh2YXJzLmNsZWFyUHJvcHMgPSB0cnVlKTtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIC0xKTtcbiAgfTtcblxuICBGbGlwLnRvID0gZnVuY3Rpb24gdG8oc3RhdGUsIHZhcnMpIHtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIDEpO1xuICB9O1xuXG4gIEZsaXAuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycykge1xuICAgIHJldHVybiBfZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycyk7XG4gIH07XG5cbiAgRmxpcC5maXQgPSBmdW5jdGlvbiBmaXQoZnJvbUVsLCB0b0VsLCB2YXJzKSB7XG4gICAgdmFyIHYgPSB2YXJzID8gX2NvcHkodmFycywgX2ZpdFJlc2VydmVkKSA6IHt9LFxuICAgICAgICBfcmVmID0gdmFycyB8fCB2LFxuICAgICAgICBhYnNvbHV0ZSA9IF9yZWYuYWJzb2x1dGUsXG4gICAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgICAgZ2V0VmFycyA9IF9yZWYuZ2V0VmFycyxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBydW5CYWNrd2FyZHMgPSBfcmVmLnJ1bkJhY2t3YXJkcyxcbiAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZSxcbiAgICAgICAgc2ltcGxlID0gX3JlZi5zaW1wbGUsXG4gICAgICAgIGZpdENoaWxkID0gdmFycyAmJiB2YXJzLmZpdENoaWxkICYmIF9nZXRFbCh2YXJzLmZpdENoaWxkKSxcbiAgICAgICAgYmVmb3JlID0gX3BhcnNlRWxlbWVudFN0YXRlKHRvRWwsIHByb3BzLCBzaW1wbGUsIGZyb21FbCksXG4gICAgICAgIGFmdGVyID0gX3BhcnNlRWxlbWVudFN0YXRlKGZyb21FbCwgMCwgc2ltcGxlLCBiZWZvcmUpLFxuICAgICAgICBpbmxpbmVQcm9wcyA9IHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzO1xuXG4gICAgcHJvcHMgJiYgX2FwcGx5UHJvcHModiwgYmVmb3JlLnByb3BzKTtcblxuICAgIGlmIChydW5CYWNrd2FyZHMpIHtcbiAgICAgIF9yZWNvcmRJbmxpbmVTdHlsZXMoYWZ0ZXIsIGlubGluZVByb3BzKTtcblxuICAgICAgXCJpbW1lZGlhdGVSZW5kZXJcIiBpbiB2IHx8ICh2LmltbWVkaWF0ZVJlbmRlciA9IHRydWUpO1xuXG4gICAgICB2Lm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9hcHBseUlubGluZVN0eWxlcyhhZnRlcik7XG5cbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGFic29sdXRlICYmIF9tYWtlQWJzb2x1dGUoYWZ0ZXIsIGJlZm9yZSk7XG4gICAgdiA9IF9maXQoYWZ0ZXIsIGJlZm9yZSwgc2NhbGUgfHwgZml0Q2hpbGQsIHByb3BzLCBmaXRDaGlsZCwgdi5kdXJhdGlvbiB8fCBnZXRWYXJzID8gdiA6IDApO1xuICAgIHJldHVybiBnZXRWYXJzID8gdiA6IHYuZHVyYXRpb24gPyBnc2FwLnRvKGFmdGVyLmVsZW1lbnQsIHYpIDogbnVsbDtcbiAgfTtcblxuICBGbGlwLm1ha2VBYnNvbHV0ZSA9IGZ1bmN0aW9uIG1ha2VBYnNvbHV0ZSh0YXJnZXRzT3JTdGF0ZXMsIHZhcnMpIHtcbiAgICByZXR1cm4gKHRhcmdldHNPclN0YXRlcyBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IHRhcmdldHNPclN0YXRlcyA6IG5ldyBGbGlwU3RhdGUodGFyZ2V0c09yU3RhdGVzLCB2YXJzKSkubWFrZUFic29sdXRlKCk7XG4gIH07XG5cbiAgRmxpcC5iYXRjaCA9IGZ1bmN0aW9uIGJhdGNoKGlkKSB7XG4gICAgaWQgfHwgKGlkID0gXCJkZWZhdWx0XCIpO1xuICAgIHJldHVybiBfYmF0Y2hMb29rdXBbaWRdIHx8IChfYmF0Y2hMb29rdXBbaWRdID0gbmV3IEZsaXBCYXRjaChpZCkpO1xuICB9O1xuXG4gIEZsaXAua2lsbEZsaXBzT2YgPSBmdW5jdGlvbiBraWxsRmxpcHNPZih0YXJnZXRzLCBjb21wbGV0ZSkge1xuICAgICh0YXJnZXRzIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0cy50YXJnZXRzIDogX3RvQXJyYXkodGFyZ2V0cykpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIF9raWxsRmxpcCh0Ll9mbGlwLCBjb21wbGV0ZSAhPT0gZmFsc2UgPyAxIDogMik7XG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcC5pc0ZsaXBwaW5nID0gZnVuY3Rpb24gaXNGbGlwcGluZyh0YXJnZXQpIHtcbiAgICB2YXIgZiA9IEZsaXAuZ2V0QnlUYXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gISFmICYmIGYuaXNBY3RpdmUoKTtcbiAgfTtcblxuICBGbGlwLmdldEJ5VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0QnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIChfZ2V0RWwodGFyZ2V0KSB8fCBfZW1wdHlPYmopLl9mbGlwO1xuICB9O1xuXG4gIEZsaXAuZ2V0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gZ2V0RWxlbWVudFN0YXRlKHRhcmdldCwgcHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRTdGF0ZShfZ2V0RWwodGFyZ2V0KSwgcHJvcHMpO1xuICB9O1xuXG4gIEZsaXAuY29udmVydENvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH07XG5cbiAgRmxpcC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBfYm9keSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKF9ib2R5KSB7XG4gICAgICBnc2FwID0gY29yZTtcblxuICAgICAgX3NldERvYyhfYm9keSk7XG5cbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoMC4xKTtcblxuICAgICAgX2Nsb3Nlc3RUZW50aCA9IGZ1bmN0aW9uIF9jbG9zZXN0VGVudGgodmFsdWUsIGFkZCkge1xuICAgICAgICByZXR1cm4gc25hcChwYXJzZUZsb2F0KHZhbHVlKSArIGFkZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRmxpcDtcbn0oKTtcbkZsaXAudmVyc2lvbiA9IFwiMy4xMS4yXCI7IC8vIGZ1bmN0aW9uIHdoZW5JbWFnZXNMb2FkKGVsLCBmdW5jKSB7XG4vLyBcdGxldCBwZW5kaW5nID0gW10sXG4vLyBcdFx0b25Mb2FkID0gZSA9PiB7XG4vLyBcdFx0XHRwZW5kaW5nLnNwbGljZShwZW5kaW5nLmluZGV4T2YoZS50YXJnZXQpLCAxKTtcbi8vIFx0XHRcdGUudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uTG9hZCk7XG4vLyBcdFx0XHRwZW5kaW5nLmxlbmd0aCB8fCBmdW5jKCk7XG4vLyBcdFx0fTtcbi8vIFx0Z3NhcC51dGlscy50b0FycmF5KGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbWdcIiA/IGVsIDogZWwucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkuZm9yRWFjaChpbWcgPT4gaW1nLmNvbXBsZXRlIHx8IGltZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpIHx8IHBlbmRpbmcucHVzaChpbWcpKTtcbi8vIFx0cGVuZGluZy5sZW5ndGggfHwgZnVuYygpO1xuLy8gfVxuXG50eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5nc2FwICYmIHdpbmRvdy5nc2FwLnJlZ2lzdGVyUGx1Z2luKEZsaXApO1xuZXhwb3J0IHsgRmxpcCBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/Flip.js\n"));

/***/ }),

/***/ "./node_modules/gsap/MotionPathPlugin.js":
/*!***********************************************!*\
  !*** ./node_modules/gsap/MotionPathPlugin.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MotionPathPlugin\": function() { return /* binding */ MotionPathPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ MotionPathPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ \"./node_modules/gsap/utils/paths.js\");\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrix.js */ \"./node_modules/gsap/utils/matrix.js\");\n/*!\n * MotionPathPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\n\nvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n    _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n    _DEG2RAD = Math.PI / 180,\n    gsap,\n    PropTween,\n    _getUnit,\n    _toArray,\n    _getStyleSaver,\n    _reverting,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\n  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n  var l = values.length,\n      si = mode === 2 ? 0 : mode,\n      i = 0,\n      v;\n\n  for (; i < l; i++) {\n    segment[si] = v = parseFloat(values[i][property]);\n    mode === 2 && (segment[si + 1] = 0);\n    si += 2;\n  }\n\n  return segment;\n},\n    _getPropNum = function _getPropNum(target, prop, unit) {\n  return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\n},\n    _relativize = function _relativize(segment) {\n  var x = segment[0],\n      y = segment[1],\n      i;\n\n  for (i = 2; i < segment.length; i += 2) {\n    x = segment[i] += x;\n    y = segment[i + 1] += y;\n  }\n},\n    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n// _quadToCubic = points => {\n// \tlet cubic = [],\n// \t\tl = points.length - 1,\n// \t\ti = 1,\n// \t\ta, b, c;\n// \tfor (; i < l; i+=2) {\n// \t\ta = points[i-1];\n// \t\tb = points[i];\n// \t\tc = points[i+1];\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n// \t}\n// \tcubic.push(points[l]);\n// \treturn cubic;\n// },\n_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\n  if (vars.type === \"cubic\") {\n    segment = [segment];\n  } else {\n    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n    vars.relative && _relativize(segment);\n    var pointFunc = y ? _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment : _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.flatPointsToSegment;\n    segment = [pointFunc(segment, vars.curviness)];\n  }\n\n  segment = slicer(_align(segment, target, vars));\n\n  _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\n  y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n  return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n},\n    _emptyFunc = function _emptyFunc(v) {\n  return v;\n},\n    _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n    _originToPoint = function _originToPoint(element, origin, parentMatrix) {\n  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n  var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(element),\n      x = 0,\n      y = 0,\n      svg;\n\n  if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n    svg = element.viewBox.baseVal;\n    svg.width || (svg = {\n      width: +element.getAttribute(\"width\"),\n      height: +element.getAttribute(\"height\")\n    });\n  } else {\n    svg = origin && element.getBBox && element.getBBox();\n  }\n\n  if (origin && origin !== \"auto\") {\n    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n  }\n\n  return parentMatrix.apply(x || y ? m.apply({\n    x: x,\n    y: y\n  }) : {\n    x: m.e,\n    y: m.f\n  });\n},\n    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\n  var parentMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement.parentNode, true, true),\n      m = parentMatrix.clone().multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement)),\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),\n      x = _originToPoint2.x,\n      y = _originToPoint2.y,\n      p;\n\n  m.e = m.f = 0;\n\n  if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n    p = toElement.getAttribute(\"d\").match(_numExp) || [];\n    p = m.apply({\n      x: +p[0],\n      y: +p[1]\n    });\n    x += p.x;\n    y += p.y;\n  } //if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\n\n\n  if (p) {\n    p = m.apply(toElement.getBBox());\n    x -= p.x;\n    y -= p.y;\n  }\n\n  m.e = x - fromPoint.x;\n  m.f = y - fromPoint.y;\n  return m;\n},\n    _align = function _align(rawPath, target, _ref) {\n  var align = _ref.align,\n      matrix = _ref.matrix,\n      offsetX = _ref.offsetX,\n      offsetY = _ref.offsetY,\n      alignOrigin = _ref.alignOrigin;\n\n  var x = rawPath[0][0],\n      y = rawPath[0][1],\n      curX = _getPropNum(target, \"x\"),\n      curY = _getPropNum(target, \"y\"),\n      alignTarget,\n      m,\n      p;\n\n  if (!rawPath || !rawPath.length) {\n    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(\"M0,0L0,0\");\n  }\n\n  if (align) {\n    if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n    } else {\n      if (alignOrigin && alignOrigin[2] !== false) {\n        gsap.set(target, {\n          transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n        });\n      } else {\n        alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n      }\n\n      m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n      p = m.apply({\n        x: x,\n        y: y\n      });\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n    }\n  }\n\n  if (matrix) {\n    (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n  } else if (offsetX || offsetY) {\n    (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n  }\n\n  return rawPath;\n},\n    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\n  var cache = target._gsap,\n      harness = cache.harness,\n      alias = harness && harness.aliases && harness.aliases[property],\n      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n  pt.path = rawPath;\n  pt.pp = pathProperty;\n\n  plugin._props.push(prop);\n},\n    _sliceModifier = function _sliceModifier(start, end) {\n  return function (rawPath) {\n    return start || end !== 1 ? (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath)(rawPath, start, end) : rawPath;\n  };\n};\n\nvar MotionPathPlugin = {\n  version: \"3.11.2\",\n  name: \"motionPath\",\n  register: function register(core, Plugin, propTween) {\n    gsap = core;\n    _getUnit = gsap.utils.getUnit;\n    _toArray = gsap.utils.toArray;\n    _getStyleSaver = gsap.core.getStyleSaver;\n\n    _reverting = gsap.core.reverting || function () {};\n\n    PropTween = propTween;\n  },\n  init: function init(target, vars, tween) {\n    if (!gsap) {\n      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n      return false;\n    }\n\n    if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n      vars = {\n        path: vars\n      };\n    }\n\n    var rawPaths = [],\n        _vars = vars,\n        path = _vars.path,\n        autoRotate = _vars.autoRotate,\n        unitX = _vars.unitX,\n        unitY = _vars.unitY,\n        x = _vars.x,\n        y = _vars.y,\n        firstObj = path[0],\n        slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\n        rawPath,\n        p;\n\n    this.rawPaths = rawPaths;\n    this.target = target;\n    this.tween = tween;\n    this.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\n\n    if (this.rotate = autoRotate || autoRotate === 0) {\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n      this.rOffset = parseFloat(autoRotate) || 0;\n      this.radians = !!vars.useRadians;\n      this.rProp = vars.rotation || \"rotation\"; // rotation property\n\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n    }\n\n    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n      for (p in firstObj) {\n        if (!x && ~_xProps.indexOf(p)) {\n          x = p;\n        } else if (!y && ~_yProps.indexOf(p)) {\n          y = p;\n        }\n      }\n\n      if (x && y) {\n        //correlated values\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n      } else {\n        x = y = 0;\n      }\n\n      for (p in firstObj) {\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n      }\n    } else {\n      rawPath = slicer(_align((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(vars.path), target, vars));\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(rawPath, vars.resolution);\n      rawPaths.push(rawPath);\n\n      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\n      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n    }\n  },\n  render: function render(ratio, data) {\n    var rawPaths = data.rawPaths,\n        i = rawPaths.length,\n        pt = data._pt;\n\n    if (data.tween._time || !_reverting()) {\n      if (ratio > 1) {\n        ratio = 1;\n      } else if (ratio < 0) {\n        ratio = 0;\n      }\n\n      while (i--) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath)(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n      }\n\n      while (pt) {\n        pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n        pt = pt._next;\n      }\n\n      data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n    } else {\n      data.styles.revert();\n    }\n  },\n  getLength: function getLength(path) {\n    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(path)).totalLength;\n  },\n  sliceRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath,\n  getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,\n  pointsToSegment: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment,\n  stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,\n  rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,\n  transformRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath,\n  getGlobalMatrix: _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix,\n  getPositionOnPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath,\n  cacheRawPathMeasurements: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements,\n  convertToPath: function convertToPath(targets, swap) {\n    return _toArray(targets).map(function (target) {\n      return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false);\n    });\n  },\n  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\n    var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement));\n    return point ? m.apply(point) : m;\n  },\n  getAlignMatrix: _getAlignMatrix,\n  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\n    return {\n      x: m.e,\n      y: m.f\n    };\n  },\n  arrayToRawPath: function arrayToRawPath(value, vars) {\n    vars = vars || {};\n\n    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\n    vars.relative && _relativize(segment);\n    return [vars.type === \"cubic\" ? segment : (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)(segment, vars.curviness)];\n  }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9Nb3Rpb25QYXRoUGx1Z2luLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDb087QUFDaEw7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBK0MsR0FBRywrQ0FBK0M7QUFDckg7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCLDREQUFlLEdBQUcsZ0VBQW1CO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLHlFQUF3QixnRUFBZ0U7QUFDakcsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRUFBZTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxxQkFBcUIsaUVBQWU7QUFDcEMsd0NBQXdDLGlFQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyREFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxpRUFBZ0I7QUFDdEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLGlFQUFnQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsSUFBSSxpRUFBZ0I7QUFDcEIsSUFBSTtBQUNKLElBQUksaUVBQWdCO0FBQ3BCOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0NBQWdDLDZEQUFZO0FBQzVDO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRCw4REFBOEQ7O0FBRTlELHFFQUFxRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhCQUE4QiwyREFBVTtBQUN4QyxNQUFNLHlFQUF3QjtBQUM5Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrRUFBaUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcseUVBQXdCLENBQUMsMkRBQVU7QUFDOUMsR0FBRztBQUNILGdCQUFnQix5REFBWTtBQUM1QixjQUFjLHVEQUFVO0FBQ3hCLG1CQUFtQiw0REFBZTtBQUNsQyxtQkFBbUIsNERBQWU7QUFDbEMsbUJBQW1CLDREQUFlO0FBQ2xDLG9CQUFvQiw2REFBZ0I7QUFDcEMsbUJBQW1CLDZEQUFlO0FBQ2xDLHFCQUFxQiw4REFBaUI7QUFDdEMsNEJBQTRCLHFFQUF3QjtBQUNwRDtBQUNBO0FBQ0EsYUFBYSw4REFBYztBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsWUFBWSxpRUFBZSxpQ0FBaUMsaUVBQWU7QUFDM0U7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsZ0VBQWU7QUFDN0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL01vdGlvblBhdGhQbHVnaW4uanM/Y2VjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vdGlvblBhdGhQbHVnaW4gMy4xMS4yXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0UmF3UGF0aCwgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzLCBnZXRQb3NpdGlvbk9uUGF0aCwgcG9pbnRzVG9TZWdtZW50LCBmbGF0UG9pbnRzVG9TZWdtZW50LCBzbGljZVJhd1BhdGgsIHN0cmluZ1RvUmF3UGF0aCwgcmF3UGF0aFRvU3RyaW5nLCB0cmFuc2Zvcm1SYXdQYXRoLCBjb252ZXJ0VG9QYXRoIGFzIF9jb252ZXJ0VG9QYXRoIH0gZnJvbSBcIi4vdXRpbHMvcGF0aHMuanNcIjtcbmltcG9ydCB7IGdldEdsb2JhbE1hdHJpeCB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgX3hQcm9wcyA9IFwieCx0cmFuc2xhdGVYLGxlZnQsbWFyZ2luTGVmdCx4UGVyY2VudFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfeVByb3BzID0gXCJ5LHRyYW5zbGF0ZVksdG9wLG1hcmdpblRvcCx5UGVyY2VudFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgZ3NhcCxcbiAgICBQcm9wVHdlZW4sXG4gICAgX2dldFVuaXQsXG4gICAgX3RvQXJyYXksXG4gICAgX2dldFN0eWxlU2F2ZXIsXG4gICAgX3JldmVydGluZyxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheSA9IGZ1bmN0aW9uIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgdmFsdWVzLCBwcm9wZXJ0eSwgbW9kZSkge1xuICAvL21vZGU6IDAgPSB4IGJ1dCBkb24ndCBmaWxsIHkgeWV0LCAxID0geSwgMiA9IHggYW5kIGZpbGwgeSB3aXRoIDAuXG4gIHZhciBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHNpID0gbW9kZSA9PT0gMiA/IDAgOiBtb2RlLFxuICAgICAgaSA9IDAsXG4gICAgICB2O1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc2VnbWVudFtzaV0gPSB2ID0gcGFyc2VGbG9hdCh2YWx1ZXNbaV1bcHJvcGVydHldKTtcbiAgICBtb2RlID09PSAyICYmIChzZWdtZW50W3NpICsgMV0gPSAwKTtcbiAgICBzaSArPSAyO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59LFxuICAgIF9nZXRQcm9wTnVtID0gZnVuY3Rpb24gX2dldFByb3BOdW0odGFyZ2V0LCBwcm9wLCB1bml0KSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHRhcmdldC5fZ3NhcC5nZXQodGFyZ2V0LCBwcm9wLCB1bml0IHx8IFwicHhcIikpIHx8IDA7XG59LFxuICAgIF9yZWxhdGl2aXplID0gZnVuY3Rpb24gX3JlbGF0aXZpemUoc2VnbWVudCkge1xuICB2YXIgeCA9IHNlZ21lbnRbMF0sXG4gICAgICB5ID0gc2VnbWVudFsxXSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMjsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB4ID0gc2VnbWVudFtpXSArPSB4O1xuICAgIHkgPSBzZWdtZW50W2kgKyAxXSArPSB5O1xuICB9XG59LFxuICAgIC8vIGZlZWQgaW4gYW4gYXJyYXkgb2YgcXVhZHJhdGljIGJlemllciBwb2ludHMgbGlrZSBbe3g6IDAsIHk6IDB9LCAuLi5dIGFuZCBpdCdsbCBjb252ZXJ0IGl0IHRvIGN1YmljIGJlemllclxuLy8gX3F1YWRUb0N1YmljID0gcG9pbnRzID0+IHtcbi8vIFx0bGV0IGN1YmljID0gW10sXG4vLyBcdFx0bCA9IHBvaW50cy5sZW5ndGggLSAxLFxuLy8gXHRcdGkgPSAxLFxuLy8gXHRcdGEsIGIsIGM7XG4vLyBcdGZvciAoOyBpIDwgbDsgaSs9Mikge1xuLy8gXHRcdGEgPSBwb2ludHNbaS0xXTtcbi8vIFx0XHRiID0gcG9pbnRzW2ldO1xuLy8gXHRcdGMgPSBwb2ludHNbaSsxXTtcbi8vIFx0XHRjdWJpYy5wdXNoKGEsIHt4OiAoMiAqIGIueCArIGEueCkgLyAzLCB5OiAoMiAqIGIueSArIGEueSkgLyAzfSwge3g6ICgyICogYi54ICsgYy54KSAvIDMsIHk6ICgyICogYi55ICsgYy55KSAvIDN9KTtcbi8vIFx0fVxuLy8gXHRjdWJpYy5wdXNoKHBvaW50c1tsXSk7XG4vLyBcdHJldHVybiBjdWJpYztcbi8vIH0sXG5fc2VnbWVudFRvUmF3UGF0aCA9IGZ1bmN0aW9uIF9zZWdtZW50VG9SYXdQYXRoKHBsdWdpbiwgc2VnbWVudCwgdGFyZ2V0LCB4LCB5LCBzbGljZXIsIHZhcnMsIHVuaXRYLCB1bml0WSkge1xuICBpZiAodmFycy50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICBzZWdtZW50ID0gW3NlZ21lbnRdO1xuICB9IGVsc2Uge1xuICAgIHZhcnMuZnJvbUN1cnJlbnQgIT09IGZhbHNlICYmIHNlZ21lbnQudW5zaGlmdChfZ2V0UHJvcE51bSh0YXJnZXQsIHgsIHVuaXRYKSwgeSA/IF9nZXRQcm9wTnVtKHRhcmdldCwgeSwgdW5pdFkpIDogMCk7XG4gICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcbiAgICB2YXIgcG9pbnRGdW5jID0geSA/IHBvaW50c1RvU2VnbWVudCA6IGZsYXRQb2ludHNUb1NlZ21lbnQ7XG4gICAgc2VnbWVudCA9IFtwb2ludEZ1bmMoc2VnbWVudCwgdmFycy5jdXJ2aW5lc3MpXTtcbiAgfVxuXG4gIHNlZ21lbnQgPSBzbGljZXIoX2FsaWduKHNlZ21lbnQsIHRhcmdldCwgdmFycykpO1xuXG4gIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeCwgc2VnbWVudCwgXCJ4XCIsIHVuaXRYKTtcblxuICB5ICYmIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeSwgc2VnbWVudCwgXCJ5XCIsIHVuaXRZKTtcbiAgcmV0dXJuIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhzZWdtZW50LCB2YXJzLnJlc29sdXRpb24gfHwgKHZhcnMuY3VydmluZXNzID09PSAwID8gMjAgOiAxMikpOyAvL3doZW4gY3VydmluZXNzIGlzIDAsIGl0IGNyZWF0ZXMgY29udHJvbCBwb2ludHMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzIHdoaWNoIG1ha2VzIGl0IG1vcmUgc2Vuc2l0aXZlIHRvIHJlc29sdXRpb24sIHRodXMgd2UgY2hhbmdlIHRoZSBkZWZhdWx0IGFjY29yZGluZ2x5LlxufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYyh2KSB7XG4gIHJldHVybiB2O1xufSxcbiAgICBfbnVtRXhwID0gL1stK1xcLl0qXFxkK1xcLj8oPzplLXxlXFwrKT9cXGQqL2csXG4gICAgX29yaWdpblRvUG9pbnQgPSBmdW5jdGlvbiBfb3JpZ2luVG9Qb2ludChlbGVtZW50LCBvcmlnaW4sIHBhcmVudE1hdHJpeCkge1xuICAvLyBvcmlnaW4gaXMgYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCB2YWx1ZXMgKDAtMSkgaW4gcmVsYXRpb24gdG8gdGhlIHdpZHRoL2hlaWdodCwgc28gWzAuNSwgMC41XSB3b3VsZCBiZSB0aGUgY2VudGVyLiBJdCBjYW4gYWxzbyBiZSBcImF1dG9cIiBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdGhlIHRvcCBsZWZ0IHVubGVzcyBpdCdzIGEgPHBhdGg+LCB3aGVuIGl0IHdpbGwgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aCBpdHNlbGYuXG4gIHZhciBtID0gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIHN2ZztcblxuICBpZiAoKGVsZW1lbnQudGFnTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIpIHtcbiAgICBzdmcgPSBlbGVtZW50LnZpZXdCb3guYmFzZVZhbDtcbiAgICBzdmcud2lkdGggfHwgKHN2ZyA9IHtcbiAgICAgIHdpZHRoOiArZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSxcbiAgICAgIGhlaWdodDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3ZnID0gb3JpZ2luICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEJCb3goKTtcbiAgfVxuXG4gIGlmIChvcmlnaW4gJiYgb3JpZ2luICE9PSBcImF1dG9cIikge1xuICAgIHggPSBvcmlnaW4ucHVzaCA/IG9yaWdpblswXSAqIChzdmcgPyBzdmcud2lkdGggOiBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDApIDogb3JpZ2luLng7XG4gICAgeSA9IG9yaWdpbi5wdXNoID8gb3JpZ2luWzFdICogKHN2ZyA/IHN2Zy5oZWlnaHQgOiBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwKSA6IG9yaWdpbi55O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudE1hdHJpeC5hcHBseSh4IHx8IHkgPyBtLmFwcGx5KHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogbS5lLFxuICAgIHk6IG0uZlxuICB9KTtcbn0sXG4gICAgX2dldEFsaWduTWF0cml4ID0gZnVuY3Rpb24gX2dldEFsaWduTWF0cml4KGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKSB7XG4gIHZhciBwYXJlbnRNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQucGFyZW50Tm9kZSwgdHJ1ZSwgdHJ1ZSksXG4gICAgICBtID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KHRvRWxlbWVudCkpLFxuICAgICAgZnJvbVBvaW50ID0gX29yaWdpblRvUG9pbnQoZnJvbUVsZW1lbnQsIGZyb21PcmlnaW4sIHBhcmVudE1hdHJpeCksXG4gICAgICBfb3JpZ2luVG9Qb2ludDIgPSBfb3JpZ2luVG9Qb2ludCh0b0VsZW1lbnQsIHRvT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuICAgICAgeCA9IF9vcmlnaW5Ub1BvaW50Mi54LFxuICAgICAgeSA9IF9vcmlnaW5Ub1BvaW50Mi55LFxuICAgICAgcDtcblxuICBtLmUgPSBtLmYgPSAwO1xuXG4gIGlmICh0b09yaWdpbiA9PT0gXCJhdXRvXCIgJiYgdG9FbGVtZW50LmdldFRvdGFsTGVuZ3RoICYmIHRvRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicGF0aFwiKSB7XG4gICAgcCA9IHRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkXCIpLm1hdGNoKF9udW1FeHApIHx8IFtdO1xuICAgIHAgPSBtLmFwcGx5KHtcbiAgICAgIHg6ICtwWzBdLFxuICAgICAgeTogK3BbMV1cbiAgICB9KTtcbiAgICB4ICs9IHAueDtcbiAgICB5ICs9IHAueTtcbiAgfSAvL2lmIChwIHx8ICh0b0VsZW1lbnQuZ2V0QkJveCAmJiBmcm9tRWxlbWVudC5nZXRCQm94ICYmIHRvRWxlbWVudC5vd25lclNWR0VsZW1lbnQgPT09IGZyb21FbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkpIHtcblxuXG4gIGlmIChwKSB7XG4gICAgcCA9IG0uYXBwbHkodG9FbGVtZW50LmdldEJCb3goKSk7XG4gICAgeCAtPSBwLng7XG4gICAgeSAtPSBwLnk7XG4gIH1cblxuICBtLmUgPSB4IC0gZnJvbVBvaW50Lng7XG4gIG0uZiA9IHkgLSBmcm9tUG9pbnQueTtcbiAgcmV0dXJuIG07XG59LFxuICAgIF9hbGlnbiA9IGZ1bmN0aW9uIF9hbGlnbihyYXdQYXRoLCB0YXJnZXQsIF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIG1hdHJpeCA9IF9yZWYubWF0cml4LFxuICAgICAgb2Zmc2V0WCA9IF9yZWYub2Zmc2V0WCxcbiAgICAgIG9mZnNldFkgPSBfcmVmLm9mZnNldFksXG4gICAgICBhbGlnbk9yaWdpbiA9IF9yZWYuYWxpZ25PcmlnaW47XG5cbiAgdmFyIHggPSByYXdQYXRoWzBdWzBdLFxuICAgICAgeSA9IHJhd1BhdGhbMF1bMV0sXG4gICAgICBjdXJYID0gX2dldFByb3BOdW0odGFyZ2V0LCBcInhcIiksXG4gICAgICBjdXJZID0gX2dldFByb3BOdW0odGFyZ2V0LCBcInlcIiksXG4gICAgICBhbGlnblRhcmdldCxcbiAgICAgIG0sXG4gICAgICBwO1xuXG4gIGlmICghcmF3UGF0aCB8fCAhcmF3UGF0aC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0UmF3UGF0aChcIk0wLDBMMCwwXCIpO1xuICB9XG5cbiAgaWYgKGFsaWduKSB7XG4gICAgaWYgKGFsaWduID09PSBcInNlbGZcIiB8fCAoYWxpZ25UYXJnZXQgPSBfdG9BcnJheShhbGlnbilbMF0gfHwgdGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIDEsIDAsIDAsIDEsIGN1clggLSB4LCBjdXJZIC0geSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGlnbk9yaWdpbiAmJiBhbGlnbk9yaWdpblsyXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZ3NhcC5zZXQodGFyZ2V0LCB7XG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBhbGlnbk9yaWdpblswXSAqIDEwMCArIFwiJSBcIiArIGFsaWduT3JpZ2luWzFdICogMTAwICsgXCIlXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbk9yaWdpbiA9IFtfZ2V0UHJvcE51bSh0YXJnZXQsIFwieFBlcmNlbnRcIikgLyAtMTAwLCBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieVBlcmNlbnRcIikgLyAtMTAwXTtcbiAgICAgIH1cblxuICAgICAgbSA9IF9nZXRBbGlnbk1hdHJpeCh0YXJnZXQsIGFsaWduVGFyZ2V0LCBhbGlnbk9yaWdpbiwgXCJhdXRvXCIpO1xuICAgICAgcCA9IG0uYXBwbHkoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgbS5hLCBtLmIsIG0uYywgbS5kLCBjdXJYICsgbS5lIC0gKHAueCAtIG0uZSksIGN1clkgKyBtLmYgLSAocC55IC0gbS5mKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdHJpeCkge1xuICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgbWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC5lLCBtYXRyaXguZik7XG4gIH0gZWxzZSBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBvZmZzZXRYIHx8IDAsIG9mZnNldFkgfHwgMCk7XG4gIH1cblxuICByZXR1cm4gcmF3UGF0aDtcbn0sXG4gICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgcmF3UGF0aCwgcGF0aFByb3BlcnR5LCBmb3JjZVVuaXQpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgaGFybmVzcyA9IGNhY2hlLmhhcm5lc3MsXG4gICAgICBhbGlhcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzICYmIGhhcm5lc3MuYWxpYXNlc1twcm9wZXJ0eV0sXG4gICAgICBwcm9wID0gYWxpYXMgJiYgYWxpYXMuaW5kZXhPZihcIixcIikgPCAwID8gYWxpYXMgOiBwcm9wZXJ0eSxcbiAgICAgIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAwLCBfZW1wdHlGdW5jLCAwLCBjYWNoZS5zZXQodGFyZ2V0LCBwcm9wLCBwbHVnaW4pKTtcbiAgcHQudSA9IF9nZXRVbml0KGNhY2hlLmdldCh0YXJnZXQsIHByb3AsIGZvcmNlVW5pdCkpIHx8IDA7XG4gIHB0LnBhdGggPSByYXdQYXRoO1xuICBwdC5wcCA9IHBhdGhQcm9wZXJ0eTtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcCk7XG59LFxuICAgIF9zbGljZU1vZGlmaWVyID0gZnVuY3Rpb24gX3NsaWNlTW9kaWZpZXIoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJhd1BhdGgpIHtcbiAgICByZXR1cm4gc3RhcnQgfHwgZW5kICE9PSAxID8gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIDogcmF3UGF0aDtcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgTW90aW9uUGF0aFBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjExLjJcIixcbiAgbmFtZTogXCJtb3Rpb25QYXRoXCIsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlLCBQbHVnaW4sIHByb3BUd2Vlbikge1xuICAgIGdzYXAgPSBjb3JlO1xuICAgIF9nZXRVbml0ID0gZ3NhcC51dGlscy5nZXRVbml0O1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIF9nZXRTdHlsZVNhdmVyID0gZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXI7XG5cbiAgICBfcmV2ZXJ0aW5nID0gZ3NhcC5jb3JlLnJldmVydGluZyB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIFByb3BUd2VlbiA9IHByb3BUd2VlbjtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG4gICAgaWYgKCFnc2FwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihNb3Rpb25QYXRoUGx1Z2luKVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgdmFycyA9PT0gXCJvYmplY3RcIiAmJiAhdmFycy5zdHlsZSkgfHwgIXZhcnMucGF0aCkge1xuICAgICAgdmFycyA9IHtcbiAgICAgICAgcGF0aDogdmFyc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcmF3UGF0aHMgPSBbXSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBwYXRoID0gX3ZhcnMucGF0aCxcbiAgICAgICAgYXV0b1JvdGF0ZSA9IF92YXJzLmF1dG9Sb3RhdGUsXG4gICAgICAgIHVuaXRYID0gX3ZhcnMudW5pdFgsXG4gICAgICAgIHVuaXRZID0gX3ZhcnMudW5pdFksXG4gICAgICAgIHggPSBfdmFycy54LFxuICAgICAgICB5ID0gX3ZhcnMueSxcbiAgICAgICAgZmlyc3RPYmogPSBwYXRoWzBdLFxuICAgICAgICBzbGljZXIgPSBfc2xpY2VNb2RpZmllcih2YXJzLnN0YXJ0LCBcImVuZFwiIGluIHZhcnMgPyB2YXJzLmVuZCA6IDEpLFxuICAgICAgICByYXdQYXRoLFxuICAgICAgICBwO1xuXG4gICAgdGhpcy5yYXdQYXRocyA9IHJhd1BhdGhzO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgICB0aGlzLnN0eWxlcyA9IF9nZXRTdHlsZVNhdmVyICYmIF9nZXRTdHlsZVNhdmVyKHRhcmdldCwgXCJ0cmFuc2Zvcm1cIik7XG5cbiAgICBpZiAodGhpcy5yb3RhdGUgPSBhdXRvUm90YXRlIHx8IGF1dG9Sb3RhdGUgPT09IDApIHtcbiAgICAgIC8vZ2V0IHRoZSByb3RhdGlvbmFsIGRhdGEgRklSU1Qgc28gdGhhdCB0aGUgc2V0VHJhbnNmb3JtKCkgbWV0aG9kIGlzIGNhbGxlZCBpbiB0aGUgY29ycmVjdCBvcmRlciBpbiB0aGUgcmVuZGVyKCkgbG9vcCAtIHJvdGF0aW9uIGdldHMgc2V0IGxhc3QuXG4gICAgICB0aGlzLnJPZmZzZXQgPSBwYXJzZUZsb2F0KGF1dG9Sb3RhdGUpIHx8IDA7XG4gICAgICB0aGlzLnJhZGlhbnMgPSAhIXZhcnMudXNlUmFkaWFucztcbiAgICAgIHRoaXMuclByb3AgPSB2YXJzLnJvdGF0aW9uIHx8IFwicm90YXRpb25cIjsgLy8gcm90YXRpb24gcHJvcGVydHlcblxuICAgICAgdGhpcy5yU2V0ID0gdGFyZ2V0Ll9nc2FwLnNldCh0YXJnZXQsIHRoaXMuclByb3AsIHRoaXMpOyAvLyByb3RhdGlvbiBzZXR0ZXJcblxuICAgICAgdGhpcy5ydSA9IF9nZXRVbml0KHRhcmdldC5fZ3NhcC5nZXQodGFyZ2V0LCB0aGlzLnJQcm9wKSkgfHwgMDsgLy8gcm90YXRpb24gdW5pdHNcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSAmJiAhKFwiY2xvc2VkXCIgaW4gcGF0aCkgJiYgdHlwZW9mIGZpcnN0T2JqICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBmb3IgKHAgaW4gZmlyc3RPYmopIHtcbiAgICAgICAgaWYgKCF4ICYmIH5feFByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICB4ID0gcDtcbiAgICAgICAgfSBlbHNlIGlmICgheSAmJiB+X3lQcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgeSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHggJiYgeSkge1xuICAgICAgICAvL2NvcnJlbGF0ZWQgdmFsdWVzXG4gICAgICAgIHJhd1BhdGhzLnB1c2goX3NlZ21lbnRUb1Jhd1BhdGgodGhpcywgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KFtdLCBwYXRoLCB4LCAwKSwgcGF0aCwgeSwgMSksIHRhcmdldCwgeCwgeSwgc2xpY2VyLCB2YXJzLCB1bml0WCB8fCBfZ2V0VW5pdChwYXRoWzBdW3hdKSwgdW5pdFkgfHwgX2dldFVuaXQocGF0aFswXVt5XSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB5ID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChwIGluIGZpcnN0T2JqKSB7XG4gICAgICAgIHAgIT09IHggJiYgcCAhPT0geSAmJiByYXdQYXRocy5wdXNoKF9zZWdtZW50VG9SYXdQYXRoKHRoaXMsIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHBhdGgsIHAsIDIpLCB0YXJnZXQsIHAsIDAsIHNsaWNlciwgdmFycywgX2dldFVuaXQocGF0aFswXVtwXSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmF3UGF0aCA9IHNsaWNlcihfYWxpZ24oZ2V0UmF3UGF0aCh2YXJzLnBhdGgpLCB0YXJnZXQsIHZhcnMpKTtcbiAgICAgIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCB2YXJzLnJlc29sdXRpb24pO1xuICAgICAgcmF3UGF0aHMucHVzaChyYXdQYXRoKTtcblxuICAgICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgdmFycy54IHx8IFwieFwiLCByYXdQYXRoLCBcInhcIiwgdmFycy51bml0WCB8fCBcInB4XCIpO1xuXG4gICAgICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4odGhpcywgdGFyZ2V0LCB2YXJzLnkgfHwgXCJ5XCIsIHJhd1BhdGgsIFwieVwiLCB2YXJzLnVuaXRZIHx8IFwicHhcIik7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciByYXdQYXRocyA9IGRhdGEucmF3UGF0aHMsXG4gICAgICAgIGkgPSByYXdQYXRocy5sZW5ndGgsXG4gICAgICAgIHB0ID0gZGF0YS5fcHQ7XG5cbiAgICBpZiAoZGF0YS50d2Vlbi5fdGltZSB8fCAhX3JldmVydGluZygpKSB7XG4gICAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICAgIHJhdGlvID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocmF0aW8gPCAwKSB7XG4gICAgICAgIHJhdGlvID0gMDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBnZXRQb3NpdGlvbk9uUGF0aChyYXdQYXRoc1tpXSwgcmF0aW8sICFpICYmIGRhdGEucm90YXRlLCByYXdQYXRoc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5zZXQocHQudCwgcHQucCwgcHQucGF0aFtwdC5wcF0gKyBwdC51LCBwdC5kLCByYXRpbyk7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucm90YXRlICYmIGRhdGEuclNldChkYXRhLnRhcmdldCwgZGF0YS5yUHJvcCwgcmF3UGF0aHNbMF0uYW5nbGUgKiAoZGF0YS5yYWRpYW5zID8gX0RFRzJSQUQgOiAxKSArIGRhdGEuck9mZnNldCArIGRhdGEucnUsIGRhdGEsIHJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5zdHlsZXMucmV2ZXJ0KCk7XG4gICAgfVxuICB9LFxuICBnZXRMZW5ndGg6IGZ1bmN0aW9uIGdldExlbmd0aChwYXRoKSB7XG4gICAgcmV0dXJuIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhnZXRSYXdQYXRoKHBhdGgpKS50b3RhbExlbmd0aDtcbiAgfSxcbiAgc2xpY2VSYXdQYXRoOiBzbGljZVJhd1BhdGgsXG4gIGdldFJhd1BhdGg6IGdldFJhd1BhdGgsXG4gIHBvaW50c1RvU2VnbWVudDogcG9pbnRzVG9TZWdtZW50LFxuICBzdHJpbmdUb1Jhd1BhdGg6IHN0cmluZ1RvUmF3UGF0aCxcbiAgcmF3UGF0aFRvU3RyaW5nOiByYXdQYXRoVG9TdHJpbmcsXG4gIHRyYW5zZm9ybVJhd1BhdGg6IHRyYW5zZm9ybVJhd1BhdGgsXG4gIGdldEdsb2JhbE1hdHJpeDogZ2V0R2xvYmFsTWF0cml4LFxuICBnZXRQb3NpdGlvbk9uUGF0aDogZ2V0UG9zaXRpb25PblBhdGgsXG4gIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50czogY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzLFxuICBjb252ZXJ0VG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0VG9QYXRoKHRhcmdldHMsIHN3YXApIHtcbiAgICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBfY29udmVydFRvUGF0aCh0YXJnZXQsIHN3YXAgIT09IGZhbHNlKTtcbiAgICB9KTtcbiAgfSxcbiAgY29udmVydENvb3JkaW5hdGVzOiBmdW5jdGlvbiBjb252ZXJ0Q29vcmRpbmF0ZXMoZnJvbUVsZW1lbnQsIHRvRWxlbWVudCwgcG9pbnQpIHtcbiAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0b0VsZW1lbnQsIHRydWUsIHRydWUpLm11bHRpcGx5KGdldEdsb2JhbE1hdHJpeChmcm9tRWxlbWVudCkpO1xuICAgIHJldHVybiBwb2ludCA/IG0uYXBwbHkocG9pbnQpIDogbTtcbiAgfSxcbiAgZ2V0QWxpZ25NYXRyaXg6IF9nZXRBbGlnbk1hdHJpeCxcbiAgZ2V0UmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbikge1xuICAgIHZhciBtID0gX2dldEFsaWduTWF0cml4KGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBtLmUsXG4gICAgICB5OiBtLmZcbiAgICB9O1xuICB9LFxuICBhcnJheVRvUmF3UGF0aDogZnVuY3Rpb24gYXJyYXlUb1Jhd1BhdGgodmFsdWUsIHZhcnMpIHtcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcblxuICAgIHZhciBzZWdtZW50ID0gX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KFtdLCB2YWx1ZSwgdmFycy54IHx8IFwieFwiLCAwKSwgdmFsdWUsIHZhcnMueSB8fCBcInlcIiwgMSk7XG5cbiAgICB2YXJzLnJlbGF0aXZlICYmIF9yZWxhdGl2aXplKHNlZ21lbnQpO1xuICAgIHJldHVybiBbdmFycy50eXBlID09PSBcImN1YmljXCIgPyBzZWdtZW50IDogcG9pbnRzVG9TZWdtZW50KHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG4gIH1cbn07XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbik7XG5leHBvcnQgeyBNb3Rpb25QYXRoUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/MotionPathPlugin.js\n"));

/***/ }),

/***/ "./node_modules/gsap/Observer.js":
/*!***************************************!*\
  !*** ./node_modules/gsap/Observer.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observer\": function() { return /* binding */ Observer; },\n/* harmony export */   \"_getProxyProp\": function() { return /* binding */ _getProxyProp; },\n/* harmony export */   \"_getScrollFunc\": function() { return /* binding */ _getScrollFunc; },\n/* harmony export */   \"_getTarget\": function() { return /* binding */ _getTarget; },\n/* harmony export */   \"_getVelocityProp\": function() { return /* binding */ _getVelocityProp; },\n/* harmony export */   \"_horizontal\": function() { return /* binding */ _horizontal; },\n/* harmony export */   \"_isViewport\": function() { return /* binding */ _isViewport; },\n/* harmony export */   \"_proxies\": function() { return /* binding */ _proxies; },\n/* harmony export */   \"_scrollers\": function() { return /* binding */ _scrollers; },\n/* harmony export */   \"_vertical\": function() { return /* binding */ _vertical; },\n/* harmony export */   \"default\": function() { return /* binding */ Observer; }\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * Observer 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _clamp,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _isTouch,\n    _pointerType,\n    ScrollTrigger,\n    _root,\n    _normalizer,\n    _eventTypes,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _startup = 1,\n    _observers = [],\n    _scrollers = [],\n    _proxies = [],\n    _getTime = Date.now,\n    _bridge = function _bridge(name, value) {\n  return value;\n},\n    _integrate = function _integrate() {\n  var core = ScrollTrigger.core,\n      data = core.bridge || {},\n      scrollers = core._scrollers,\n      proxies = core._proxies;\n  scrollers.push.apply(scrollers, _scrollers);\n  proxies.push.apply(proxies, _proxies);\n  _scrollers = scrollers;\n  _proxies = proxies;\n\n  _bridge = function _bridge(name, value) {\n    return data[name](value);\n  };\n},\n    _getProxyProp = function _getProxyProp(element, property) {\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n},\n    _isViewport = function _isViewport(el) {\n  return !!~_root.indexOf(el);\n},\n    _addListener = function _addListener(element, type, func, nonPassive, capture) {\n  return element.addEventListener(type, func, {\n    passive: !nonPassive,\n    capture: !!capture\n  });\n},\n    _removeListener = function _removeListener(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n},\n    _scrollLeft = \"scrollLeft\",\n    _scrollTop = \"scrollTop\",\n    _onScroll = function _onScroll() {\n  return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n},\n    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n  var cachingFunc = function cachingFunc(value) {\n    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n    if (value || value === 0) {\n      _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n\n      var isNormalizing = _normalizer && _normalizer.isPressed;\n      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n\n      f(value);\n      cachingFunc.cacheID = _scrollers.cache;\n      isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n      cachingFunc.cacheID = _scrollers.cache;\n      cachingFunc.v = f();\n    }\n\n    return cachingFunc.v + cachingFunc.offset;\n  };\n\n  cachingFunc.offset = 0;\n  return f && cachingFunc;\n},\n    _horizontal = {\n  s: _scrollLeft,\n  p: \"left\",\n  p2: \"Left\",\n  os: \"right\",\n  os2: \"Right\",\n  d: \"width\",\n  d2: \"Width\",\n  a: \"x\",\n  sc: _scrollCacheFunc(function (value) {\n    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n  })\n},\n    _vertical = {\n  s: _scrollTop,\n  p: \"top\",\n  p2: \"Top\",\n  os: \"bottom\",\n  os2: \"Bottom\",\n  d: \"height\",\n  d2: \"Height\",\n  a: \"y\",\n  op: _horizontal,\n  sc: _scrollCacheFunc(function (value) {\n    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n  })\n},\n    _getTarget = function _getTarget(t) {\n  return gsap.utils.toArray(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n},\n    _getScrollFunc = function _getScrollFunc(element, _ref) {\n  var s = _ref.s,\n      sc = _ref.sc;\n  // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n  _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n\n  var i = _scrollers.indexOf(element),\n      offset = sc === _vertical.sc ? 1 : 2;\n\n  !~i && (i = _scrollers.push(element) - 1);\n  _scrollers[i + offset] || element.addEventListener(\"scroll\", _onScroll); // clear the cache when a scroll occurs\n\n  var prev = _scrollers[i + offset],\n      func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {\n    return arguments.length ? element[s] = value : element[s];\n  })));\n  func.target = element;\n  prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n\n  return func;\n},\n    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n  var v1 = value,\n      v2 = value,\n      t1 = _getTime(),\n      t2 = t1,\n      min = minTimeRefresh || 50,\n      dropToZeroTime = Math.max(500, min * 3),\n      update = function update(value, force) {\n    var t = _getTime();\n\n    if (force || t - t1 > min) {\n      v2 = v1;\n      v1 = value;\n      t2 = t1;\n      t1 = t;\n    } else if (useDelta) {\n      v1 += value;\n    } else {\n      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n      v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n    }\n  },\n      reset = function reset() {\n    v2 = v1 = useDelta ? 0 : v1;\n    t2 = t1 = 0;\n  },\n      getVelocity = function getVelocity(latestValue) {\n    var tOld = t2,\n        vOld = v2,\n        t = _getTime();\n\n    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n  };\n\n  return {\n    update: update,\n    reset: reset,\n    getVelocity: getVelocity\n  };\n},\n    _getEvent = function _getEvent(e, preventDefault) {\n  preventDefault && !e._gsapAllow && e.preventDefault();\n  return e.changedTouches ? e.changedTouches[0] : e;\n},\n    _getAbsoluteMax = function _getAbsoluteMax(a) {\n  var max = Math.max.apply(Math, a),\n      min = Math.min.apply(Math, a);\n  return Math.abs(max) >= Math.abs(min) ? max : min;\n},\n    _setScrollTrigger = function _setScrollTrigger() {\n  ScrollTrigger = gsap.core.globals().ScrollTrigger;\n  ScrollTrigger && ScrollTrigger.core && _integrate();\n},\n    _initCore = function _initCore(core) {\n  gsap = core || _getGSAP();\n\n  if (gsap && typeof document !== \"undefined\" && document.body) {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n    _root = [_win, _doc, _docEl, _body];\n    _clamp = gsap.utils.clamp;\n    _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\n    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n    _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n    setTimeout(function () {\n      return _startup = 0;\n    }, 500);\n\n    _setScrollTrigger();\n\n    _coreInitted = 1;\n  }\n\n  return _coreInitted;\n};\n\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = /*#__PURE__*/function () {\n  function Observer(vars) {\n    this.init(vars);\n  }\n\n  var _proto = Observer.prototype;\n\n  _proto.init = function init(vars) {\n    _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n    ScrollTrigger || _setScrollTrigger();\n    var tolerance = vars.tolerance,\n        dragMinimum = vars.dragMinimum,\n        type = vars.type,\n        target = vars.target,\n        lineHeight = vars.lineHeight,\n        debounce = vars.debounce,\n        preventDefault = vars.preventDefault,\n        onStop = vars.onStop,\n        onStopDelay = vars.onStopDelay,\n        ignore = vars.ignore,\n        wheelSpeed = vars.wheelSpeed,\n        event = vars.event,\n        onDragStart = vars.onDragStart,\n        onDragEnd = vars.onDragEnd,\n        onDrag = vars.onDrag,\n        onPress = vars.onPress,\n        onRelease = vars.onRelease,\n        onRight = vars.onRight,\n        onLeft = vars.onLeft,\n        onUp = vars.onUp,\n        onDown = vars.onDown,\n        onChangeX = vars.onChangeX,\n        onChangeY = vars.onChangeY,\n        onChange = vars.onChange,\n        onToggleX = vars.onToggleX,\n        onToggleY = vars.onToggleY,\n        onHover = vars.onHover,\n        onHoverEnd = vars.onHoverEnd,\n        onMove = vars.onMove,\n        ignoreCheck = vars.ignoreCheck,\n        isNormalizer = vars.isNormalizer,\n        onGestureStart = vars.onGestureStart,\n        onGestureEnd = vars.onGestureEnd,\n        onWheel = vars.onWheel,\n        onEnable = vars.onEnable,\n        onDisable = vars.onDisable,\n        onClick = vars.onClick,\n        scrollSpeed = vars.scrollSpeed,\n        capture = vars.capture,\n        allowClicks = vars.allowClicks,\n        lockAxis = vars.lockAxis,\n        onLockAxis = vars.onLockAxis;\n    this.target = target = _getTarget(target) || _docEl;\n    this.vars = vars;\n    ignore && (ignore = gsap.utils.toArray(ignore));\n    tolerance = tolerance || 1e-9;\n    dragMinimum = dragMinimum || 0;\n    wheelSpeed = wheelSpeed || 1;\n    scrollSpeed = scrollSpeed || 1;\n    type = type || \"wheel,touch,pointer\";\n    debounce = debounce !== false;\n    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n\n    var id,\n        onStopDelayedCall,\n        dragged,\n        moved,\n        wheeled,\n        locked,\n        axis,\n        self = this,\n        prevDeltaX = 0,\n        prevDeltaY = 0,\n        scrollFuncX = _getScrollFunc(target, _horizontal),\n        scrollFuncY = _getScrollFunc(target, _vertical),\n        scrollX = scrollFuncX(),\n        scrollY = scrollFuncY(),\n        limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\",\n        // for devices that accommodate mouse events and touch events, we need to distinguish.\n    isViewport = _isViewport(target),\n        ownerDoc = target.ownerDocument || _doc,\n        deltaX = [0, 0, 0],\n        // wheel, scroll, pointer/touch\n    deltaY = [0, 0, 0],\n        onClickTime = 0,\n        clickCapture = function clickCapture() {\n      return onClickTime = _getTime();\n    },\n        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n      return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n    },\n        onStopFunc = function onStopFunc() {\n      self._vx.reset();\n\n      self._vy.reset();\n\n      onStopDelayedCall.pause();\n      onStop && onStop(self);\n    },\n        update = function update() {\n      var dx = self.deltaX = _getAbsoluteMax(deltaX),\n          dy = self.deltaY = _getAbsoluteMax(deltaY),\n          changedX = Math.abs(dx) >= tolerance,\n          changedY = Math.abs(dy) >= tolerance;\n\n      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n\n      if (changedX) {\n        onRight && self.deltaX > 0 && onRight(self);\n        onLeft && self.deltaX < 0 && onLeft(self);\n        onChangeX && onChangeX(self);\n        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n        prevDeltaX = self.deltaX;\n        deltaX[0] = deltaX[1] = deltaX[2] = 0;\n      }\n\n      if (changedY) {\n        onDown && self.deltaY > 0 && onDown(self);\n        onUp && self.deltaY < 0 && onUp(self);\n        onChangeY && onChangeY(self);\n        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n        prevDeltaY = self.deltaY;\n        deltaY[0] = deltaY[1] = deltaY[2] = 0;\n      }\n\n      if (moved || dragged) {\n        onMove && onMove(self);\n\n        if (dragged) {\n          onDrag(self);\n          dragged = false;\n        }\n\n        moved = false;\n      }\n\n      locked && !(locked = false) && onLockAxis && onLockAxis(self);\n\n      if (wheeled) {\n        onWheel(self);\n        wheeled = false;\n      }\n\n      id = 0;\n    },\n        onDelta = function onDelta(x, y, index) {\n      deltaX[index] += x;\n      deltaY[index] += y;\n\n      self._vx.update(x);\n\n      self._vy.update(y);\n\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    },\n        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n      if (lockAxis && !axis) {\n        self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n        locked = true;\n      }\n\n      if (axis !== \"y\") {\n        deltaX[2] += x;\n\n        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n\n      }\n\n      if (axis !== \"x\") {\n        deltaY[2] += y;\n\n        self._vy.update(y, true);\n      }\n\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    },\n        _onDrag = function _onDrag(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      e = _getEvent(e, preventDefault);\n      var x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y,\n          isDragging = self.isDragging;\n      self.x = x;\n      self.y = y;\n\n      if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n        onDrag && (dragged = true);\n        isDragging || (self.isDragging = true);\n        onTouchOrPointerDelta(dx, dy);\n        isDragging || onDragStart && onDragStart(self);\n      }\n    },\n        _onPress = self.onPress = function (e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      self.axis = axis = null;\n      onStopDelayedCall.pause();\n      self.isPressed = true;\n      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n\n      prevDeltaX = prevDeltaY = 0;\n      self.startX = self.x = e.clientX;\n      self.startY = self.y = e.clientY;\n\n      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n\n\n      self._vy.reset();\n\n      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);\n\n      self.deltaX = self.deltaY = 0;\n      onPress && onPress(self);\n    },\n        _onRelease = function _onRelease(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n\n      var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),\n          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n      eventData = _getEvent(e);\n\n      if (!wasDragging) {\n        self._vx.reset();\n\n        self._vy.reset();\n\n        if (preventDefault && allowClicks) {\n          gsap.delayedCall(0.08, function () {\n            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n              if (e.target.click) {\n                //some browsers (like mobile Safari) don't properly trigger the click event\n                e.target.click();\n              } else if (ownerDoc.createEvent) {\n                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                e.target.dispatchEvent(syntheticEvent);\n              }\n            }\n          });\n        }\n      }\n\n      self.isDragging = self.isGesturing = self.isPressed = false;\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\n      onDragEnd && wasDragging && onDragEnd(self);\n      onRelease && onRelease(self, wasDragging);\n    },\n        _onGestureStart = function _onGestureStart(e) {\n      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n    },\n        _onGestureEnd = function _onGestureEnd() {\n      return (self.isGesturing = false) || onGestureEnd(self);\n    },\n        onScroll = function onScroll(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      var x = scrollFuncX(),\n          y = scrollFuncY();\n      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n      scrollX = x;\n      scrollY = y;\n      onStop && onStopDelayedCall.restart(true);\n    },\n        _onWheel = function _onWheel(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      e = _getEvent(e, preventDefault);\n      onWheel && (wheeled = true);\n      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\n    },\n        _onMove = function _onMove(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      var x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y;\n      self.x = x;\n      self.y = y;\n      moved = true;\n      (dx || dy) && onTouchOrPointerDelta(dx, dy);\n    },\n        _onHover = function _onHover(e) {\n      self.event = e;\n      onHover(self);\n    },\n        _onHoverEnd = function _onHoverEnd(e) {\n      self.event = e;\n      onHoverEnd(self);\n    },\n        _onClick = function _onClick(e) {\n      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n    };\n\n    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n    self.deltaX = self.deltaY = 0;\n    self._vx = _getVelocityProp(0, 50, true);\n    self._vy = _getVelocityProp(0, 50, true);\n    self.scrollX = scrollFuncX;\n    self.scrollY = scrollFuncY;\n    self.isDragging = self.isGesturing = self.isPressed = false;\n\n    self.enable = function (e) {\n      if (!self.isEnabled) {\n        _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\n        type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, preventDefault, capture);\n        type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, preventDefault, capture);\n\n        if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n          _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);\n\n          _addListener(ownerDoc, _eventTypes[2], _onRelease);\n\n          _addListener(ownerDoc, _eventTypes[3], _onRelease);\n\n          allowClicks && _addListener(target, \"click\", clickCapture, false, true);\n          onClick && _addListener(target, \"click\", _onClick);\n          onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n          onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n          onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n          onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n          onMove && _addListener(target, _pointerType + \"move\", _onMove);\n        }\n\n        self.isEnabled = true;\n        e && e.type && _onPress(e);\n        onEnable && onEnable(self);\n      }\n\n      return self;\n    };\n\n    self.disable = function () {\n      if (self.isEnabled) {\n        // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n        _observers.filter(function (o) {\n          return o !== self && _isViewport(o.target);\n        }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\n        if (self.isPressed) {\n          self._vx.reset();\n\n          self._vy.reset();\n\n          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n        }\n\n        _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n\n        _removeListener(target, \"wheel\", _onWheel, capture);\n\n        _removeListener(target, _eventTypes[0], _onPress, capture);\n\n        _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n\n        _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n\n        _removeListener(target, \"click\", clickCapture, true);\n\n        _removeListener(target, \"click\", _onClick);\n\n        _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n\n        _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n\n        _removeListener(target, _pointerType + \"enter\", _onHover);\n\n        _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n\n        _removeListener(target, _pointerType + \"move\", _onMove);\n\n        self.isEnabled = self.isPressed = self.isDragging = false;\n        onDisable && onDisable(self);\n      }\n    };\n\n    self.kill = function () {\n      self.disable();\n\n      var i = _observers.indexOf(self);\n\n      i >= 0 && _observers.splice(i, 1);\n      _normalizer === self && (_normalizer = 0);\n    };\n\n    _observers.push(self);\n\n    isNormalizer && _isViewport(target) && (_normalizer = self);\n    self.enable(event);\n  };\n\n  _createClass(Observer, [{\n    key: \"velocityX\",\n    get: function get() {\n      return this._vx.getVelocity();\n    }\n  }, {\n    key: \"velocityY\",\n    get: function get() {\n      return this._vy.getVelocity();\n    }\n  }]);\n\n  return Observer;\n}();\nObserver.version = \"3.11.2\";\n\nObserver.create = function (vars) {\n  return new Observer(vars);\n};\n\nObserver.register = _initCore;\n\nObserver.getAll = function () {\n  return _observers.slice();\n};\n\nObserver.getById = function (id) {\n  return _observers.filter(function (o) {\n    return o.vars.id === id;\n  })[0];\n};\n\n_getGSAP() && gsap.registerPlugin(Observer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQSw2RkFBNkY7O0FBRTdGO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7OztBQUd4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL09ic2VydmVyLmpzPzA5NjQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKiFcbiAqIE9ic2VydmVyIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2xhbXAsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfaXNUb3VjaCxcbiAgICBfcG9pbnRlclR5cGUsXG4gICAgU2Nyb2xsVHJpZ2dlcixcbiAgICBfcm9vdCxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfZXZlbnRUeXBlcyxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHApIHtcbiAgcmV0dXJuIHA7XG59LFxuICAgIF9zdGFydHVwID0gMSxcbiAgICBfb2JzZXJ2ZXJzID0gW10sXG4gICAgX3Njcm9sbGVycyA9IFtdLFxuICAgIF9wcm94aWVzID0gW10sXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfYnJpZGdlID0gZnVuY3Rpb24gX2JyaWRnZShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59LFxuICAgIF9pbnRlZ3JhdGUgPSBmdW5jdGlvbiBfaW50ZWdyYXRlKCkge1xuICB2YXIgY29yZSA9IFNjcm9sbFRyaWdnZXIuY29yZSxcbiAgICAgIGRhdGEgPSBjb3JlLmJyaWRnZSB8fCB7fSxcbiAgICAgIHNjcm9sbGVycyA9IGNvcmUuX3Njcm9sbGVycyxcbiAgICAgIHByb3hpZXMgPSBjb3JlLl9wcm94aWVzO1xuICBzY3JvbGxlcnMucHVzaC5hcHBseShzY3JvbGxlcnMsIF9zY3JvbGxlcnMpO1xuICBwcm94aWVzLnB1c2guYXBwbHkocHJveGllcywgX3Byb3hpZXMpO1xuICBfc2Nyb2xsZXJzID0gc2Nyb2xsZXJzO1xuICBfcHJveGllcyA9IHByb3hpZXM7XG5cbiAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZGF0YVtuYW1lXSh2YWx1ZSk7XG4gIH07XG59LFxuICAgIF9nZXRQcm94eVByb3AgPSBmdW5jdGlvbiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSAmJiBfcHJveGllc1tfcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICsgMV1bcHJvcGVydHldO1xufSxcbiAgICBfaXNWaWV3cG9ydCA9IGZ1bmN0aW9uIF9pc1ZpZXdwb3J0KGVsKSB7XG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGVsKTtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIG5vblBhc3NpdmUsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7XG4gICAgcGFzc2l2ZTogIW5vblBhc3NpdmUsXG4gICAgY2FwdHVyZTogISFjYXB0dXJlXG4gIH0pO1xufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsICEhY2FwdHVyZSk7XG59LFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICByZXR1cm4gX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9zY3JvbGxlcnMuY2FjaGUrKztcbn0sXG4gICAgX3Njcm9sbENhY2hlRnVuYyA9IGZ1bmN0aW9uIF9zY3JvbGxDYWNoZUZ1bmMoZiwgZG9Ob3RDYWNoZSkge1xuICB2YXIgY2FjaGluZ0Z1bmMgPSBmdW5jdGlvbiBjYWNoaW5nRnVuYyh2YWx1ZSkge1xuICAgIC8vIHNpbmNlIHJlYWRpbmcgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0L3BhZ2VPZmZzZXRZL3BhZ2VPZmZzZXRYIGNhbiB0cmlnZ2VyIGEgbGF5b3V0LCB0aGlzIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBjYWNoZSB0aGUgdmFsdWUgc28gaXQgb25seSBnZXRzIHJlYWQgZnJlc2ggYWZ0ZXIgYSBcInNjcm9sbFwiIGV2ZW50IGZpcmVzIChvciB3aGlsZSB3ZSdyZSByZWZyZXNoaW5nIGJlY2F1c2UgdGhhdCBjYW4gbGVuZ3RoZW4gdGhlIHBhZ2UgYW5kIGFsdGVyIHRoZSBzY3JvbGwgcG9zaXRpb24pLiB3aGVuIFwic29mdFwiIGlzIHRydWUsIHRoYXQgbWVhbnMgZG9uJ3QgYWN0dWFsbHkgc2V0IHRoZSBzY3JvbGwsIGJ1dCBjYWNoZSB0aGUgbmV3IHZhbHVlIGluc3RlYWQgKHVzZWZ1bCBpbiBTY3JvbGxTbW9vdGhlcilcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIF9zdGFydHVwICYmIChfd2luLmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiKTsgLy8gb3RoZXJ3aXNlIHRoZSBuZXcgcG9zaXRpb24gd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgdGhlIGJyb3dzZXIgb25sb2FkLlxuXG4gICAgICB2YXIgaXNOb3JtYWxpemluZyA9IF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlzUHJlc3NlZDtcbiAgICAgIHZhbHVlID0gY2FjaGluZ0Z1bmMudiA9IE1hdGgucm91bmQodmFsdWUpIHx8IChfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pT1MgPyAxIDogMCk7IC8vVE9ETzogaU9TIEJ1ZzogaWYgeW91IGFsbG93IGl0IHRvIGdvIHRvIDAsIFNhZmFyaSBjYW4gc3RhcnQgdG8gcmVwb3J0IHN1cGVyIHN0cmFuZ2UgKHdpbGRseSBpbmFjY3VyYXRlKSB0b3VjaCBwb3NpdGlvbnMhXG5cbiAgICAgIGYodmFsdWUpO1xuICAgICAgY2FjaGluZ0Z1bmMuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG4gICAgICBpc05vcm1hbGl6aW5nICYmIF9icmlkZ2UoXCJzc1wiLCB2YWx1ZSk7IC8vIHNldCBzY3JvbGwgKG5vdGlmeSBTY3JvbGxUcmlnZ2VyIHNvIGl0IGNhbiBkaXNwYXRjaCBhIFwic2Nyb2xsU3RhcnRcIiBldmVudCBpZiBuZWNlc3NhcnlcbiAgICB9IGVsc2UgaWYgKGRvTm90Q2FjaGUgfHwgX3Njcm9sbGVycy5jYWNoZSAhPT0gY2FjaGluZ0Z1bmMuY2FjaGVJRCB8fCBfYnJpZGdlKFwicmVmXCIpKSB7XG4gICAgICBjYWNoaW5nRnVuYy5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcbiAgICAgIGNhY2hpbmdGdW5jLnYgPSBmKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hpbmdGdW5jLnYgKyBjYWNoaW5nRnVuYy5vZmZzZXQ7XG4gIH07XG5cbiAgY2FjaGluZ0Z1bmMub2Zmc2V0ID0gMDtcbiAgcmV0dXJuIGYgJiYgY2FjaGluZ0Z1bmM7XG59LFxuICAgIF9ob3Jpem9udGFsID0ge1xuICBzOiBfc2Nyb2xsTGVmdCxcbiAgcDogXCJsZWZ0XCIsXG4gIHAyOiBcIkxlZnRcIixcbiAgb3M6IFwicmlnaHRcIixcbiAgb3MyOiBcIlJpZ2h0XCIsXG4gIGQ6IFwid2lkdGhcIixcbiAgZDI6IFwiV2lkdGhcIixcbiAgYTogXCJ4XCIsXG4gIHNjOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyh2YWx1ZSwgX3ZlcnRpY2FsLnNjKCkpIDogX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jW19zY3JvbGxMZWZ0XSB8fCBfZG9jRWxbX3Njcm9sbExlZnRdIHx8IF9ib2R5W19zY3JvbGxMZWZ0XSB8fCAwO1xuICB9KVxufSxcbiAgICBfdmVydGljYWwgPSB7XG4gIHM6IF9zY3JvbGxUb3AsXG4gIHA6IFwidG9wXCIsXG4gIHAyOiBcIlRvcFwiLFxuICBvczogXCJib3R0b21cIixcbiAgb3MyOiBcIkJvdHRvbVwiLFxuICBkOiBcImhlaWdodFwiLFxuICBkMjogXCJIZWlnaHRcIixcbiAgYTogXCJ5XCIsXG4gIG9wOiBfaG9yaXpvbnRhbCxcbiAgc2M6IF9zY3JvbGxDYWNoZUZ1bmMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKF9ob3Jpem9udGFsLnNjKCksIHZhbHVlKSA6IF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsVG9wXSB8fCBfZG9jRWxbX3Njcm9sbFRvcF0gfHwgX2JvZHlbX3Njcm9sbFRvcF0gfHwgMDtcbiAgfSlcbn0sXG4gICAgX2dldFRhcmdldCA9IGZ1bmN0aW9uIF9nZXRUYXJnZXQodCkge1xuICByZXR1cm4gZ3NhcC51dGlscy50b0FycmF5KHQpWzBdIHx8ICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIiAmJiBnc2FwLmNvbmZpZygpLm51bGxUYXJnZXRXYXJuICE9PSBmYWxzZSA/IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0KSA6IG51bGwpO1xufSxcbiAgICBfZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxGdW5jKGVsZW1lbnQsIF9yZWYpIHtcbiAgdmFyIHMgPSBfcmVmLnMsXG4gICAgICBzYyA9IF9yZWYuc2M7XG4gIC8vIHdlIHN0b3JlIHRoZSBzY3JvbGxlciBmdW5jdGlvbnMgaW4gYW4gYWx0ZXJuYXRpbmcgc2VxdWVuY2VkIEFycmF5IGxpa2UgW2VsZW1lbnQsIHZlcnRpY2FsU2Nyb2xsRnVuYywgaG9yaXpvbnRhbFNjcm9sbEZ1bmMsIC4uLl0gc28gdGhhdCB3ZSBjYW4gbWluaW1pemUgbWVtb3J5LCBtYXhpbWl6ZSBwZXJmb3JtYW5jZSwgYW5kIHdlIGFsc28gcmVjb3JkIHRoZSBsYXN0IHBvc2l0aW9uIGFzIGEgXCIucmVjXCIgcHJvcGVydHkgaW4gb3JkZXIgdG8gcmV2ZXJ0IHRvIHRoYXQgYWZ0ZXIgcmVmcmVzaGluZyB0byBlbnN1cmUgdGhpbmdzIGRvbid0IHNoaWZ0IGFyb3VuZC5cbiAgX2lzVmlld3BvcnQoZWxlbWVudCkgJiYgKGVsZW1lbnQgPSBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsKTtcblxuICB2YXIgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZihlbGVtZW50KSxcbiAgICAgIG9mZnNldCA9IHNjID09PSBfdmVydGljYWwuc2MgPyAxIDogMjtcblxuICAhfmkgJiYgKGkgPSBfc2Nyb2xsZXJzLnB1c2goZWxlbWVudCkgLSAxKTtcbiAgX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSB8fCBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gY2xlYXIgdGhlIGNhY2hlIHdoZW4gYSBzY3JvbGwgb2NjdXJzXG5cbiAgdmFyIHByZXYgPSBfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdLFxuICAgICAgZnVuYyA9IHByZXYgfHwgKF9zY3JvbGxlcnNbaSArIG9mZnNldF0gPSBfc2Nyb2xsQ2FjaGVGdW5jKF9nZXRQcm94eVByb3AoZWxlbWVudCwgcyksIHRydWUpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IHNjIDogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGVsZW1lbnRbc10gPSB2YWx1ZSA6IGVsZW1lbnRbc107XG4gIH0pKSk7XG4gIGZ1bmMudGFyZ2V0ID0gZWxlbWVudDtcbiAgcHJldiB8fCAoZnVuYy5zbW9vdGggPSBnc2FwLmdldFByb3BlcnR5KGVsZW1lbnQsIFwic2Nyb2xsQmVoYXZpb3JcIikgPT09IFwic21vb3RoXCIpOyAvLyBvbmx5IHNldCBpdCB0aGUgZmlyc3QgdGltZSAoZG9uJ3QgcmVzZXQgZXZlcnkgdGltZSBhIHNjcm9sbEZ1bmMgaXMgcmVxdWVzdGVkIGJlY2F1c2UgcGVyaGFwcyBpdCBoYXBwZW5zIGR1cmluZyBhIHJlZnJlc2goKSB3aGVuIGl0J3MgZGlzYWJsZWQgaW4gU2Nyb2xsVHJpZ2dlci5cblxuICByZXR1cm4gZnVuYztcbn0sXG4gICAgX2dldFZlbG9jaXR5UHJvcCA9IGZ1bmN0aW9uIF9nZXRWZWxvY2l0eVByb3AodmFsdWUsIG1pblRpbWVSZWZyZXNoLCB1c2VEZWx0YSkge1xuICB2YXIgdjEgPSB2YWx1ZSxcbiAgICAgIHYyID0gdmFsdWUsXG4gICAgICB0MSA9IF9nZXRUaW1lKCksXG4gICAgICB0MiA9IHQxLFxuICAgICAgbWluID0gbWluVGltZVJlZnJlc2ggfHwgNTAsXG4gICAgICBkcm9wVG9aZXJvVGltZSA9IE1hdGgubWF4KDUwMCwgbWluICogMyksXG4gICAgICB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodmFsdWUsIGZvcmNlKSB7XG4gICAgdmFyIHQgPSBfZ2V0VGltZSgpO1xuXG4gICAgaWYgKGZvcmNlIHx8IHQgLSB0MSA+IG1pbikge1xuICAgICAgdjIgPSB2MTtcbiAgICAgIHYxID0gdmFsdWU7XG4gICAgICB0MiA9IHQxO1xuICAgICAgdDEgPSB0O1xuICAgIH0gZWxzZSBpZiAodXNlRGVsdGEpIHtcbiAgICAgIHYxICs9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgdG90YWxseSBuZWNlc3NhcnksIGJ1dCBtYWtlcyBpdCBhIGJpdCBtb3JlIGFjY3VyYXRlIGJ5IGFkanVzdGluZyB0aGUgdjEgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2xvcGUuIFRoaXMgd2F5IHdlJ3JlIG5vdCBqdXN0IGlnbm9yaW5nIHRoZSBpbmNvbWluZyBkYXRhLiBSZW1vdmluZyBmb3Igbm93IGJlY2F1c2UgaXQgZG9lc24ndCBzZWVtIHRvIG1ha2UgbXVjaCBwcmFjdGljYWwgZGlmZmVyZW5jZSBhbmQgaXQncyBwcm9iYWJseSBub3Qgd29ydGggdGhlIGtiLlxuICAgICAgdjEgPSB2MiArICh2YWx1ZSAtIHYyKSAvICh0IC0gdDIpICogKHQxIC0gdDIpO1xuICAgIH1cbiAgfSxcbiAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdjIgPSB2MSA9IHVzZURlbHRhID8gMCA6IHYxO1xuICAgIHQyID0gdDEgPSAwO1xuICB9LFxuICAgICAgZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiBnZXRWZWxvY2l0eShsYXRlc3RWYWx1ZSkge1xuICAgIHZhciB0T2xkID0gdDIsXG4gICAgICAgIHZPbGQgPSB2MixcbiAgICAgICAgdCA9IF9nZXRUaW1lKCk7XG5cbiAgICAobGF0ZXN0VmFsdWUgfHwgbGF0ZXN0VmFsdWUgPT09IDApICYmIGxhdGVzdFZhbHVlICE9PSB2MSAmJiB1cGRhdGUobGF0ZXN0VmFsdWUpO1xuICAgIHJldHVybiB0MSA9PT0gdDIgfHwgdCAtIHQyID4gZHJvcFRvWmVyb1RpbWUgPyAwIDogKHYxICsgKHVzZURlbHRhID8gdk9sZCA6IC12T2xkKSkgLyAoKHVzZURlbHRhID8gdCA6IHQxKSAtIHRPbGQpICogMTAwMDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIHJlc2V0OiByZXNldCxcbiAgICBnZXRWZWxvY2l0eTogZ2V0VmVsb2NpdHlcbiAgfTtcbn0sXG4gICAgX2dldEV2ZW50ID0gZnVuY3Rpb24gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KSB7XG4gIHByZXZlbnREZWZhdWx0ICYmICFlLl9nc2FwQWxsb3cgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlO1xufSxcbiAgICBfZ2V0QWJzb2x1dGVNYXggPSBmdW5jdGlvbiBfZ2V0QWJzb2x1dGVNYXgoYSkge1xuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYSksXG4gICAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhKTtcbiAgcmV0dXJuIE1hdGguYWJzKG1heCkgPj0gTWF0aC5hYnMobWluKSA/IG1heCA6IG1pbjtcbn0sXG4gICAgX3NldFNjcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2V0U2Nyb2xsVHJpZ2dlcigpIHtcbiAgU2Nyb2xsVHJpZ2dlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsVHJpZ2dlcjtcbiAgU2Nyb2xsVHJpZ2dlciAmJiBTY3JvbGxUcmlnZ2VyLmNvcmUgJiYgX2ludGVncmF0ZSgpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChnc2FwICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gICAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG4gICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICBfcG9pbnRlclR5cGUgPSBcIm9ucG9pbnRlcmVudGVyXCIgaW4gX2JvZHkgPyBcInBvaW50ZXJcIiA6IFwibW91c2VcIjsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICBfaXNUb3VjaCA9IE9ic2VydmVyLmlzVG91Y2ggPSBfd2luLm1hdGNoTWVkaWEgJiYgX3dpbi5tYXRjaE1lZGlhKFwiKGhvdmVyOiBub25lKSwgKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlcyA/IDEgOiBcIm9udG91Y2hzdGFydFwiIGluIF93aW4gfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDAgPyAyIDogMDtcbiAgICBfZXZlbnRUeXBlcyA9IE9ic2VydmVyLmV2ZW50VHlwZXMgPSAoXCJvbnRvdWNoc3RhcnRcIiBpbiBfZG9jRWwgPyBcInRvdWNoc3RhcnQsdG91Y2htb3ZlLHRvdWNoY2FuY2VsLHRvdWNoZW5kXCIgOiAhKFwib25wb2ludGVyZG93blwiIGluIF9kb2NFbCkgPyBcIm1vdXNlZG93bixtb3VzZW1vdmUsbW91c2V1cCxtb3VzZXVwXCIgOiBcInBvaW50ZXJkb3duLHBvaW50ZXJtb3ZlLHBvaW50ZXJjYW5jZWwscG9pbnRlcnVwXCIpLnNwbGl0KFwiLFwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfc3RhcnR1cCA9IDA7XG4gICAgfSwgNTAwKTtcblxuICAgIF9zZXRTY3JvbGxUcmlnZ2VyKCk7XG5cbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG5cbiAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcbn07XG5cbl9ob3Jpem9udGFsLm9wID0gX3ZlcnRpY2FsO1xuX3Njcm9sbGVycy5jYWNoZSA9IDA7XG5leHBvcnQgdmFyIE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFycykge1xuICAgIHRoaXMuaW5pdCh2YXJzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKVwiKTtcbiAgICBTY3JvbGxUcmlnZ2VyIHx8IF9zZXRTY3JvbGxUcmlnZ2VyKCk7XG4gICAgdmFyIHRvbGVyYW5jZSA9IHZhcnMudG9sZXJhbmNlLFxuICAgICAgICBkcmFnTWluaW11bSA9IHZhcnMuZHJhZ01pbmltdW0sXG4gICAgICAgIHR5cGUgPSB2YXJzLnR5cGUsXG4gICAgICAgIHRhcmdldCA9IHZhcnMudGFyZ2V0LFxuICAgICAgICBsaW5lSGVpZ2h0ID0gdmFycy5saW5lSGVpZ2h0LFxuICAgICAgICBkZWJvdW5jZSA9IHZhcnMuZGVib3VuY2UsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdmFycy5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgb25TdG9wID0gdmFycy5vblN0b3AsXG4gICAgICAgIG9uU3RvcERlbGF5ID0gdmFycy5vblN0b3BEZWxheSxcbiAgICAgICAgaWdub3JlID0gdmFycy5pZ25vcmUsXG4gICAgICAgIHdoZWVsU3BlZWQgPSB2YXJzLndoZWVsU3BlZWQsXG4gICAgICAgIGV2ZW50ID0gdmFycy5ldmVudCxcbiAgICAgICAgb25EcmFnU3RhcnQgPSB2YXJzLm9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWdFbmQgPSB2YXJzLm9uRHJhZ0VuZCxcbiAgICAgICAgb25EcmFnID0gdmFycy5vbkRyYWcsXG4gICAgICAgIG9uUHJlc3MgPSB2YXJzLm9uUHJlc3MsXG4gICAgICAgIG9uUmVsZWFzZSA9IHZhcnMub25SZWxlYXNlLFxuICAgICAgICBvblJpZ2h0ID0gdmFycy5vblJpZ2h0LFxuICAgICAgICBvbkxlZnQgPSB2YXJzLm9uTGVmdCxcbiAgICAgICAgb25VcCA9IHZhcnMub25VcCxcbiAgICAgICAgb25Eb3duID0gdmFycy5vbkRvd24sXG4gICAgICAgIG9uQ2hhbmdlWCA9IHZhcnMub25DaGFuZ2VYLFxuICAgICAgICBvbkNoYW5nZVkgPSB2YXJzLm9uQ2hhbmdlWSxcbiAgICAgICAgb25DaGFuZ2UgPSB2YXJzLm9uQ2hhbmdlLFxuICAgICAgICBvblRvZ2dsZVggPSB2YXJzLm9uVG9nZ2xlWCxcbiAgICAgICAgb25Ub2dnbGVZID0gdmFycy5vblRvZ2dsZVksXG4gICAgICAgIG9uSG92ZXIgPSB2YXJzLm9uSG92ZXIsXG4gICAgICAgIG9uSG92ZXJFbmQgPSB2YXJzLm9uSG92ZXJFbmQsXG4gICAgICAgIG9uTW92ZSA9IHZhcnMub25Nb3ZlLFxuICAgICAgICBpZ25vcmVDaGVjayA9IHZhcnMuaWdub3JlQ2hlY2ssXG4gICAgICAgIGlzTm9ybWFsaXplciA9IHZhcnMuaXNOb3JtYWxpemVyLFxuICAgICAgICBvbkdlc3R1cmVTdGFydCA9IHZhcnMub25HZXN0dXJlU3RhcnQsXG4gICAgICAgIG9uR2VzdHVyZUVuZCA9IHZhcnMub25HZXN0dXJlRW5kLFxuICAgICAgICBvbldoZWVsID0gdmFycy5vbldoZWVsLFxuICAgICAgICBvbkVuYWJsZSA9IHZhcnMub25FbmFibGUsXG4gICAgICAgIG9uRGlzYWJsZSA9IHZhcnMub25EaXNhYmxlLFxuICAgICAgICBvbkNsaWNrID0gdmFycy5vbkNsaWNrLFxuICAgICAgICBzY3JvbGxTcGVlZCA9IHZhcnMuc2Nyb2xsU3BlZWQsXG4gICAgICAgIGNhcHR1cmUgPSB2YXJzLmNhcHR1cmUsXG4gICAgICAgIGFsbG93Q2xpY2tzID0gdmFycy5hbGxvd0NsaWNrcyxcbiAgICAgICAgbG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzLFxuICAgICAgICBvbkxvY2tBeGlzID0gdmFycy5vbkxvY2tBeGlzO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0ID0gX2dldFRhcmdldCh0YXJnZXQpIHx8IF9kb2NFbDtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIGlnbm9yZSAmJiAoaWdub3JlID0gZ3NhcC51dGlscy50b0FycmF5KGlnbm9yZSkpO1xuICAgIHRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCAxZS05O1xuICAgIGRyYWdNaW5pbXVtID0gZHJhZ01pbmltdW0gfHwgMDtcbiAgICB3aGVlbFNwZWVkID0gd2hlZWxTcGVlZCB8fCAxO1xuICAgIHNjcm9sbFNwZWVkID0gc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICB0eXBlID0gdHlwZSB8fCBcIndoZWVsLHRvdWNoLHBvaW50ZXJcIjtcbiAgICBkZWJvdW5jZSA9IGRlYm91bmNlICE9PSBmYWxzZTtcbiAgICBsaW5lSGVpZ2h0IHx8IChsaW5lSGVpZ2h0ID0gcGFyc2VGbG9hdChfd2luLmdldENvbXB1dGVkU3R5bGUoX2JvZHkpLmxpbmVIZWlnaHQpIHx8IDIyKTsgLy8gbm90ZTogYnJvd3NlciBtYXkgcmVwb3J0IFwibm9ybWFsXCIsIHNvIGRlZmF1bHQgdG8gMjIuXG5cbiAgICB2YXIgaWQsXG4gICAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLFxuICAgICAgICBkcmFnZ2VkLFxuICAgICAgICBtb3ZlZCxcbiAgICAgICAgd2hlZWxlZCxcbiAgICAgICAgbG9ja2VkLFxuICAgICAgICBheGlzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgcHJldkRlbHRhWCA9IDAsXG4gICAgICAgIHByZXZEZWx0YVkgPSAwLFxuICAgICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxuICAgICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYKCksXG4gICAgICAgIHNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpLFxuICAgICAgICBsaW1pdFRvVG91Y2ggPSB+dHlwZS5pbmRleE9mKFwidG91Y2hcIikgJiYgIX50eXBlLmluZGV4T2YoXCJwb2ludGVyXCIpICYmIF9ldmVudFR5cGVzWzBdID09PSBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgIC8vIGZvciBkZXZpY2VzIHRoYXQgYWNjb21tb2RhdGUgbW91c2UgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMsIHdlIG5lZWQgdG8gZGlzdGluZ3Vpc2guXG4gICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHRhcmdldCksXG4gICAgICAgIG93bmVyRG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgICAgZGVsdGFYID0gWzAsIDAsIDBdLFxuICAgICAgICAvLyB3aGVlbCwgc2Nyb2xsLCBwb2ludGVyL3RvdWNoXG4gICAgZGVsdGFZID0gWzAsIDAsIDBdLFxuICAgICAgICBvbkNsaWNrVGltZSA9IDAsXG4gICAgICAgIGNsaWNrQ2FwdHVyZSA9IGZ1bmN0aW9uIGNsaWNrQ2FwdHVyZSgpIHtcbiAgICAgIHJldHVybiBvbkNsaWNrVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAgICAgX2lnbm9yZUNoZWNrID0gZnVuY3Rpb24gX2lnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpIHtcbiAgICAgIHJldHVybiAoc2VsZi5ldmVudCA9IGUpICYmIGlnbm9yZSAmJiB+aWdub3JlLmluZGV4T2YoZS50YXJnZXQpIHx8IGlzUG9pbnRlck9yVG91Y2ggJiYgbGltaXRUb1RvdWNoICYmIGUucG9pbnRlclR5cGUgIT09IFwidG91Y2hcIiB8fCBpZ25vcmVDaGVjayAmJiBpZ25vcmVDaGVjayhlLCBpc1BvaW50ZXJPclRvdWNoKTtcbiAgICB9LFxuICAgICAgICBvblN0b3BGdW5jID0gZnVuY3Rpb24gb25TdG9wRnVuYygpIHtcbiAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7XG5cbiAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICBvblN0b3AgJiYgb25TdG9wKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBkeCA9IHNlbGYuZGVsdGFYID0gX2dldEFic29sdXRlTWF4KGRlbHRhWCksXG4gICAgICAgICAgZHkgPSBzZWxmLmRlbHRhWSA9IF9nZXRBYnNvbHV0ZU1heChkZWx0YVkpLFxuICAgICAgICAgIGNoYW5nZWRYID0gTWF0aC5hYnMoZHgpID49IHRvbGVyYW5jZSxcbiAgICAgICAgICBjaGFuZ2VkWSA9IE1hdGguYWJzKGR5KSA+PSB0b2xlcmFuY2U7XG5cbiAgICAgIG9uQ2hhbmdlICYmIChjaGFuZ2VkWCB8fCBjaGFuZ2VkWSkgJiYgb25DaGFuZ2Uoc2VsZiwgZHgsIGR5LCBkZWx0YVgsIGRlbHRhWSk7IC8vIGluIFNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsKCksIHdlIG5lZWQgdG8ga25vdyBpZiBpdCB3YXMgdG91Y2gvcG9pbnRlciBzbyB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgZGVsdGFYL2RlbHRhWSBBcnJheXMgYmVmb3JlIHdlIGNsZWFyIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoY2hhbmdlZFgpIHtcbiAgICAgICAgb25SaWdodCAmJiBzZWxmLmRlbHRhWCA+IDAgJiYgb25SaWdodChzZWxmKTtcbiAgICAgICAgb25MZWZ0ICYmIHNlbGYuZGVsdGFYIDwgMCAmJiBvbkxlZnQoc2VsZik7XG4gICAgICAgIG9uQ2hhbmdlWCAmJiBvbkNoYW5nZVgoc2VsZik7XG4gICAgICAgIG9uVG9nZ2xlWCAmJiBzZWxmLmRlbHRhWCA8IDAgIT09IHByZXZEZWx0YVggPCAwICYmIG9uVG9nZ2xlWChzZWxmKTtcbiAgICAgICAgcHJldkRlbHRhWCA9IHNlbGYuZGVsdGFYO1xuICAgICAgICBkZWx0YVhbMF0gPSBkZWx0YVhbMV0gPSBkZWx0YVhbMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZFkpIHtcbiAgICAgICAgb25Eb3duICYmIHNlbGYuZGVsdGFZID4gMCAmJiBvbkRvd24oc2VsZik7XG4gICAgICAgIG9uVXAgJiYgc2VsZi5kZWx0YVkgPCAwICYmIG9uVXAoc2VsZik7XG4gICAgICAgIG9uQ2hhbmdlWSAmJiBvbkNoYW5nZVkoc2VsZik7XG4gICAgICAgIG9uVG9nZ2xlWSAmJiBzZWxmLmRlbHRhWSA8IDAgIT09IHByZXZEZWx0YVkgPCAwICYmIG9uVG9nZ2xlWShzZWxmKTtcbiAgICAgICAgcHJldkRlbHRhWSA9IHNlbGYuZGVsdGFZO1xuICAgICAgICBkZWx0YVlbMF0gPSBkZWx0YVlbMV0gPSBkZWx0YVlbMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobW92ZWQgfHwgZHJhZ2dlZCkge1xuICAgICAgICBvbk1vdmUgJiYgb25Nb3ZlKHNlbGYpO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkKSB7XG4gICAgICAgICAgb25EcmFnKHNlbGYpO1xuICAgICAgICAgIGRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxvY2tlZCAmJiAhKGxvY2tlZCA9IGZhbHNlKSAmJiBvbkxvY2tBeGlzICYmIG9uTG9ja0F4aXMoc2VsZik7XG5cbiAgICAgIGlmICh3aGVlbGVkKSB7XG4gICAgICAgIG9uV2hlZWwoc2VsZik7XG4gICAgICAgIHdoZWVsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWQgPSAwO1xuICAgIH0sXG4gICAgICAgIG9uRGVsdGEgPSBmdW5jdGlvbiBvbkRlbHRhKHgsIHksIGluZGV4KSB7XG4gICAgICBkZWx0YVhbaW5kZXhdICs9IHg7XG4gICAgICBkZWx0YVlbaW5kZXhdICs9IHk7XG5cbiAgICAgIHNlbGYuX3Z4LnVwZGF0ZSh4KTtcblxuICAgICAgc2VsZi5fdnkudXBkYXRlKHkpO1xuXG4gICAgICBkZWJvdW5jZSA/IGlkIHx8IChpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpKSA6IHVwZGF0ZSgpO1xuICAgIH0sXG4gICAgICAgIG9uVG91Y2hPclBvaW50ZXJEZWx0YSA9IGZ1bmN0aW9uIG9uVG91Y2hPclBvaW50ZXJEZWx0YSh4LCB5KSB7XG4gICAgICBpZiAobG9ja0F4aXMgJiYgIWF4aXMpIHtcbiAgICAgICAgc2VsZi5heGlzID0gYXhpcyA9IE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeSkgPyBcInhcIiA6IFwieVwiO1xuICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyAhPT0gXCJ5XCIpIHtcbiAgICAgICAgZGVsdGFYWzJdICs9IHg7XG5cbiAgICAgICAgc2VsZi5fdngudXBkYXRlKHgsIHRydWUpOyAvLyB1cGRhdGUgdGhlIHZlbG9jaXR5IGFzIGZyZXF1ZW50bHkgYXMgcG9zc2libGUgaW5zdGVhZCBvZiBpbiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHNvIHRoYXQgdmVyeSBxdWljayB0b3VjaC1zY3JvbGxzIChmbGlja3MpIGZlZWwgbmF0dXJhbC4gSWYgaXQncyB0aGUgbW91c2UvdG91Y2gvcG9pbnRlciwgZm9yY2UgaXQgc28gdGhhdCB3ZSBnZXQgc25hcHB5L2FjY3VyYXRlIG1vbWVudHVtIHNjcm9sbC5cblxuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyAhPT0gXCJ4XCIpIHtcbiAgICAgICAgZGVsdGFZWzJdICs9IHk7XG5cbiAgICAgICAgc2VsZi5fdnkudXBkYXRlKHksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBkZWJvdW5jZSA/IGlkIHx8IChpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpKSA6IHVwZGF0ZSgpO1xuICAgIH0sXG4gICAgICAgIF9vbkRyYWcgPSBmdW5jdGlvbiBfb25EcmFnKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlID0gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgZHggPSB4IC0gc2VsZi54LFxuICAgICAgICAgIGR5ID0geSAtIHNlbGYueSxcbiAgICAgICAgICBpc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nO1xuICAgICAgc2VsZi54ID0geDtcbiAgICAgIHNlbGYueSA9IHk7XG5cbiAgICAgIGlmIChpc0RyYWdnaW5nIHx8IE1hdGguYWJzKHNlbGYuc3RhcnRYIC0geCkgPj0gZHJhZ01pbmltdW0gfHwgTWF0aC5hYnMoc2VsZi5zdGFydFkgLSB5KSA+PSBkcmFnTWluaW11bSkge1xuICAgICAgICBvbkRyYWcgJiYgKGRyYWdnZWQgPSB0cnVlKTtcbiAgICAgICAgaXNEcmFnZ2luZyB8fCAoc2VsZi5pc0RyYWdnaW5nID0gdHJ1ZSk7XG4gICAgICAgIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgICAgICBpc0RyYWdnaW5nIHx8IG9uRHJhZ1N0YXJ0ICYmIG9uRHJhZ1N0YXJ0KHNlbGYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIF9vblByZXNzID0gc2VsZi5vblByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmF4aXMgPSBheGlzID0gbnVsbDtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBlID0gX2dldEV2ZW50KGUpOyAvLyBub3RlOiBtYXkgbmVlZCB0byBwcmV2ZW50RGVmYXVsdCg/KSBXb24ndCBzaWRlLXNjcm9sbCBvbiBpT1MgU2FmYXJpIGlmIHdlIGRvLCB0aG91Z2guXG5cbiAgICAgIHByZXZEZWx0YVggPSBwcmV2RGVsdGFZID0gMDtcbiAgICAgIHNlbGYuc3RhcnRYID0gc2VsZi54ID0gZS5jbGllbnRYO1xuICAgICAgc2VsZi5zdGFydFkgPSBzZWxmLnkgPSBlLmNsaWVudFk7XG5cbiAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7IC8vIG90aGVyd2lzZSB0aGUgdDIgbWF5IGJlIHN0YWxlIGlmIHRoZSB1c2VyIHRvdWNoZXMgYW5kIGZsaWNrcyBzdXBlciBmYXN0IGFuZCByZWxlYXNlcyBpbiBsZXNzIHRoYW4gMiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGlja3MsIGNhdXNpbmcgdmVsb2NpdHkgdG8gYmUgMC5cblxuXG4gICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICBfYWRkTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCBwcmV2ZW50RGVmYXVsdCwgdHJ1ZSk7XG5cbiAgICAgIHNlbGYuZGVsdGFYID0gc2VsZi5kZWx0YVkgPSAwO1xuICAgICAgb25QcmVzcyAmJiBvblByZXNzKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vblJlbGVhc2UgPSBmdW5jdGlvbiBfb25SZWxlYXNlKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCB0cnVlKTtcblxuICAgICAgdmFyIHdhc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nICYmIChNYXRoLmFicyhzZWxmLnggLSBzZWxmLnN0YXJ0WCkgPiAzIHx8IE1hdGguYWJzKHNlbGYueSAtIHNlbGYuc3RhcnRZKSA+IDMpLFxuICAgICAgICAgIC8vIHNvbWUgdG91Y2ggZGV2aWNlcyBuZWVkIHNvbWUgd2lnZ2xlIHJvb20gaW4gdGVybXMgb2Ygc2Vuc2luZyBjbGlja3MgLSB0aGUgZmluZ2VyIG1heSBtb3ZlIGEgZmV3IHBpeGVscy5cbiAgICAgIGV2ZW50RGF0YSA9IF9nZXRFdmVudChlKTtcblxuICAgICAgaWYgKCF3YXNEcmFnZ2luZykge1xuICAgICAgICBzZWxmLl92eC5yZXNldCgpO1xuXG4gICAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ICYmIGFsbG93Q2xpY2tzKSB7XG4gICAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjA4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxuICAgICAgICAgICAgaWYgKF9nZXRUaW1lKCkgLSBvbkNsaWNrVGltZSA+IDMwMCAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ludGhldGljRXZlbnQgPSBvd25lckRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V2ZW50LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgX3dpbiwgMSwgZXZlbnREYXRhLnNjcmVlblgsIGV2ZW50RGF0YS5zY3JlZW5ZLCBldmVudERhdGEuY2xpZW50WCwgZXZlbnREYXRhLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHN5bnRoZXRpY0V2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgb25TdG9wICYmICFpc05vcm1hbGl6ZXIgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIG9uRHJhZ0VuZCAmJiB3YXNEcmFnZ2luZyAmJiBvbkRyYWdFbmQoc2VsZik7XG4gICAgICBvblJlbGVhc2UgJiYgb25SZWxlYXNlKHNlbGYsIHdhc0RyYWdnaW5nKTtcbiAgICB9LFxuICAgICAgICBfb25HZXN0dXJlU3RhcnQgPSBmdW5jdGlvbiBfb25HZXN0dXJlU3RhcnQoZSkge1xuICAgICAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSAmJiAoc2VsZi5pc0dlc3R1cmluZyA9IHRydWUpICYmIG9uR2VzdHVyZVN0YXJ0KGUsIHNlbGYuaXNEcmFnZ2luZyk7XG4gICAgfSxcbiAgICAgICAgX29uR2VzdHVyZUVuZCA9IGZ1bmN0aW9uIF9vbkdlc3R1cmVFbmQoKSB7XG4gICAgICByZXR1cm4gKHNlbGYuaXNHZXN0dXJpbmcgPSBmYWxzZSkgfHwgb25HZXN0dXJlRW5kKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIG9uU2Nyb2xsID0gZnVuY3Rpb24gb25TY3JvbGwoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gc2Nyb2xsRnVuY1goKSxcbiAgICAgICAgICB5ID0gc2Nyb2xsRnVuY1koKTtcbiAgICAgIG9uRGVsdGEoKHggLSBzY3JvbGxYKSAqIHNjcm9sbFNwZWVkLCAoeSAtIHNjcm9sbFkpICogc2Nyb2xsU3BlZWQsIDEpO1xuICAgICAgc2Nyb2xsWCA9IHg7XG4gICAgICBzY3JvbGxZID0geTtcbiAgICAgIG9uU3RvcCAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgIH0sXG4gICAgICAgIF9vbldoZWVsID0gZnVuY3Rpb24gX29uV2hlZWwoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUgPSBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpO1xuICAgICAgb25XaGVlbCAmJiAod2hlZWxlZCA9IHRydWUpO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSAoZS5kZWx0YU1vZGUgPT09IDEgPyBsaW5lSGVpZ2h0IDogZS5kZWx0YU1vZGUgPT09IDIgPyBfd2luLmlubmVySGVpZ2h0IDogMSkgKiB3aGVlbFNwZWVkO1xuICAgICAgb25EZWx0YShlLmRlbHRhWCAqIG11bHRpcGxpZXIsIGUuZGVsdGFZICogbXVsdGlwbGllciwgMCk7XG4gICAgICBvblN0b3AgJiYgIWlzTm9ybWFsaXplciAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgIH0sXG4gICAgICAgIF9vbk1vdmUgPSBmdW5jdGlvbiBfb25Nb3ZlKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgIGR4ID0geCAtIHNlbGYueCxcbiAgICAgICAgICBkeSA9IHkgLSBzZWxmLnk7XG4gICAgICBzZWxmLnggPSB4O1xuICAgICAgc2VsZi55ID0geTtcbiAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgIChkeCB8fCBkeSkgJiYgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XG4gICAgfSxcbiAgICAgICAgX29uSG92ZXIgPSBmdW5jdGlvbiBfb25Ib3ZlcihlKSB7XG4gICAgICBzZWxmLmV2ZW50ID0gZTtcbiAgICAgIG9uSG92ZXIoc2VsZik7XG4gICAgfSxcbiAgICAgICAgX29uSG92ZXJFbmQgPSBmdW5jdGlvbiBfb25Ib3ZlckVuZChlKSB7XG4gICAgICBzZWxmLmV2ZW50ID0gZTtcbiAgICAgIG9uSG92ZXJFbmQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG4gICAgICByZXR1cm4gX2lnbm9yZUNoZWNrKGUpIHx8IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCkgJiYgb25DbGljayhzZWxmKTtcbiAgICB9O1xuXG4gICAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYyA9IGdzYXAuZGVsYXllZENhbGwob25TdG9wRGVsYXkgfHwgMC4yNSwgb25TdG9wRnVuYykucGF1c2UoKTtcbiAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcbiAgICBzZWxmLl92eCA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuX3Z5ID0gX2dldFZlbG9jaXR5UHJvcCgwLCA1MCwgdHJ1ZSk7XG4gICAgc2VsZi5zY3JvbGxYID0gc2Nyb2xsRnVuY1g7XG4gICAgc2VsZi5zY3JvbGxZID0gc2Nyb2xsRnVuY1k7XG4gICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgdHlwZS5pbmRleE9mKFwic2Nyb2xsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIHByZXZlbnREZWZhdWx0LCBjYXB0dXJlKTtcbiAgICAgICAgdHlwZS5pbmRleE9mKFwid2hlZWxcIikgPj0gMCAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBcIndoZWVsXCIsIF9vbldoZWVsLCBwcmV2ZW50RGVmYXVsdCwgY2FwdHVyZSk7XG5cbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcInRvdWNoXCIpID49IDAgJiYgX2lzVG91Y2ggfHwgdHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA+PSAwKSB7XG4gICAgICAgICAgX2FkZExpc3RlbmVyKHRhcmdldCwgX2V2ZW50VHlwZXNbMF0sIF9vblByZXNzLCBwcmV2ZW50RGVmYXVsdCwgY2FwdHVyZSk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgICAgYWxsb3dDbGlja3MgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBvbkNsaWNrICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgX29uQ2xpY2spO1xuICAgICAgICAgIG9uR2VzdHVyZVN0YXJ0ICYmIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlc3RhcnRcIiwgX29uR2VzdHVyZVN0YXJ0KTtcbiAgICAgICAgICBvbkdlc3R1cmVFbmQgJiYgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVlbmRcIiwgX29uR2VzdHVyZUVuZCk7XG4gICAgICAgICAgb25Ib3ZlciAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImVudGVyXCIsIF9vbkhvdmVyKTtcbiAgICAgICAgICBvbkhvdmVyRW5kICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibGVhdmVcIiwgX29uSG92ZXJFbmQpO1xuICAgICAgICAgIG9uTW92ZSAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcIm1vdmVcIiwgX29uTW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGUgJiYgZS50eXBlICYmIF9vblByZXNzKGUpO1xuICAgICAgICBvbkVuYWJsZSAmJiBvbkVuYWJsZShzZWxmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlzRW5hYmxlZCkge1xuICAgICAgICAvLyBvbmx5IHJlbW92ZSB0aGUgX29uU2Nyb2xsIGxpc3RlbmVyIGlmIHRoZXJlIGFyZW4ndCBhbnkgb3RoZXJzIHRoYXQgcmVseSBvbiB0aGUgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgX29ic2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAhPT0gc2VsZiAmJiBfaXNWaWV3cG9ydChvLnRhcmdldCk7XG4gICAgICAgIH0pLmxlbmd0aCB8fCBfcmVtb3ZlTGlzdGVuZXIoaXNWaWV3cG9ydCA/IG93bmVyRG9jIDogdGFyZ2V0LCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgIGlmIChzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7XG5cbiAgICAgICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNWaWV3cG9ydCA/IG93bmVyRG9jIDogdGFyZ2V0LCBcInNjcm9sbFwiLCBvblNjcm9sbCwgY2FwdHVyZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgXCJ3aGVlbFwiLCBfb25XaGVlbCwgY2FwdHVyZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX2V2ZW50VHlwZXNbMF0sIF9vblByZXNzLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzNdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIGNsaWNrQ2FwdHVyZSwgdHJ1ZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBfb25DbGljayk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVzdGFydFwiLCBfb25HZXN0dXJlU3RhcnQpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlZW5kXCIsIF9vbkdlc3R1cmVFbmQpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwiZW50ZXJcIiwgX29uSG92ZXIpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibGVhdmVcIiwgX29uSG92ZXJFbmQpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcblxuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IHNlbGYuaXNQcmVzc2VkID0gc2VsZi5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIG9uRGlzYWJsZSAmJiBvbkRpc2FibGUoc2VsZik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZGlzYWJsZSgpO1xuXG4gICAgICB2YXIgaSA9IF9vYnNlcnZlcnMuaW5kZXhPZihzZWxmKTtcblxuICAgICAgaSA+PSAwICYmIF9vYnNlcnZlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgX25vcm1hbGl6ZXIgPT09IHNlbGYgJiYgKF9ub3JtYWxpemVyID0gMCk7XG4gICAgfTtcblxuICAgIF9vYnNlcnZlcnMucHVzaChzZWxmKTtcblxuICAgIGlzTm9ybWFsaXplciAmJiBfaXNWaWV3cG9ydCh0YXJnZXQpICYmIChfbm9ybWFsaXplciA9IHNlbGYpO1xuICAgIHNlbGYuZW5hYmxlKGV2ZW50KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcInZlbG9jaXR5WFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Z4LmdldFZlbG9jaXR5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlbG9jaXR5WVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Z5LmdldFZlbG9jaXR5KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmVyO1xufSgpO1xuT2JzZXJ2ZXIudmVyc2lvbiA9IFwiMy4xMS4yXCI7XG5cbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIodmFycyk7XG59O1xuXG5PYnNlcnZlci5yZWdpc3RlciA9IF9pbml0Q29yZTtcblxuT2JzZXJ2ZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX29ic2VydmVycy5zbGljZSgpO1xufTtcblxuT2JzZXJ2ZXIuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gX29ic2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gby52YXJzLmlkID09PSBpZDtcbiAgfSlbMF07XG59O1xuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oT2JzZXJ2ZXIpO1xuZXhwb3J0IHsgT2JzZXJ2ZXIgYXMgZGVmYXVsdCwgX2lzVmlld3BvcnQsIF9zY3JvbGxlcnMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfcHJveGllcywgX2dldFZlbG9jaXR5UHJvcCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX2dldFRhcmdldCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/Observer.js\n"));

/***/ }),

/***/ "./node_modules/gsap/PixiPlugin.js":
/*!*****************************************!*\
  !*** ./node_modules/gsap/PixiPlugin.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PixiPlugin\": function() { return /* binding */ PixiPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ PixiPlugin; }\n/* harmony export */ });\n/*!\n * PixiPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _win,\n    _splitColor,\n    _coreInitted,\n    _PIXI,\n    PropTween,\n    _getSetter,\n    _isV4,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _warn = function _warn(message) {\n  return console.warn(message);\n},\n    _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n    _lumR = 0.212671,\n    _lumG = 0.715160,\n    _lumB = 0.072169,\n    _applyMatrix = function _applyMatrix(m, m2) {\n  var temp = [],\n      i = 0,\n      z = 0,\n      y,\n      x;\n\n  for (y = 0; y < 4; y++) {\n    for (x = 0; x < 5; x++) {\n      z = x === 4 ? m[i + 4] : 0;\n      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n    }\n\n    i += 5;\n  }\n\n  return temp;\n},\n    _setSaturation = function _setSaturation(m, n) {\n  var inv = 1 - n,\n      r = inv * _lumR,\n      g = inv * _lumG,\n      b = inv * _lumB;\n  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);\n},\n    _colorize = function _colorize(m, color, amount) {\n  var c = _splitColor(color),\n      r = c[0] / 255,\n      g = c[1] / 255,\n      b = c[2] / 255,\n      inv = 1 - amount;\n\n  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);\n},\n    _setHue = function _setHue(m, n) {\n  n *= Math.PI / 180;\n  var c = Math.cos(n),\n      s = Math.sin(n);\n  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);\n},\n    _setContrast = function _setContrast(m, n) {\n  return _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);\n},\n    _getFilter = function _getFilter(target, type) {\n  var filterClass = _PIXI.filters[type],\n      filters = target.filters || [],\n      i = filters.length,\n      filter;\n  filterClass || _warn(type + \" not found. PixiPlugin.registerPIXI(PIXI)\");\n\n  while (--i > -1) {\n    if (filters[i] instanceof filterClass) {\n      return filters[i];\n    }\n  }\n\n  filter = new filterClass();\n\n  if (type === \"BlurFilter\") {\n    filter.blur = 0;\n  }\n\n  filters.push(filter);\n  target.filters = filters;\n  return filter;\n},\n    _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, plugin, cache, vars) {\n  //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.\n  plugin.add(cache, p, cache[p], vars[p]);\n\n  plugin._props.push(p);\n},\n    _applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {\n  var temp = new _PIXI.filters.ColorMatrixFilter();\n  temp.matrix = matrix;\n  temp.brightness(brightness, true);\n  return temp.matrix;\n},\n    _copy = function _copy(obj) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    copy[p] = obj[p];\n  }\n\n  return copy;\n},\n    _CMFdefaults = {\n  contrast: 1,\n  saturation: 1,\n  colorizeAmount: 0,\n  colorize: \"rgb(255,255,255)\",\n  hue: 0,\n  brightness: 1\n},\n    _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, pg) {\n  var filter = _getFilter(target, \"ColorMatrixFilter\"),\n      cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults),\n      combine = v.combineCMF && !(\"colorMatrixFilter\" in v && !v.colorMatrixFilter),\n      i,\n      matrix,\n      startMatrix;\n\n  startMatrix = filter.matrix;\n\n  if (v.resolution) {\n    filter.resolution = v.resolution;\n  }\n\n  if (v.matrix && v.matrix.length === startMatrix.length) {\n    matrix = v.matrix;\n\n    if (cache.contrast !== 1) {\n      _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, _CMFdefaults);\n    }\n\n    if (cache.hue) {\n      _addColorMatrixFilterCacheTween(\"hue\", pg, cache, _CMFdefaults);\n    }\n\n    if (cache.brightness !== 1) {\n      _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, _CMFdefaults);\n    }\n\n    if (cache.colorizeAmount) {\n      _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, _CMFdefaults);\n\n      _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, _CMFdefaults);\n    }\n\n    if (cache.saturation !== 1) {\n      _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, _CMFdefaults);\n    }\n  } else {\n    matrix = _idMatrix.slice();\n\n    if (v.contrast != null) {\n      matrix = _setContrast(matrix, +v.contrast);\n\n      _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, v);\n    } else if (cache.contrast !== 1) {\n      if (combine) {\n        matrix = _setContrast(matrix, cache.contrast);\n      } else {\n        _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, _CMFdefaults);\n      }\n    }\n\n    if (v.hue != null) {\n      matrix = _setHue(matrix, +v.hue);\n\n      _addColorMatrixFilterCacheTween(\"hue\", pg, cache, v);\n    } else if (cache.hue) {\n      if (combine) {\n        matrix = _setHue(matrix, cache.hue);\n      } else {\n        _addColorMatrixFilterCacheTween(\"hue\", pg, cache, _CMFdefaults);\n      }\n    }\n\n    if (v.brightness != null) {\n      matrix = _applyBrightnessToMatrix(+v.brightness, matrix);\n\n      _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, v);\n    } else if (cache.brightness !== 1) {\n      if (combine) {\n        matrix = _applyBrightnessToMatrix(cache.brightness, matrix);\n      } else {\n        _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, _CMFdefaults);\n      }\n    }\n\n    if (v.colorize != null) {\n      v.colorizeAmount = \"colorizeAmount\" in v ? +v.colorizeAmount : 1;\n      matrix = _colorize(matrix, v.colorize, v.colorizeAmount);\n\n      _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, v);\n\n      _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, v);\n    } else if (cache.colorizeAmount) {\n      if (combine) {\n        matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);\n      } else {\n        _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, _CMFdefaults);\n\n        _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, _CMFdefaults);\n      }\n    }\n\n    if (v.saturation != null) {\n      matrix = _setSaturation(matrix, +v.saturation);\n\n      _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, v);\n    } else if (cache.saturation !== 1) {\n      if (combine) {\n        matrix = _setSaturation(matrix, cache.saturation);\n      } else {\n        _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, _CMFdefaults);\n      }\n    }\n  }\n\n  i = matrix.length;\n\n  while (--i > -1) {\n    if (matrix[i] !== startMatrix[i]) {\n      pg.add(startMatrix, i, startMatrix[i], matrix[i], \"colorMatrixFilter\");\n    }\n  }\n\n  pg._props.push(\"colorMatrixFilter\");\n},\n    _renderColor = function _renderColor(ratio, _ref) {\n  var t = _ref.t,\n      p = _ref.p,\n      color = _ref.color,\n      set = _ref.set;\n  set(t, p, color[0] << 16 | color[1] << 8 | color[2]);\n},\n    _renderDirtyCache = function _renderDirtyCache(ratio, _ref2) {\n  var g = _ref2.g;\n\n  if (g) {\n    //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the \"dirty\" and \"clearDirty\" values. If we don't do this, the values will be tween properly, but not rendered.\n    g.dirty++;\n    g.clearDirty++;\n  }\n},\n    _renderAutoAlpha = function _renderAutoAlpha(ratio, data) {\n  data.t.visible = !!data.t.alpha;\n},\n    _addColorTween = function _addColorTween(target, p, value, plugin) {\n  var currentValue = target[p],\n      startColor = _splitColor(_isFunction(currentValue) ? target[p.indexOf(\"set\") || !_isFunction(target[\"get\" + p.substr(3)]) ? p : \"get\" + p.substr(3)]() : currentValue),\n      endColor = _splitColor(value);\n\n  plugin._pt = new PropTween(plugin._pt, target, p, 0, 0, _renderColor, {\n    t: target,\n    p: p,\n    color: startColor,\n    set: _getSetter(target, p)\n  });\n  plugin.add(startColor, 0, startColor[0], endColor[0]);\n  plugin.add(startColor, 1, startColor[1], endColor[1]);\n  plugin.add(startColor, 2, startColor[2], endColor[2]);\n},\n    _colorProps = {\n  tint: 1,\n  lineColor: 1,\n  fillColor: 1\n},\n    _xyContexts = \"position,scale,skew,pivot,anchor,tilePosition,tileScale\".split(\",\"),\n    _contexts = {\n  x: \"position\",\n  y: \"position\",\n  tileX: \"tilePosition\",\n  tileY: \"tilePosition\"\n},\n    _colorMatrixFilterProps = {\n  colorMatrixFilter: 1,\n  saturation: 1,\n  contrast: 1,\n  hue: 1,\n  colorize: 1,\n  colorizeAmount: 1,\n  brightness: 1,\n  combineCMF: 1\n},\n    _DEG2RAD = Math.PI / 180,\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _degreesToRadians = function _degreesToRadians(value) {\n  return _isString(value) && value.charAt(1) === \"=\" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;\n},\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 100000) / 100000, data);\n},\n    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, radians) {\n  var cap = 360 * (radians ? _DEG2RAD : 1),\n      isString = _isString(endValue),\n      relative = isString && endValue.charAt(1) === \"=\" ? +(endValue.charAt(0) + \"1\") : 0,\n      endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD : 1),\n      change = relative ? endNum * relative : endNum - startNum,\n      finalValue = startNum + change,\n      direction,\n      pt;\n\n  if (isString) {\n    direction = endValue.split(\"_\")[1];\n\n    if (direction === \"short\") {\n      change %= cap;\n\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n\n    if (direction === \"cw\" && change < 0) {\n      change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;\n    } else if (direction === \"ccw\" && change > 0) {\n      change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;\n    }\n  }\n\n  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  return pt;\n},\n    _initCore = function _initCore() {\n  if (_windowExists()) {\n    _win = window;\n    gsap = _getGSAP();\n    _PIXI = _coreInitted = _PIXI || _win.PIXI;\n    _isV4 = _PIXI && _PIXI.VERSION && _PIXI.VERSION.charAt(0) === \"4\";\n\n    _splitColor = function _splitColor(color) {\n      return gsap.utils.splitColor((color + \"\").substr(0, 2) === \"0x\" ? \"#\" + color.substr(2) : color);\n    }; // some colors in PIXI are reported as \"0xFF4421\" instead of \"#FF4421\".\n\n  }\n},\n    i,\n    p; //context setup...\n\n\nfor (i = 0; i < _xyContexts.length; i++) {\n  p = _xyContexts[i];\n  _contexts[p + \"X\"] = p;\n  _contexts[p + \"Y\"] = p;\n}\n\nvar PixiPlugin = {\n  version: \"3.11.2\",\n  name: \"pixi\",\n  register: function register(core, Plugin, propTween) {\n    gsap = core;\n    PropTween = propTween;\n    _getSetter = Plugin.getSetter;\n\n    _initCore();\n  },\n  registerPIXI: function registerPIXI(pixi) {\n    _PIXI = pixi;\n  },\n  init: function init(target, values, tween, index, targets) {\n    _PIXI || _initCore();\n\n    if (!_PIXI || !(target instanceof _PIXI.DisplayObject)) {\n      console.warn(target, \"is not a DisplayObject or PIXI was not found. PixiPlugin.registerPIXI(PIXI);\");\n      return false;\n    }\n\n    var context, axis, value, colorMatrix, filter, p, padding, i, data;\n\n    for (p in values) {\n      context = _contexts[p];\n      value = values[p];\n\n      if (context) {\n        axis = ~p.charAt(p.length - 1).toLowerCase().indexOf(\"x\") ? \"x\" : \"y\";\n        this.add(target[context], axis, target[context][axis], context === \"skew\" ? _degreesToRadians(value) : value, 0, 0, 0, 0, 0, 1);\n      } else if (p === \"scale\" || p === \"anchor\" || p === \"pivot\" || p === \"tileScale\") {\n        this.add(target[p], \"x\", target[p].x, value);\n        this.add(target[p], \"y\", target[p].y, value);\n      } else if (p === \"rotation\" || p === \"angle\") {\n        //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.\n        _addRotationalPropTween(this, target, p, target[p], value, p === \"rotation\");\n      } else if (_colorMatrixFilterProps[p]) {\n        if (!colorMatrix) {\n          _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);\n\n          colorMatrix = true;\n        }\n      } else if (p === \"blur\" || p === \"blurX\" || p === \"blurY\" || p === \"blurPadding\") {\n        filter = _getFilter(target, \"BlurFilter\");\n        this.add(filter, p, filter[p], value);\n\n        if (values.blurPadding !== 0) {\n          padding = values.blurPadding || Math.max(filter[p], value) * 2;\n          i = target.filters.length;\n\n          while (--i > -1) {\n            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.\n          }\n        }\n      } else if (_colorProps[p]) {\n        if ((p === \"lineColor\" || p === \"fillColor\") && target instanceof _PIXI.Graphics) {\n          data = (target.geometry || target).graphicsData; //\"geometry\" was introduced in PIXI version 5\n\n          this._pt = new PropTween(this._pt, target, p, 0, 0, _renderDirtyCache, {\n            g: target.geometry || target\n          });\n          i = data.length;\n\n          while (--i > -1) {\n            _addColorTween(_isV4 ? data[i] : data[i][p.substr(0, 4) + \"Style\"], _isV4 ? p : \"color\", value, this);\n          }\n        } else {\n          _addColorTween(target, p, value, this);\n        }\n      } else if (p === \"autoAlpha\") {\n        this._pt = new PropTween(this._pt, target, \"visible\", 0, 0, _renderAutoAlpha);\n        this.add(target, \"alpha\", target.alpha, value);\n\n        this._props.push(\"alpha\", \"visible\");\n      } else if (p !== \"resolution\") {\n        this.add(target, p, \"get\", value);\n      }\n\n      this._props.push(p);\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(PixiPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9QaXhpUGx1Z2luLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsT0FBTzs7O0FBR1AsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvUGl4aVBsdWdpbi5qcz8xZDA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUGl4aVBsdWdpbiAzLjExLjJcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9zcGxpdENvbG9yLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfUElYSSxcbiAgICBQcm9wVHdlZW4sXG4gICAgX2dldFNldHRlcixcbiAgICBfaXNWNCxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2lkTWF0cml4ID0gWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdLFxuICAgIF9sdW1SID0gMC4yMTI2NzEsXG4gICAgX2x1bUcgPSAwLjcxNTE2MCxcbiAgICBfbHVtQiA9IDAuMDcyMTY5LFxuICAgIF9hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIF9hcHBseU1hdHJpeChtLCBtMikge1xuICB2YXIgdGVtcCA9IFtdLFxuICAgICAgaSA9IDAsXG4gICAgICB6ID0gMCxcbiAgICAgIHksXG4gICAgICB4O1xuXG4gIGZvciAoeSA9IDA7IHkgPCA0OyB5KyspIHtcbiAgICBmb3IgKHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICB6ID0geCA9PT0gNCA/IG1baSArIDRdIDogMDtcbiAgICAgIHRlbXBbaSArIHhdID0gbVtpXSAqIG0yW3hdICsgbVtpICsgMV0gKiBtMlt4ICsgNV0gKyBtW2kgKyAyXSAqIG0yW3ggKyAxMF0gKyBtW2kgKyAzXSAqIG0yW3ggKyAxNV0gKyB6O1xuICAgIH1cblxuICAgIGkgKz0gNTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wO1xufSxcbiAgICBfc2V0U2F0dXJhdGlvbiA9IGZ1bmN0aW9uIF9zZXRTYXR1cmF0aW9uKG0sIG4pIHtcbiAgdmFyIGludiA9IDEgLSBuLFxuICAgICAgciA9IGludiAqIF9sdW1SLFxuICAgICAgZyA9IGludiAqIF9sdW1HLFxuICAgICAgYiA9IGludiAqIF9sdW1CO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtyICsgbiwgZywgYiwgMCwgMCwgciwgZyArIG4sIGIsIDAsIDAsIHIsIGcsIGIgKyBuLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9jb2xvcml6ZSA9IGZ1bmN0aW9uIF9jb2xvcml6ZShtLCBjb2xvciwgYW1vdW50KSB7XG4gIHZhciBjID0gX3NwbGl0Q29sb3IoY29sb3IpLFxuICAgICAgciA9IGNbMF0gLyAyNTUsXG4gICAgICBnID0gY1sxXSAvIDI1NSxcbiAgICAgIGIgPSBjWzJdIC8gMjU1LFxuICAgICAgaW52ID0gMSAtIGFtb3VudDtcblxuICByZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9zZXRIdWUgPSBmdW5jdGlvbiBfc2V0SHVlKG0sIG4pIHtcbiAgbiAqPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgYyA9IE1hdGguY29zKG4pLFxuICAgICAgcyA9IE1hdGguc2luKG4pO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtfbHVtUiArIGMgKiAoMSAtIF9sdW1SKSArIHMgKiAtX2x1bVIsIF9sdW1HICsgYyAqIC1fbHVtRyArIHMgKiAtX2x1bUcsIF9sdW1CICsgYyAqIC1fbHVtQiArIHMgKiAoMSAtIF9sdW1CKSwgMCwgMCwgX2x1bVIgKyBjICogLV9sdW1SICsgcyAqIDAuMTQzLCBfbHVtRyArIGMgKiAoMSAtIF9sdW1HKSArIHMgKiAwLjE0LCBfbHVtQiArIGMgKiAtX2x1bUIgKyBzICogLTAuMjgzLCAwLCAwLCBfbHVtUiArIGMgKiAtX2x1bVIgKyBzICogLSgxIC0gX2x1bVIpLCBfbHVtRyArIGMgKiAtX2x1bUcgKyBzICogX2x1bUcsIF9sdW1CICsgYyAqICgxIC0gX2x1bUIpICsgcyAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXSwgbSk7XG59LFxuICAgIF9zZXRDb250cmFzdCA9IGZ1bmN0aW9uIF9zZXRDb250cmFzdChtLCBuKSB7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW24sIDAsIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIG4sIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIG4sIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX2dldEZpbHRlciA9IGZ1bmN0aW9uIF9nZXRGaWx0ZXIodGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBmaWx0ZXJDbGFzcyA9IF9QSVhJLmZpbHRlcnNbdHlwZV0sXG4gICAgICBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG4gICAgICBpID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICBmaWx0ZXI7XG4gIGZpbHRlckNsYXNzIHx8IF93YXJuKHR5cGUgKyBcIiBub3QgZm91bmQuIFBpeGlQbHVnaW4ucmVnaXN0ZXJQSVhJKFBJWEkpXCIpO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGlmIChmaWx0ZXJzW2ldIGluc3RhbmNlb2YgZmlsdGVyQ2xhc3MpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJzW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZpbHRlciA9IG5ldyBmaWx0ZXJDbGFzcygpO1xuXG4gIGlmICh0eXBlID09PSBcIkJsdXJGaWx0ZXJcIikge1xuICAgIGZpbHRlci5ibHVyID0gMDtcbiAgfVxuXG4gIGZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICB0YXJnZXQuZmlsdGVycyA9IGZpbHRlcnM7XG4gIHJldHVybiBmaWx0ZXI7XG59LFxuICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4gPSBmdW5jdGlvbiBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKHAsIHBsdWdpbiwgY2FjaGUsIHZhcnMpIHtcbiAgLy93ZSBjYWNoZSB0aGUgQ29sb3JNYXRyaXhGaWx0ZXIgY29tcG9uZW50cyBpbiBhIF9nc0NvbG9yTWF0cml4RmlsdGVyIG9iamVjdCBhdHRhY2hlZCB0byB0aGUgdGFyZ2V0IG9iamVjdCBzbyB0aGF0IGl0J3MgZWFzeSB0byBncmFiIHRoZSBjdXJyZW50IHZhbHVlIGF0IGFueSB0aW1lLlxuICBwbHVnaW4uYWRkKGNhY2hlLCBwLCBjYWNoZVtwXSwgdmFyc1twXSk7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xufSxcbiAgICBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXggPSBmdW5jdGlvbiBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgoYnJpZ2h0bmVzcywgbWF0cml4KSB7XG4gIHZhciB0ZW1wID0gbmV3IF9QSVhJLmZpbHRlcnMuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcbiAgdGVtcC5tYXRyaXggPSBtYXRyaXg7XG4gIHRlbXAuYnJpZ2h0bmVzcyhicmlnaHRuZXNzLCB0cnVlKTtcbiAgcmV0dXJuIHRlbXAubWF0cml4O1xufSxcbiAgICBfY29weSA9IGZ1bmN0aW9uIF9jb3B5KG9iaikge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgY29weVtwXSA9IG9ialtwXTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfQ01GZGVmYXVsdHMgPSB7XG4gIGNvbnRyYXN0OiAxLFxuICBzYXR1cmF0aW9uOiAxLFxuICBjb2xvcml6ZUFtb3VudDogMCxcbiAgY29sb3JpemU6IFwicmdiKDI1NSwyNTUsMjU1KVwiLFxuICBodWU6IDAsXG4gIGJyaWdodG5lc3M6IDFcbn0sXG4gICAgX3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIgPSBmdW5jdGlvbiBfcGFyc2VDb2xvck1hdHJpeEZpbHRlcih0YXJnZXQsIHYsIHBnKSB7XG4gIHZhciBmaWx0ZXIgPSBfZ2V0RmlsdGVyKHRhcmdldCwgXCJDb2xvck1hdHJpeEZpbHRlclwiKSxcbiAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc0NvbG9yTWF0cml4RmlsdGVyID0gdGFyZ2V0Ll9nc0NvbG9yTWF0cml4RmlsdGVyIHx8IF9jb3B5KF9DTUZkZWZhdWx0cyksXG4gICAgICBjb21iaW5lID0gdi5jb21iaW5lQ01GICYmICEoXCJjb2xvck1hdHJpeEZpbHRlclwiIGluIHYgJiYgIXYuY29sb3JNYXRyaXhGaWx0ZXIpLFxuICAgICAgaSxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHN0YXJ0TWF0cml4O1xuXG4gIHN0YXJ0TWF0cml4ID0gZmlsdGVyLm1hdHJpeDtcblxuICBpZiAodi5yZXNvbHV0aW9uKSB7XG4gICAgZmlsdGVyLnJlc29sdXRpb24gPSB2LnJlc29sdXRpb247XG4gIH1cblxuICBpZiAodi5tYXRyaXggJiYgdi5tYXRyaXgubGVuZ3RoID09PSBzdGFydE1hdHJpeC5sZW5ndGgpIHtcbiAgICBtYXRyaXggPSB2Lm1hdHJpeDtcblxuICAgIGlmIChjYWNoZS5jb250cmFzdCAhPT0gMSkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuaHVlKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiaHVlXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuYnJpZ2h0bmVzcyAhPT0gMSkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImJyaWdodG5lc3NcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5jb2xvcml6ZUFtb3VudCkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplQW1vdW50XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc2F0dXJhdGlvbiAhPT0gMSkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcInNhdHVyYXRpb25cIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRyaXggPSBfaWRNYXRyaXguc2xpY2UoKTtcblxuICAgIGlmICh2LmNvbnRyYXN0ICE9IG51bGwpIHtcbiAgICAgIG1hdHJpeCA9IF9zZXRDb250cmFzdChtYXRyaXgsICt2LmNvbnRyYXN0KTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgdik7XG4gICAgfSBlbHNlIGlmIChjYWNoZS5jb250cmFzdCAhPT0gMSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX3NldENvbnRyYXN0KG1hdHJpeCwgY2FjaGUuY29udHJhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodi5odWUgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX3NldEh1ZShtYXRyaXgsICt2Lmh1ZSk7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmh1ZSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX3NldEh1ZShtYXRyaXgsIGNhY2hlLmh1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiaHVlXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodi5icmlnaHRuZXNzICE9IG51bGwpIHtcbiAgICAgIG1hdHJpeCA9IF9hcHBseUJyaWdodG5lc3NUb01hdHJpeCgrdi5icmlnaHRuZXNzLCBtYXRyaXgpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuYnJpZ2h0bmVzcyAhPT0gMSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4KGNhY2hlLmJyaWdodG5lc3MsIG1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHYuY29sb3JpemUgIT0gbnVsbCkge1xuICAgICAgdi5jb2xvcml6ZUFtb3VudCA9IFwiY29sb3JpemVBbW91bnRcIiBpbiB2ID8gK3YuY29sb3JpemVBbW91bnQgOiAxO1xuICAgICAgbWF0cml4ID0gX2NvbG9yaXplKG1hdHJpeCwgdi5jb2xvcml6ZSwgdi5jb2xvcml6ZUFtb3VudCk7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZVwiLCBwZywgY2FjaGUsIHYpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmNvbG9yaXplQW1vdW50KSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCBjYWNoZS5jb2xvcml6ZSwgY2FjaGUuY29sb3JpemVBbW91bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblxuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2LnNhdHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX3NldFNhdHVyYXRpb24obWF0cml4LCArdi5zYXR1cmF0aW9uKTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcInNhdHVyYXRpb25cIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLnNhdHVyYXRpb24gIT09IDEpIHtcbiAgICAgIGlmIChjb21iaW5lKSB7XG4gICAgICAgIG1hdHJpeCA9IF9zZXRTYXR1cmF0aW9uKG1hdHJpeCwgY2FjaGUuc2F0dXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwic2F0dXJhdGlvblwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaSA9IG1hdHJpeC5sZW5ndGg7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKG1hdHJpeFtpXSAhPT0gc3RhcnRNYXRyaXhbaV0pIHtcbiAgICAgIHBnLmFkZChzdGFydE1hdHJpeCwgaSwgc3RhcnRNYXRyaXhbaV0sIG1hdHJpeFtpXSwgXCJjb2xvck1hdHJpeEZpbHRlclwiKTtcbiAgICB9XG4gIH1cblxuICBwZy5fcHJvcHMucHVzaChcImNvbG9yTWF0cml4RmlsdGVyXCIpO1xufSxcbiAgICBfcmVuZGVyQ29sb3IgPSBmdW5jdGlvbiBfcmVuZGVyQ29sb3IocmF0aW8sIF9yZWYpIHtcbiAgdmFyIHQgPSBfcmVmLnQsXG4gICAgICBwID0gX3JlZi5wLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgc2V0ID0gX3JlZi5zZXQ7XG4gIHNldCh0LCBwLCBjb2xvclswXSA8PCAxNiB8IGNvbG9yWzFdIDw8IDggfCBjb2xvclsyXSk7XG59LFxuICAgIF9yZW5kZXJEaXJ0eUNhY2hlID0gZnVuY3Rpb24gX3JlbmRlckRpcnR5Q2FjaGUocmF0aW8sIF9yZWYyKSB7XG4gIHZhciBnID0gX3JlZjIuZztcblxuICBpZiAoZykge1xuICAgIC8vaW4gb3JkZXIgZm9yIFBpeGlKUyB0byBhY3R1YWxseSByZWRyYXcgR3JhcGhpY3NEYXRhLCB3ZSd2ZSBnb3R0YSBpbmNyZW1lbnQgdGhlIFwiZGlydHlcIiBhbmQgXCJjbGVhckRpcnR5XCIgdmFsdWVzLiBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGUgdmFsdWVzIHdpbGwgYmUgdHdlZW4gcHJvcGVybHksIGJ1dCBub3QgcmVuZGVyZWQuXG4gICAgZy5kaXJ0eSsrO1xuICAgIGcuY2xlYXJEaXJ0eSsrO1xuICB9XG59LFxuICAgIF9yZW5kZXJBdXRvQWxwaGEgPSBmdW5jdGlvbiBfcmVuZGVyQXV0b0FscGhhKHJhdGlvLCBkYXRhKSB7XG4gIGRhdGEudC52aXNpYmxlID0gISFkYXRhLnQuYWxwaGE7XG59LFxuICAgIF9hZGRDb2xvclR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbG9yVHdlZW4odGFyZ2V0LCBwLCB2YWx1ZSwgcGx1Z2luKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcF0sXG4gICAgICBzdGFydENvbG9yID0gX3NwbGl0Q29sb3IoX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IHRhcmdldFtwLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMyldKCkgOiBjdXJyZW50VmFsdWUpLFxuICAgICAgZW5kQ29sb3IgPSBfc3BsaXRDb2xvcih2YWx1ZSk7XG5cbiAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwLCAwLCAwLCBfcmVuZGVyQ29sb3IsIHtcbiAgICB0OiB0YXJnZXQsXG4gICAgcDogcCxcbiAgICBjb2xvcjogc3RhcnRDb2xvcixcbiAgICBzZXQ6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwKVxuICB9KTtcbiAgcGx1Z2luLmFkZChzdGFydENvbG9yLCAwLCBzdGFydENvbG9yWzBdLCBlbmRDb2xvclswXSk7XG4gIHBsdWdpbi5hZGQoc3RhcnRDb2xvciwgMSwgc3RhcnRDb2xvclsxXSwgZW5kQ29sb3JbMV0pO1xuICBwbHVnaW4uYWRkKHN0YXJ0Q29sb3IsIDIsIHN0YXJ0Q29sb3JbMl0sIGVuZENvbG9yWzJdKTtcbn0sXG4gICAgX2NvbG9yUHJvcHMgPSB7XG4gIHRpbnQ6IDEsXG4gIGxpbmVDb2xvcjogMSxcbiAgZmlsbENvbG9yOiAxXG59LFxuICAgIF94eUNvbnRleHRzID0gXCJwb3NpdGlvbixzY2FsZSxza2V3LHBpdm90LGFuY2hvcix0aWxlUG9zaXRpb24sdGlsZVNjYWxlXCIuc3BsaXQoXCIsXCIpLFxuICAgIF9jb250ZXh0cyA9IHtcbiAgeDogXCJwb3NpdGlvblwiLFxuICB5OiBcInBvc2l0aW9uXCIsXG4gIHRpbGVYOiBcInRpbGVQb3NpdGlvblwiLFxuICB0aWxlWTogXCJ0aWxlUG9zaXRpb25cIlxufSxcbiAgICBfY29sb3JNYXRyaXhGaWx0ZXJQcm9wcyA9IHtcbiAgY29sb3JNYXRyaXhGaWx0ZXI6IDEsXG4gIHNhdHVyYXRpb246IDEsXG4gIGNvbnRyYXN0OiAxLFxuICBodWU6IDEsXG4gIGNvbG9yaXplOiAxLFxuICBjb2xvcml6ZUFtb3VudDogMSxcbiAgYnJpZ2h0bmVzczogMSxcbiAgY29tYmluZUNNRjogMVxufSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9kZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gX2RlZ3JlZXNUb1JhZGlhbnModmFsdWUpIHtcbiAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/IHZhbHVlLnN1YnN0cigwLCAyKSArIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqIF9ERUcyUkFEIDogdmFsdWUgKiBfREVHMlJBRDtcbn0sXG4gICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMDApIC8gMTAwMDAwLCBkYXRhKTtcbn0sXG4gICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUm90YXRpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmFkaWFucykge1xuICB2YXIgY2FwID0gMzYwICogKHJhZGlhbnMgPyBfREVHMlJBRCA6IDEpLFxuICAgICAgaXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuICAgICAgcmVsYXRpdmUgPSBpc1N0cmluZyAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwLFxuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChyZWxhdGl2ZSA/IGVuZFZhbHVlLnN1YnN0cigyKSA6IGVuZFZhbHVlKSAqIChyYWRpYW5zID8gX0RFRzJSQUQgOiAxKSxcbiAgICAgIGNoYW5nZSA9IHJlbGF0aXZlID8gZW5kTnVtICogcmVsYXRpdmUgOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIDFlMTApICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogMWUxMCkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBnc2FwID0gX2dldEdTQVAoKTtcbiAgICBfUElYSSA9IF9jb3JlSW5pdHRlZCA9IF9QSVhJIHx8IF93aW4uUElYSTtcbiAgICBfaXNWNCA9IF9QSVhJICYmIF9QSVhJLlZFUlNJT04gJiYgX1BJWEkuVkVSU0lPTi5jaGFyQXQoMCkgPT09IFwiNFwiO1xuXG4gICAgX3NwbGl0Q29sb3IgPSBmdW5jdGlvbiBfc3BsaXRDb2xvcihjb2xvcikge1xuICAgICAgcmV0dXJuIGdzYXAudXRpbHMuc3BsaXRDb2xvcigoY29sb3IgKyBcIlwiKS5zdWJzdHIoMCwgMikgPT09IFwiMHhcIiA/IFwiI1wiICsgY29sb3Iuc3Vic3RyKDIpIDogY29sb3IpO1xuICAgIH07IC8vIHNvbWUgY29sb3JzIGluIFBJWEkgYXJlIHJlcG9ydGVkIGFzIFwiMHhGRjQ0MjFcIiBpbnN0ZWFkIG9mIFwiI0ZGNDQyMVwiLlxuXG4gIH1cbn0sXG4gICAgaSxcbiAgICBwOyAvL2NvbnRleHQgc2V0dXAuLi5cblxuXG5mb3IgKGkgPSAwOyBpIDwgX3h5Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgcCA9IF94eUNvbnRleHRzW2ldO1xuICBfY29udGV4dHNbcCArIFwiWFwiXSA9IHA7XG4gIF9jb250ZXh0c1twICsgXCJZXCJdID0gcDtcbn1cblxuZXhwb3J0IHZhciBQaXhpUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTEuMlwiLFxuICBuYW1lOiBcInBpeGlcIixcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUsIFBsdWdpbiwgcHJvcFR3ZWVuKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG4gICAgUHJvcFR3ZWVuID0gcHJvcFR3ZWVuO1xuICAgIF9nZXRTZXR0ZXIgPSBQbHVnaW4uZ2V0U2V0dGVyO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH0sXG4gIHJlZ2lzdGVyUElYSTogZnVuY3Rpb24gcmVnaXN0ZXJQSVhJKHBpeGkpIHtcbiAgICBfUElYSSA9IHBpeGk7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZXMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIF9QSVhJIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgaWYgKCFfUElYSSB8fCAhKHRhcmdldCBpbnN0YW5jZW9mIF9QSVhJLkRpc3BsYXlPYmplY3QpKSB7XG4gICAgICBjb25zb2xlLndhcm4odGFyZ2V0LCBcImlzIG5vdCBhIERpc3BsYXlPYmplY3Qgb3IgUElYSSB3YXMgbm90IGZvdW5kLiBQaXhpUGx1Z2luLnJlZ2lzdGVyUElYSShQSVhJKTtcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQsIGF4aXMsIHZhbHVlLCBjb2xvck1hdHJpeCwgZmlsdGVyLCBwLCBwYWRkaW5nLCBpLCBkYXRhO1xuXG4gICAgZm9yIChwIGluIHZhbHVlcykge1xuICAgICAgY29udGV4dCA9IF9jb250ZXh0c1twXTtcbiAgICAgIHZhbHVlID0gdmFsdWVzW3BdO1xuXG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBheGlzID0gfnAuY2hhckF0KHAubGVuZ3RoIC0gMSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwieFwiKSA/IFwieFwiIDogXCJ5XCI7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldFtjb250ZXh0XSwgYXhpcywgdGFyZ2V0W2NvbnRleHRdW2F4aXNdLCBjb250ZXh0ID09PSBcInNrZXdcIiA/IF9kZWdyZWVzVG9SYWRpYW5zKHZhbHVlKSA6IHZhbHVlLCAwLCAwLCAwLCAwLCAwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzY2FsZVwiIHx8IHAgPT09IFwiYW5jaG9yXCIgfHwgcCA9PT0gXCJwaXZvdFwiIHx8IHAgPT09IFwidGlsZVNjYWxlXCIpIHtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0W3BdLCBcInhcIiwgdGFyZ2V0W3BdLngsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0W3BdLCBcInlcIiwgdGFyZ2V0W3BdLnksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJyb3RhdGlvblwiIHx8IHAgPT09IFwiYW5nbGVcIikge1xuICAgICAgICAvL1BJWEkgZXhwZWN0cyByb3RhdGlvbiBpbiByYWRpYW5zLCBidXQgYXMgYSBjb252ZW5pZW5jZSB3ZSBsZXQgZm9sa3MgZGVmaW5lIGl0IGluIGRlZ3JlZXMgYW5kIHdlIGRvIHRoZSBjb252ZXJzaW9uLlxuICAgICAgICBfYWRkUm90YXRpb25hbFByb3BUd2Vlbih0aGlzLCB0YXJnZXQsIHAsIHRhcmdldFtwXSwgdmFsdWUsIHAgPT09IFwicm90YXRpb25cIik7XG4gICAgICB9IGVsc2UgaWYgKF9jb2xvck1hdHJpeEZpbHRlclByb3BzW3BdKSB7XG4gICAgICAgIGlmICghY29sb3JNYXRyaXgpIHtcbiAgICAgICAgICBfcGFyc2VDb2xvck1hdHJpeEZpbHRlcih0YXJnZXQsIHZhbHVlcy5jb2xvck1hdHJpeEZpbHRlciB8fCB2YWx1ZXMsIHRoaXMpO1xuXG4gICAgICAgICAgY29sb3JNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiYmx1clwiIHx8IHAgPT09IFwiYmx1clhcIiB8fCBwID09PSBcImJsdXJZXCIgfHwgcCA9PT0gXCJibHVyUGFkZGluZ1wiKSB7XG4gICAgICAgIGZpbHRlciA9IF9nZXRGaWx0ZXIodGFyZ2V0LCBcIkJsdXJGaWx0ZXJcIik7XG4gICAgICAgIHRoaXMuYWRkKGZpbHRlciwgcCwgZmlsdGVyW3BdLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5ibHVyUGFkZGluZyAhPT0gMCkge1xuICAgICAgICAgIHBhZGRpbmcgPSB2YWx1ZXMuYmx1clBhZGRpbmcgfHwgTWF0aC5tYXgoZmlsdGVyW3BdLCB2YWx1ZSkgKiAyO1xuICAgICAgICAgIGkgPSB0YXJnZXQuZmlsdGVycy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldC5maWx0ZXJzW2ldLnBhZGRpbmcgPSBNYXRoLm1heCh0YXJnZXQuZmlsdGVyc1tpXS5wYWRkaW5nLCBwYWRkaW5nKTsgLy9pZiB3ZSBkb24ndCBleHBhbmQgdGhlIHBhZGRpbmcgb24gYWxsIHRoZSBmaWx0ZXJzLCBpdCBjYW4gbG9vayBjbGlwcGVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfY29sb3JQcm9wc1twXSkge1xuICAgICAgICBpZiAoKHAgPT09IFwibGluZUNvbG9yXCIgfHwgcCA9PT0gXCJmaWxsQ29sb3JcIikgJiYgdGFyZ2V0IGluc3RhbmNlb2YgX1BJWEkuR3JhcGhpY3MpIHtcbiAgICAgICAgICBkYXRhID0gKHRhcmdldC5nZW9tZXRyeSB8fCB0YXJnZXQpLmdyYXBoaWNzRGF0YTsgLy9cImdlb21ldHJ5XCIgd2FzIGludHJvZHVjZWQgaW4gUElYSSB2ZXJzaW9uIDVcblxuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwLCAwLCAwLCBfcmVuZGVyRGlydHlDYWNoZSwge1xuICAgICAgICAgICAgZzogdGFyZ2V0Lmdlb21ldHJ5IHx8IHRhcmdldFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGkgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgX2FkZENvbG9yVHdlZW4oX2lzVjQgPyBkYXRhW2ldIDogZGF0YVtpXVtwLnN1YnN0cigwLCA0KSArIFwiU3R5bGVcIl0sIF9pc1Y0ID8gcCA6IFwiY29sb3JcIiwgdmFsdWUsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfYWRkQ29sb3JUd2Vlbih0YXJnZXQsIHAsIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBcInZpc2libGVcIiwgMCwgMCwgX3JlbmRlckF1dG9BbHBoYSk7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldCwgXCJhbHBoYVwiLCB0YXJnZXQuYWxwaGEsIHZhbHVlKTtcblxuICAgICAgICB0aGlzLl9wcm9wcy5wdXNoKFwiYWxwaGFcIiwgXCJ2aXNpYmxlXCIpO1xuICAgICAgfSBlbHNlIGlmIChwICE9PSBcInJlc29sdXRpb25cIikge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIFwiZ2V0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cbn07XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oUGl4aVBsdWdpbik7XG5leHBvcnQgeyBQaXhpUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/PixiPlugin.js\n"));

/***/ }),

/***/ "./node_modules/gsap/ScrollToPlugin.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/ScrollToPlugin.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollToPlugin\": function() { return /* binding */ ScrollToPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollToPlugin; }\n/* harmony export */ });\n/*!\n * ScrollToPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _window,\n    _docEl,\n    _body,\n    _toArray,\n    _config,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _max = function _max(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim;\n  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n},\n    _buildGetter = function _buildGetter(e, axis) {\n  //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\" + axis.toUpperCase() + \"Offset\";\n    } else {\n      e = _docEl[p] != null ? _docEl : _body;\n    }\n  }\n\n  return function () {\n    return e[p];\n  };\n},\n    _clean = function _clean(value, index, target, targets) {\n  _isFunction(value) && (value = value(index, target, targets));\n\n  if (typeof value !== \"object\") {\n    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n      x: value,\n      y: value\n    } : {\n      y: value\n    }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n  } else if (value.nodeType) {\n    return {\n      y: value,\n      x: value\n    };\n  } else {\n    var result = {},\n        p;\n\n    for (p in value) {\n      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n    }\n\n    return result;\n  }\n},\n    _getOffset = function _getOffset(element, container) {\n  element = _toArray(element)[0];\n\n  if (!element || !element.getBoundingClientRect) {\n    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n  } : container.getBoundingClientRect(),\n      offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n\n  if (!isRoot && container) {\n    //only add the current scroll position if it's not the window/body.\n    offsets.x += _buildGetter(container, \"x\")();\n    offsets.y += _buildGetter(container, \"y\")();\n  }\n\n  return offsets;\n},\n    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (_windowExists() && gsap && document.body) {\n    _window = window;\n    _body = document.body;\n    _docEl = document.documentElement;\n    _toArray = gsap.utils.toArray;\n    gsap.config({\n      autoKillThreshold: 7\n    });\n    _config = gsap.config();\n    _coreInitted = 1;\n  }\n};\n\nvar ScrollToPlugin = {\n  version: \"3.11.2\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    var data = this,\n        snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n      scrollBehavior: \"auto\"\n    });\n\n    if (snapType && snapType !== \"none\") {\n      // disable scroll snapping to avoid strange behavior\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt,\n        target = data.target,\n        tween = data.tween,\n        autoKill = data.autoKill,\n        xPrev = data.xPrev,\n        yPrev = data.yPrev,\n        isWin = data.isWin,\n        snap = data.snap,\n        snapInline = data.snapInline,\n        x,\n        y,\n        yDif,\n        xDif,\n        threshold;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n\n    if (data.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n\n    if (data.y < 0) {\n      data.y = 0;\n    }\n\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n\n      target.scrollLeft = x + 1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n  },\n  kill: function kill(property) {\n    var both = property === \"scrollTo\";\n\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUb1BsdWdpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvU2Nyb2xsVG9QbHVnaW4uanM/MzAzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFNjcm9sbFRvUGx1Z2luIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfd2luZG93LFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfdG9BcnJheSxcbiAgICBfY29uZmlnLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfbWF4ID0gZnVuY3Rpb24gX21heChlbGVtZW50LCBheGlzKSB7XG4gIHZhciBkaW0gPSBheGlzID09PSBcInhcIiA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIsXG4gICAgICBzY3JvbGwgPSBcInNjcm9sbFwiICsgZGltLFxuICAgICAgY2xpZW50ID0gXCJjbGllbnRcIiArIGRpbTtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IF93aW5kb3cgfHwgZWxlbWVudCA9PT0gX2RvY0VsIHx8IGVsZW1lbnQgPT09IF9ib2R5ID8gTWF0aC5tYXgoX2RvY0VsW3Njcm9sbF0sIF9ib2R5W3Njcm9sbF0pIC0gKF93aW5kb3dbXCJpbm5lclwiICsgZGltXSB8fCBfZG9jRWxbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbXCJvZmZzZXRcIiArIGRpbV07XG59LFxuICAgIF9idWlsZEdldHRlciA9IGZ1bmN0aW9uIF9idWlsZEdldHRlcihlLCBheGlzKSB7XG4gIC8vcGFzcyBpbiBhbiBlbGVtZW50IGFuZCBhbiBheGlzIChcInhcIiBvciBcInlcIikgYW5kIGl0J2xsIHJldHVybiBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGF0IGVsZW1lbnQgKGxpa2Ugc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQsIGFsdGhvdWdoIGlmIHRoZSBlbGVtZW50IGlzIHRoZSB3aW5kb3csIGl0J2xsIHVzZSB0aGUgcGFnZVhPZmZzZXQvcGFnZVlPZmZzZXQgb3IgdGhlIGRvY3VtZW50RWxlbWVudCdzIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IG9yIGRvY3VtZW50LmJvZHkncy4gQmFzaWNhbGx5IHRoaXMgc3RyZWFtbGluZXMgdGhpbmdzIGFuZCBtYWtlcyBhIHZlcnkgZmFzdCBnZXR0ZXIgYWNyb3NzIGJyb3dzZXJzLlxuICB2YXIgcCA9IFwic2Nyb2xsXCIgKyAoYXhpcyA9PT0gXCJ4XCIgPyBcIkxlZnRcIiA6IFwiVG9wXCIpO1xuXG4gIGlmIChlID09PSBfd2luZG93KSB7XG4gICAgaWYgKGUucGFnZVhPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgcCA9IFwicGFnZVwiICsgYXhpcy50b1VwcGVyQ2FzZSgpICsgXCJPZmZzZXRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IF9kb2NFbFtwXSAhPSBudWxsID8gX2RvY0VsIDogX2JvZHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZVtwXTtcbiAgfTtcbn0sXG4gICAgX2NsZWFuID0gZnVuY3Rpb24gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZShpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSBcIm1heFwiICYmIHZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIgPyB7XG4gICAgICB4OiB2YWx1ZSxcbiAgICAgIHk6IHZhbHVlXG4gICAgfSA6IHtcbiAgICAgIHk6IHZhbHVlXG4gICAgfTsgLy9pZiB3ZSBkb24ndCByZWNlaXZlIGFuIG9iamVjdCBhcyB0aGUgcGFyYW1ldGVyLCBhc3N1bWUgdGhlIHVzZXIgaW50ZW5kcyBcInlcIi5cbiAgfSBlbHNlIGlmICh2YWx1ZS5ub2RlVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5OiB2YWx1ZSxcbiAgICAgIHg6IHZhbHVlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIHJlc3VsdFtwXSA9IHAgIT09IFwib25BdXRvS2lsbFwiICYmIF9pc0Z1bmN0aW9uKHZhbHVlW3BdKSA/IHZhbHVlW3BdKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFsdWVbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSxcbiAgICBfZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gX2dldE9mZnNldChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgZWxlbWVudCA9IF90b0FycmF5KGVsZW1lbnQpWzBdO1xuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwic2Nyb2xsVG8gdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuIFVzaW5nIDBcIikgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaXNSb290ID0gIWNvbnRhaW5lciB8fCBjb250YWluZXIgPT09IF93aW5kb3cgfHwgY29udGFpbmVyID09PSBfYm9keSxcbiAgICAgIGNSZWN0ID0gaXNSb290ID8ge1xuICAgIHRvcDogX2RvY0VsLmNsaWVudFRvcCAtIChfd2luZG93LnBhZ2VZT2Zmc2V0IHx8IF9kb2NFbC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDApLFxuICAgIGxlZnQ6IF9kb2NFbC5jbGllbnRMZWZ0IC0gKF93aW5kb3cucGFnZVhPZmZzZXQgfHwgX2RvY0VsLnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwKVxuICB9IDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICB4OiByZWN0LmxlZnQgLSBjUmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wIC0gY1JlY3QudG9wXG4gIH07XG5cbiAgaWYgKCFpc1Jvb3QgJiYgY29udGFpbmVyKSB7XG4gICAgLy9vbmx5IGFkZCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaWYgaXQncyBub3QgdGhlIHdpbmRvdy9ib2R5LlxuICAgIG9mZnNldHMueCArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInhcIikoKTtcbiAgICBvZmZzZXRzLnkgKz0gX2J1aWxkR2V0dGVyKGNvbnRhaW5lciwgXCJ5XCIpKCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0sXG4gICAgX3BhcnNlVmFsID0gZnVuY3Rpb24gX3BhcnNlVmFsKHZhbHVlLCB0YXJnZXQsIGF4aXMsIGN1cnJlbnRWYWwsIG9mZnNldCkge1xuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgPyBwYXJzZUZsb2F0KHZhbHVlKSAtIG9mZnNldCA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqICh2YWx1ZS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIGN1cnJlbnRWYWwgLSBvZmZzZXQgOiB2YWx1ZSA9PT0gXCJtYXhcIiA/IF9tYXgodGFyZ2V0LCBheGlzKSAtIG9mZnNldCA6IE1hdGgubWluKF9tYXgodGFyZ2V0LCBheGlzKSwgX2dldE9mZnNldCh2YWx1ZSwgdGFyZ2V0KVtheGlzXSAtIG9mZnNldCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBnc2FwICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICBfd2luZG93ID0gd2luZG93O1xuICAgIF9ib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICBfZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgZ3NhcC5jb25maWcoe1xuICAgICAgYXV0b0tpbGxUaHJlc2hvbGQ6IDdcbiAgICB9KTtcbiAgICBfY29uZmlnID0gZ3NhcC5jb25maWcoKTtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIFNjcm9sbFRvUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTEuMlwiLFxuICBuYW1lOiBcInNjcm9sbFRvXCIsXG4gIHJhd1ZhcnM6IDEsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLFxuICAgICAgICBzbmFwVHlwZSA9IGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbFNuYXBUeXBlXCIpO1xuICAgIGRhdGEuaXNXaW4gPSB0YXJnZXQgPT09IF93aW5kb3c7XG4gICAgZGF0YS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZGF0YS50d2VlbiA9IHR3ZWVuO1xuICAgIHZhbHVlID0gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICBkYXRhLnZhcnMgPSB2YWx1ZTtcbiAgICBkYXRhLmF1dG9LaWxsID0gISF2YWx1ZS5hdXRvS2lsbDtcbiAgICBkYXRhLmdldFggPSBfYnVpbGRHZXR0ZXIodGFyZ2V0LCBcInhcIik7XG4gICAgZGF0YS5nZXRZID0gX2J1aWxkR2V0dGVyKHRhcmdldCwgXCJ5XCIpO1xuICAgIGRhdGEueCA9IGRhdGEueFByZXYgPSBkYXRhLmdldFgoKTtcbiAgICBkYXRhLnkgPSBkYXRhLnlQcmV2ID0gZGF0YS5nZXRZKCk7XG4gICAgZ3NhcC5nZXRQcm9wZXJ0eSh0YXJnZXQsIFwic2Nyb2xsQmVoYXZpb3JcIikgPT09IFwic21vb3RoXCIgJiYgZ3NhcC5zZXQodGFyZ2V0LCB7XG4gICAgICBzY3JvbGxCZWhhdmlvcjogXCJhdXRvXCJcbiAgICB9KTtcblxuICAgIGlmIChzbmFwVHlwZSAmJiBzbmFwVHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIC8vIGRpc2FibGUgc2Nyb2xsIHNuYXBwaW5nIHRvIGF2b2lkIHN0cmFuZ2UgYmVoYXZpb3JcbiAgICAgIGRhdGEuc25hcCA9IDE7XG4gICAgICBkYXRhLnNuYXBJbmxpbmUgPSB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGU7XG4gICAgICB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBcIm5vbmVcIjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUueCAhPSBudWxsKSB7XG4gICAgICBkYXRhLmFkZChkYXRhLCBcInhcIiwgZGF0YS54LCBfcGFyc2VWYWwodmFsdWUueCwgdGFyZ2V0LCBcInhcIiwgZGF0YS54LCB2YWx1ZS5vZmZzZXRYIHx8IDApLCBpbmRleCwgdGFyZ2V0cyk7XG5cbiAgICAgIGRhdGEuX3Byb3BzLnB1c2goXCJzY3JvbGxUb194XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBYID0gMTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUueSAhPSBudWxsKSB7XG4gICAgICBkYXRhLmFkZChkYXRhLCBcInlcIiwgZGF0YS55LCBfcGFyc2VWYWwodmFsdWUueSwgdGFyZ2V0LCBcInlcIiwgZGF0YS55LCB2YWx1ZS5vZmZzZXRZIHx8IDApLCBpbmRleCwgdGFyZ2V0cyk7XG5cbiAgICAgIGRhdGEuX3Byb3BzLnB1c2goXCJzY3JvbGxUb195XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBZID0gMTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICAgIHRhcmdldCA9IGRhdGEudGFyZ2V0LFxuICAgICAgICB0d2VlbiA9IGRhdGEudHdlZW4sXG4gICAgICAgIGF1dG9LaWxsID0gZGF0YS5hdXRvS2lsbCxcbiAgICAgICAgeFByZXYgPSBkYXRhLnhQcmV2LFxuICAgICAgICB5UHJldiA9IGRhdGEueVByZXYsXG4gICAgICAgIGlzV2luID0gZGF0YS5pc1dpbixcbiAgICAgICAgc25hcCA9IGRhdGEuc25hcCxcbiAgICAgICAgc25hcElubGluZSA9IGRhdGEuc25hcElubGluZSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeURpZixcbiAgICAgICAgeERpZixcbiAgICAgICAgdGhyZXNob2xkO1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgeCA9IGlzV2luIHx8ICFkYXRhLnNraXBYID8gZGF0YS5nZXRYKCkgOiB4UHJldjtcbiAgICB5ID0gaXNXaW4gfHwgIWRhdGEuc2tpcFkgPyBkYXRhLmdldFkoKSA6IHlQcmV2O1xuICAgIHlEaWYgPSB5IC0geVByZXY7XG4gICAgeERpZiA9IHggLSB4UHJldjtcbiAgICB0aHJlc2hvbGQgPSBfY29uZmlnLmF1dG9LaWxsVGhyZXNob2xkO1xuXG4gICAgaWYgKGRhdGEueCA8IDApIHtcbiAgICAgIC8vY2FuJ3Qgc2Nyb2xsIHRvIGEgcG9zaXRpb24gbGVzcyB0aGFuIDAhIE1pZ2h0IGhhcHBlbiBpZiBzb21lb25lIHVzZXMgYSBCYWNrLmVhc2VPdXQgb3IgRWxhc3RpYy5lYXNlT3V0IHdoZW4gc2Nyb2xsaW5nIGJhY2sgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSAoZm9yIGV4YW1wbGUpXG4gICAgICBkYXRhLnggPSAwO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnkgPCAwKSB7XG4gICAgICBkYXRhLnkgPSAwO1xuICAgIH1cblxuICAgIGlmIChhdXRvS2lsbCkge1xuICAgICAgLy9ub3RlOiBpT1MgaGFzIGEgYnVnIHRoYXQgdGhyb3dzIG9mZiB0aGUgc2Nyb2xsIGJ5IHNldmVyYWwgcGl4ZWxzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3Mgd2l0aGluIDcgcGl4ZWxzIG9mIHRoZSBwcmV2aW91cyBvbmUgdGhhdCB3ZSBzZXQgaW5zdGVhZCBvZiBqdXN0IGxvb2tpbmcgZm9yIGFuIGV4YWN0IG1hdGNoLlxuICAgICAgaWYgKCFkYXRhLnNraXBYICYmICh4RGlmID4gdGhyZXNob2xkIHx8IHhEaWYgPCAtdGhyZXNob2xkKSAmJiB4IDwgX21heCh0YXJnZXQsIFwieFwiKSkge1xuICAgICAgICBkYXRhLnNraXBYID0gMTsgLy9pZiB0aGUgdXNlciBzY3JvbGxzIHNlcGFyYXRlbHksIHdlIHNob3VsZCBzdG9wIHR3ZWVuaW5nIVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuc2tpcFkgJiYgKHlEaWYgPiB0aHJlc2hvbGQgfHwgeURpZiA8IC10aHJlc2hvbGQpICYmIHkgPCBfbWF4KHRhcmdldCwgXCJ5XCIpKSB7XG4gICAgICAgIGRhdGEuc2tpcFkgPSAxOyAvL2lmIHRoZSB1c2VyIHNjcm9sbHMgc2VwYXJhdGVseSwgd2Ugc2hvdWxkIHN0b3AgdHdlZW5pbmchXG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLnNraXBYICYmIGRhdGEuc2tpcFkpIHtcbiAgICAgICAgdHdlZW4ua2lsbCgpO1xuICAgICAgICBkYXRhLnZhcnMub25BdXRvS2lsbCAmJiBkYXRhLnZhcnMub25BdXRvS2lsbC5hcHBseSh0d2VlbiwgZGF0YS52YXJzLm9uQXV0b0tpbGxQYXJhbXMgfHwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1dpbikge1xuICAgICAgX3dpbmRvdy5zY3JvbGxUbyghZGF0YS5za2lwWCA/IGRhdGEueCA6IHgsICFkYXRhLnNraXBZID8gZGF0YS55IDogeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuc2tpcFkgfHwgKHRhcmdldC5zY3JvbGxUb3AgPSBkYXRhLnkpO1xuICAgICAgZGF0YS5za2lwWCB8fCAodGFyZ2V0LnNjcm9sbExlZnQgPSBkYXRhLngpO1xuICAgIH1cblxuICAgIGlmIChzbmFwICYmIChyYXRpbyA9PT0gMSB8fCByYXRpbyA9PT0gMCkpIHtcbiAgICAgIHkgPSB0YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgeCA9IHRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgc25hcElubGluZSA/IHRhcmdldC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IHNuYXBJbmxpbmUgOiB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY3JvbGwtc25hcC10eXBlXCIpO1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHkgKyAxOyAvLyBidWcgaW4gU2FmYXJpIGNhdXNlcyB0aGUgZWxlbWVudCB0byB0b3RhbGx5IHJlc2V0IGl0cyBzY3JvbGwgcG9zaXRpb24gd2hlbiBzY3JvbGwtc25hcC10eXBlIGNoYW5nZXMsIHNvIHdlIG5lZWQgdG8gc2V0IGl0IHRvIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHZhbHVlIGFuZCB0aGVuIGJhY2sgYWdhaW4gdG8gd29yayBhcm91bmQgdGhpcyBidWcuXG5cbiAgICAgIHRhcmdldC5zY3JvbGxMZWZ0ID0geCArIDE7XG4gICAgICB0YXJnZXQuc2Nyb2xsVG9wID0geTtcbiAgICAgIHRhcmdldC5zY3JvbGxMZWZ0ID0geDtcbiAgICB9XG5cbiAgICBkYXRhLnhQcmV2ID0gZGF0YS54O1xuICAgIGRhdGEueVByZXYgPSBkYXRhLnk7XG4gIH0sXG4gIGtpbGw6IGZ1bmN0aW9uIGtpbGwocHJvcGVydHkpIHtcbiAgICB2YXIgYm90aCA9IHByb3BlcnR5ID09PSBcInNjcm9sbFRvXCI7XG5cbiAgICBpZiAoYm90aCB8fCBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb194XCIpIHtcbiAgICAgIHRoaXMuc2tpcFggPSAxO1xuICAgIH1cblxuICAgIGlmIChib3RoIHx8IHByb3BlcnR5ID09PSBcInNjcm9sbFRvX3lcIikge1xuICAgICAgdGhpcy5za2lwWSA9IDE7XG4gICAgfVxuICB9XG59O1xuU2Nyb2xsVG9QbHVnaW4ubWF4ID0gX21heDtcblNjcm9sbFRvUGx1Z2luLmdldE9mZnNldCA9IF9nZXRPZmZzZXQ7XG5TY3JvbGxUb1BsdWdpbi5idWlsZEdldHRlciA9IF9idWlsZEdldHRlcjtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUb1BsdWdpbik7XG5leHBvcnQgeyBTY3JvbGxUb1BsdWdpbiBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/ScrollToPlugin.js\n"));

/***/ }),

/***/ "./node_modules/gsap/ScrollTrigger.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/ScrollTrigger.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollTrigger\": function() { return /* binding */ ScrollTrigger; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollTrigger; }\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"./node_modules/gsap/Observer.js\");\n/*!\n * ScrollTrigger 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _resizeDelay,\n    _toArray,\n    _clamp,\n    _time2,\n    _syncInterval,\n    _refreshing,\n    _pointerIsDown,\n    _transformProp,\n    _i,\n    _prevWidth,\n    _prevHeight,\n    _autoRefresh,\n    _sort,\n    _suppressOverwrites,\n    _ignoreResize,\n    _normalizer,\n    _ignoreMobileResize,\n    _baseScreenHeight,\n    _baseScreenWidth,\n    _fixIOSBug,\n    _context,\n    _scrollRestoration,\n    _limitCallbacks,\n    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1,\n    _getTime = Date.now,\n    _time1 = _getTime(),\n    _lastScrollTime = 0,\n    _enabled = 0,\n    _pointerDownHandler = function _pointerDownHandler() {\n  return _pointerIsDown = 1;\n},\n    _pointerUpHandler = function _pointerUpHandler() {\n  return _pointerIsDown = 0;\n},\n    _passThrough = function _passThrough(v) {\n  return v;\n},\n    _round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getBoundsFunc = function _getBoundsFunc(element) {\n  return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function () {\n    _winOffsets.width = _win.innerWidth;\n    _winOffsets.height = _win.innerHeight;\n    return _winOffsets;\n  } : function () {\n    return _getBounds(element);\n  });\n},\n    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n  var d = _ref.d,\n      d2 = _ref.d2,\n      a = _ref.a;\n  return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function () {\n    return a()[d];\n  } : function () {\n    return (isViewport ? _win[\"inner\" + d2] : scroller[\"client\" + d2]) || 0;\n  };\n},\n    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n  return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function () {\n    return _winOffsets;\n  };\n},\n    _maxScroll = function _maxScroll(element, _ref2) {\n  var s = _ref2.s,\n      d2 = _ref2.d2,\n      d = _ref2.d,\n      a = _ref2.a;\n  return (s = \"scroll\" + d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win[\"inner\" + d2] || _docEl[\"client\" + d2] || _body[\"client\" + d2]) : element[s] - element[\"offset\" + d2];\n},\n    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n  for (var i = 0; i < _autoRefresh.length; i += 3) {\n    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n  }\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _callIfFunc = function _callIfFunc(value) {\n  return _isFunction(value) && value();\n},\n    _combineFunc = function _combineFunc(f1, f2) {\n  return function () {\n    var result1 = _callIfFunc(f1),\n        result2 = _callIfFunc(f2);\n\n    return function () {\n      _callIfFunc(result1);\n\n      _callIfFunc(result2);\n    };\n  };\n},\n    _endAnimation = function _endAnimation(animation, reversed, pause) {\n  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n},\n    _callback = function _callback(self, func) {\n  if (self.enabled) {\n    var result = func(self);\n    result && result.totalTime && (self.callbackAnimation = result);\n  }\n},\n    _abs = Math.abs,\n    _scrollLeft = \"scrollLeft\",\n    _scrollTop = \"scrollTop\",\n    _left = \"left\",\n    _top = \"top\",\n    _right = \"right\",\n    _bottom = \"bottom\",\n    _width = \"width\",\n    _height = \"height\",\n    _Right = \"Right\",\n    _Left = \"Left\",\n    _Top = \"Top\",\n    _Bottom = \"Bottom\",\n    _padding = \"padding\",\n    _margin = \"margin\",\n    _Width = \"Width\",\n    _Height = \"Height\",\n    _px = \"px\",\n    _getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element);\n},\n    _makePositionable = function _makePositionable(element) {\n  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n  var position = _getComputedStyle(element).position;\n\n  element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _getBounds = function _getBounds(element, withoutTransforms) {\n  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n    x: 0,\n    y: 0,\n    xPercent: 0,\n    yPercent: 0,\n    rotation: 0,\n    rotationX: 0,\n    rotationY: 0,\n    scale: 1,\n    skewX: 0,\n    skewY: 0\n  }).progress(1),\n      bounds = element.getBoundingClientRect();\n  tween && tween.progress(0).kill();\n  return bounds;\n},\n    _getSize = function _getSize(element, _ref3) {\n  var d2 = _ref3.d2;\n  return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n},\n    _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n  var a = [],\n      labels = timeline.labels,\n      duration = timeline.duration(),\n      p;\n\n  for (p in labels) {\n    a.push(labels[p] / duration);\n  }\n\n  return a;\n},\n    _getClosestLabel = function _getClosestLabel(animation) {\n  return function (value) {\n    return gsap.utils.snap(_getLabelRatioArray(animation), value);\n  };\n},\n    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n  var snap = gsap.utils.snap(snapIncrementOrArray),\n      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {\n    return a - b;\n  });\n  return a ? function (value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n\n    var i;\n\n    if (!direction) {\n      return snap(value);\n    }\n\n    if (direction > 0) {\n      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n\n      for (i = 0; i < a.length; i++) {\n        if (a[i] >= value) {\n          return a[i];\n        }\n      }\n\n      return a[i - 1];\n    } else {\n      i = a.length;\n      value += threshold;\n\n      while (i--) {\n        if (a[i] <= value) {\n          return a[i];\n        }\n      }\n    }\n\n    return a[0];\n  } : function (value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n\n    var snapped = snap(value);\n    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n  };\n},\n    _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n  return function (value, st) {\n    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n  };\n},\n    _multiListener = function _multiListener(func, element, types, callback) {\n  return types.split(\",\").forEach(function (type) {\n    return func(element, type, callback);\n  });\n},\n    _addListener = function _addListener(element, type, func, nonPassive, capture) {\n  return element.addEventListener(type, func, {\n    passive: !nonPassive,\n    capture: !!capture\n  });\n},\n    _removeListener = function _removeListener(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n},\n    _wheelListener = function _wheelListener(func, el, scrollFunc) {\n  return scrollFunc && scrollFunc.wheelHandler && func(el, \"wheel\", scrollFunc);\n},\n    _markerDefaults = {\n  startColor: \"green\",\n  endColor: \"red\",\n  indent: 0,\n  fontSize: \"16px\",\n  fontWeight: \"normal\"\n},\n    _defaults = {\n  toggleActions: \"play\",\n  anticipatePin: 0\n},\n    _keywords = {\n  top: 0,\n  left: 0,\n  center: 0.5,\n  bottom: 1,\n  right: 1\n},\n    _offsetToPx = function _offsetToPx(value, size) {\n  if (_isString(value)) {\n    var eqIndex = value.indexOf(\"=\"),\n        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\n    if (~eqIndex) {\n      value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n      value = value.substr(0, eqIndex - 1);\n    }\n\n    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n  }\n\n  return value;\n},\n    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n  var startColor = _ref4.startColor,\n      endColor = _ref4.endColor,\n      fontSize = _ref4.fontSize,\n      indent = _ref4.indent,\n      fontWeight = _ref4.fontWeight;\n\n  var e = _doc.createElement(\"div\"),\n      useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\",\n      isScroller = type.indexOf(\"scroller\") !== -1,\n      parent = useFixedPosition ? _body : container,\n      isStart = type.indexOf(\"start\") !== -1,\n      color = isStart ? startColor : endColor,\n      css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\n  css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n  matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n  e._isStart = isStart;\n  e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n  e.style.cssText = css;\n  e.innerText = name || name === 0 ? type + \"-\" + name : type;\n  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n  e._offset = e[\"offset\" + direction.op.d2];\n\n  _positionMarker(e, 0, direction, isStart);\n\n  return e;\n},\n    _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n  var vars = {\n    display: \"block\"\n  },\n      side = direction[flipped ? \"os2\" : \"p2\"],\n      oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n  marker._isFlipped = flipped;\n  vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n  vars[direction.a] = flipped ? \"1px\" : 0;\n  vars[\"border\" + side + _Width] = 1;\n  vars[\"border\" + oppositeSide + _Width] = 0;\n  vars[direction.p] = start + \"px\";\n  gsap.set(marker, vars);\n},\n    _triggers = [],\n    _ids = {},\n    _rafID,\n    _sync = function _sync() {\n  return _getTime() - _lastScrollTime > 34 && _updateAll();\n},\n    _onScroll = function _onScroll() {\n  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n    // if the user is dragging the scrollbar, allow it.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    _rafID || (_rafID = requestAnimationFrame(_updateAll));\n    _lastScrollTime || _dispatch(\"scrollStart\");\n    _lastScrollTime = _getTime();\n  }\n},\n    _setBaseDimensions = function _setBaseDimensions() {\n  _baseScreenWidth = _win.innerWidth;\n  _baseScreenHeight = _win.innerHeight;\n},\n    _onResize = function _onResize() {\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n  !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);\n},\n    // ignore resizes triggered by refresh()\n_listeners = {},\n    _emptyArray = [],\n    _softRefresh = function _softRefresh() {\n  return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n},\n    _dispatch = function _dispatch(type) {\n  return _listeners[type] && _listeners[type].map(function (f) {\n    return f();\n  }) || _emptyArray;\n},\n    _savedStyles = [],\n    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n  for (var i = 0; i < _savedStyles.length; i += 5) {\n    if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n      _savedStyles[i].style.cssText = _savedStyles[i + 1];\n      _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n      _savedStyles[i + 3].uncache = 1;\n    }\n  }\n},\n    _revertAll = function _revertAll(kill, media) {\n  var trigger;\n\n  for (_i = 0; _i < _triggers.length; _i++) {\n    trigger = _triggers[_i];\n\n    if (trigger && (!media || trigger._ctx === media)) {\n      if (kill) {\n        trigger.kill(1);\n      } else {\n        trigger.revert(true, true);\n      }\n    }\n  }\n\n  media && _revertRecorded(media);\n  media || _dispatch(\"revert\");\n},\n    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\n  // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n  (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\n    return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n  });\n  _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n},\n    _refreshingAll,\n    _refreshID = 0,\n    _refreshAll = function _refreshAll(force, skipRevert) {\n  if (_lastScrollTime && !force) {\n    _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n    return;\n  }\n\n  _refreshingAll = ScrollTrigger.isRefreshing = true;\n\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\n    return _isFunction(obj) && obj.cacheID++ && (obj.rec = obj());\n  }); // force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\n\n\n  var refreshInits = _dispatch(\"refreshInit\");\n\n  _sort && ScrollTrigger.sort();\n  skipRevert || _revertAll();\n\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\n    if (_isFunction(obj)) {\n      obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\n\n      obj(0);\n    }\n  });\n\n  _triggers.slice(0).forEach(function (t) {\n    return t.refresh();\n  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n\n\n  _triggers.forEach(function (t) {\n    return t.vars.end === \"max\" && t.setPositions(t.start, Math.max(t.start + 1, _maxScroll(t.scroller, t._dir)));\n  }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\".\n\n\n  refreshInits.forEach(function (result) {\n    return result && result.render && result.render(-1);\n  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\n    if (_isFunction(obj)) {\n      obj.smooth && requestAnimationFrame(function () {\n        return obj.target.style.scrollBehavior = \"smooth\";\n      });\n      obj.rec && obj(obj.rec);\n    }\n  });\n\n  _clearScrollMemory(_scrollRestoration, 1);\n\n  _resizeDelay.pause();\n\n  _refreshID++;\n\n  _updateAll(2);\n\n  _refreshingAll = ScrollTrigger.isRefreshing = false;\n\n  _dispatch(\"refresh\");\n},\n    _lastScroll = 0,\n    _direction = 1,\n    _primary,\n    _updateAll = function _updateAll(force) {\n  if (!_refreshingAll || force === 2) {\n    ScrollTrigger.isUpdating = true;\n    _primary && _primary.update(0); // ScrollSmoother users refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n\n    var l = _triggers.length,\n        time = _getTime(),\n        recordVelocity = time - _time1 >= 50,\n        scroll = l && _triggers[0].scroll();\n\n    _direction = _lastScroll > scroll ? -1 : 1;\n    _lastScroll = scroll;\n\n    if (recordVelocity) {\n      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n        _lastScrollTime = 0;\n\n        _dispatch(\"scrollEnd\");\n      }\n\n      _time2 = _time1;\n      _time1 = time;\n    }\n\n    if (_direction < 0) {\n      _i = l;\n\n      while (_i-- > 0) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n\n      _direction = 1;\n    } else {\n      for (_i = 0; _i < l; _i++) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n    }\n\n    ScrollTrigger.isUpdating = false;\n  }\n\n  _rafID = 0;\n},\n    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\", \"float\", \"zIndex\", \"gridColumnStart\", \"gridColumnEnd\", \"gridRowStart\", \"gridRowEnd\", \"gridArea\", \"justifySelf\", \"alignSelf\", \"placeSelf\", \"order\"],\n    _stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n    _swapPinOut = function _swapPinOut(pin, spacer, state) {\n  _setState(state);\n\n  var cache = pin._gsap;\n\n  if (cache.spacerIsNative) {\n    _setState(cache.spacerState);\n  } else if (pin._gsap.swappedIn) {\n    var parent = spacer.parentNode;\n\n    if (parent) {\n      parent.insertBefore(pin, spacer);\n      parent.removeChild(spacer);\n    }\n  }\n\n  pin._gsap.swappedIn = false;\n},\n    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n  if (!pin._gsap.swappedIn) {\n    var i = _propNamesToCopy.length,\n        spacerStyle = spacer.style,\n        pinStyle = pin.style,\n        p;\n\n    while (i--) {\n      p = _propNamesToCopy[i];\n      spacerStyle[p] = cs[p];\n    }\n\n    spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n    cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n    pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n    spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n    spacerStyle.overflow = \"visible\";\n    spacerStyle.boxSizing = \"border-box\";\n    spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;\n    spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\n    _setState(spacerState);\n\n    pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n    pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n    pinStyle[_padding] = cs[_padding];\n\n    if (pin.parentNode !== spacer) {\n      pin.parentNode.insertBefore(spacer, pin);\n      spacer.appendChild(pin);\n    }\n\n    pin._gsap.swappedIn = true;\n  }\n},\n    _capsExp = /([A-Z])/g,\n    _setState = function _setState(state) {\n  if (state) {\n    var style = state.t.style,\n        l = state.length,\n        i = 0,\n        p,\n        value;\n    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n\n    for (; i < l; i += 2) {\n      value = state[i + 1];\n      p = state[i];\n\n      if (value) {\n        style[p] = value;\n      } else if (style[p]) {\n        style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n      }\n    }\n  }\n},\n    _getState = function _getState(element) {\n  // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n  var l = _stateProps.length,\n      style = element.style,\n      state = [],\n      i = 0;\n\n  for (; i < l; i++) {\n    state.push(_stateProps[i], style[_stateProps[i]]);\n  }\n\n  state.t = element;\n  return state;\n},\n    _copyState = function _copyState(state, override, omitOffsets) {\n  var result = [],\n      l = state.length,\n      i = omitOffsets ? 8 : 0,\n      // skip top, left, right, bottom if omitOffsets is true\n  p;\n\n  for (; i < l; i += 2) {\n    p = state[i];\n    result.push(p, p in override ? override[p] : state[i + 1]);\n  }\n\n  result.t = state.t;\n  return result;\n},\n    _winOffsets = {\n  left: 0,\n  top: 0\n},\n    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {\n  _isFunction(value) && (value = value(self));\n\n  if (_isString(value) && value.substr(0, 3) === \"max\") {\n    value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n  }\n\n  var time = containerAnimation ? containerAnimation.time() : 0,\n      p1,\n      p2,\n      element;\n  containerAnimation && containerAnimation.seek(0);\n\n  if (!_isNumber(value)) {\n    _isFunction(trigger) && (trigger = trigger(self));\n    var offsets = (value || \"0\").split(\" \"),\n        bounds,\n        localOffset,\n        globalOffset,\n        display;\n    element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger) || _body;\n    bounds = _getBounds(element) || {};\n\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n      // if display is \"none\", it won't report getBoundingClientRect() properly\n      display = element.style.display;\n      element.style.display = \"block\";\n      bounds = _getBounds(element);\n      display ? element.style.display = display : element.style.removeProperty(\"display\");\n    }\n\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n    globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n  } else if (markerScroller) {\n    _positionMarker(markerScroller, scrollerSize, direction, true);\n  }\n\n  if (marker) {\n    var position = value + scrollerSize,\n        isStart = marker._isStart;\n    p1 = \"scroll\" + direction.d2;\n\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n\n    if (useFixedPosition) {\n      scrollerBounds = _getBounds(markerScroller);\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n    }\n  }\n\n  if (containerAnimation && element) {\n    p1 = _getBounds(element);\n    containerAnimation.seek(scrollerMax);\n    p2 = _getBounds(element);\n    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n    value = value / containerAnimation._caScrollDist * scrollerMax;\n  }\n\n  containerAnimation && containerAnimation.seek(time);\n  return containerAnimation ? value : Math.round(value);\n},\n    _prefixExp = /(webkit|moz|length|cssText|inset)/i,\n    _reparent = function _reparent(element, parent, top, left) {\n  if (element.parentNode !== parent) {\n    var style = element.style,\n        p,\n        cs;\n\n    if (parent === _body) {\n      element._stOrig = style.cssText; // record original inline styles so we can revert them later\n\n      cs = _getComputedStyle(element);\n\n      for (p in cs) {\n        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n          style[p] = cs[p];\n        }\n      }\n\n      style.top = top;\n      style.left = left;\n    } else {\n      style.cssText = element._stOrig;\n    }\n\n    gsap.core.getCache(element).uncache = 1;\n    parent.appendChild(element);\n  }\n},\n    // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n  var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),\n      prop = \"_scroll\" + direction.p2,\n      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n  lastScroll1,\n      lastScroll2,\n      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n    var tween = getTween.tween,\n        onComplete = vars.onComplete,\n        modifiers = {};\n    initialValue = initialValue || getScroll();\n    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n\n    change1 = change1 || scrollTo - initialValue;\n    tween && tween.kill();\n    lastScroll1 = Math.round(initialValue);\n    vars[prop] = scrollTo;\n    vars.modifiers = modifiers;\n\n    modifiers[prop] = function (value) {\n      value = Math.round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.\n\n      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 3 && Math.abs(value - lastScroll2) > 3) {\n        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n        tween.kill();\n        getTween.tween = 0;\n      } else {\n        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n      }\n\n      lastScroll2 = lastScroll1;\n      return lastScroll1 = Math.round(value);\n    };\n\n    vars.onComplete = function () {\n      getTween.tween = 0;\n      onComplete && onComplete.call(tween);\n    };\n\n    tween = getTween.tween = gsap.to(scroller, vars);\n    return tween;\n  };\n\n  scroller[prop] = getScroll;\n\n  getScroll.wheelHandler = function () {\n    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n  };\n\n  _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n\n\n  return getTween;\n};\n\nvar ScrollTrigger = /*#__PURE__*/function () {\n  function ScrollTrigger(vars, animation) {\n    _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n    this.init(vars, animation);\n  }\n\n  var _proto = ScrollTrigger.prototype;\n\n  _proto.init = function init(vars, animation) {\n    this.progress = this.start = 0;\n    this.vars && this.kill(true, true); // in case it's being initted again\n\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = _passThrough;\n      return;\n    }\n\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, _defaults);\n\n    var _vars = vars,\n        onUpdate = _vars.onUpdate,\n        toggleClass = _vars.toggleClass,\n        id = _vars.id,\n        onToggle = _vars.onToggle,\n        onRefresh = _vars.onRefresh,\n        scrub = _vars.scrub,\n        trigger = _vars.trigger,\n        pin = _vars.pin,\n        pinSpacing = _vars.pinSpacing,\n        invalidateOnRefresh = _vars.invalidateOnRefresh,\n        anticipatePin = _vars.anticipatePin,\n        onScrubComplete = _vars.onScrubComplete,\n        onSnapComplete = _vars.onSnapComplete,\n        once = _vars.once,\n        snap = _vars.snap,\n        pinReparent = _vars.pinReparent,\n        pinSpacer = _vars.pinSpacer,\n        containerAnimation = _vars.containerAnimation,\n        fastScrollEnd = _vars.fastScrollEnd,\n        preventOverlaps = _vars.preventOverlaps,\n        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical,\n        isToggle = !scrub && scrub !== 0,\n        scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win),\n        scrollerCache = gsap.core.getCache(scroller),\n        isViewport = _isViewport(scroller),\n        useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\",\n        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n        toggleActions = isToggle && vars.toggleActions.split(\" \"),\n        markers = \"markers\" in vars ? vars.markers : _defaults.markers,\n        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\n        self = this,\n        onRefreshInit = vars.onRefreshInit && function () {\n      return vars.onRefreshInit(self);\n    },\n        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n        lastSnap = 0,\n        lastRefresh = 0,\n        scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),\n        tweenTo,\n        pinCache,\n        snapFunc,\n        scroll1,\n        scroll2,\n        start,\n        end,\n        markerStart,\n        markerEnd,\n        markerStartTrigger,\n        markerEndTrigger,\n        markerVars,\n        change,\n        pinOriginalState,\n        pinActiveState,\n        pinState,\n        spacer,\n        offset,\n        pinGetter,\n        pinSetter,\n        pinStart,\n        pinChange,\n        spacingStart,\n        spacerState,\n        markerStartSetter,\n        markerEndSetter,\n        cs,\n        snap1,\n        snap2,\n        scrubTween,\n        scrubSmooth,\n        snapDurClamp,\n        snapDelayedCall,\n        prevProgress,\n        prevScroll,\n        prevAnimProgress,\n        caMarkerSetter,\n        customRevertReturn;\n\n    _context(self);\n\n    self._dir = direction;\n    anticipatePin *= 45;\n    self.scroller = scroller;\n    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n    scroll1 = scrollFunc();\n    self.vars = vars;\n    animation = animation || vars.animation;\n\n    if (\"refreshPriority\" in vars) {\n      _sort = 1;\n      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n    }\n\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n      left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\n    self.scrubDuration = function (value) {\n      scrubSmooth = _isNumber(value) && value;\n\n      if (!scrubSmooth) {\n        scrubTween && scrubTween.progress(1).kill();\n        scrubTween = 0;\n      } else {\n        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n          ease: \"expo\",\n          totalProgress: \"+=0.001\",\n          duration: scrubSmooth,\n          paused: true,\n          onComplete: function onComplete() {\n            return onScrubComplete && onScrubComplete(self);\n          }\n        });\n      }\n    };\n\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      self.scrubDuration(scrub);\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n\n    _triggers.push(self);\n\n    if (snap) {\n      // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\n      if (!_isObject(snap) || snap.push) {\n        snap = {\n          snapTo: snap\n        };\n      }\n\n      \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: \"auto\"\n      }); // smooth scrolling doesn't work with snap.\n\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {\n        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n      } : gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {\n        var scroll = scrollFunc(),\n            refreshedRecently = _getTime() - lastRefresh < 500,\n            tween = tweenTo.tween;\n\n        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n          var progress = (scroll - start) / change,\n              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,\n              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\n              change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),\n              naturalEnd = progress + (snap.inertia === false ? 0 : change1),\n              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n              endScroll = Math.round(start + endValue * change),\n              _snap = snap,\n              onStart = _snap.onStart,\n              _onInterrupt = _snap.onInterrupt,\n              _onComplete = _snap.onComplete;\n\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\n            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n              return;\n            }\n\n            if (snap.inertia === false) {\n              change1 = endValue - progress;\n            }\n\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || \"power3\",\n              data: _abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onInterrupt: function onInterrupt() {\n                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n              },\n              onComplete: function onComplete() {\n                self.update();\n                lastSnap = scrollFunc();\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n                _onComplete && _onComplete(self);\n              }\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\n            onStart && onStart(self, tweenTo.tween);\n          }\n        } else if (self.isActive && lastSnap !== scroll) {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n\n    id && (_ids[id] = self);\n    trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n\n    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n    customRevertReturn && (customRevertReturn = customRevertReturn(self));\n    pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\n    _isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.\n\n      self.pin = pin;\n      pinCache = gsap.core.getCache(pin);\n\n      if (!pinCache.spacer) {\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n        if (pinSpacer) {\n          pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\n          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n\n          pinCache.spacerIsNative = !!pinSpacer;\n          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n        }\n\n        pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n        spacer.classList.add(\"pin-spacer\");\n        id && spacer.classList.add(\"pin-spacer-\" + id);\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n\n      vars.force3D !== false && gsap.set(pin, {\n        force3D: true\n      });\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing + direction.os2];\n      pinGetter = gsap.getProperty(pin);\n      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n\n      _swapPinIn(pin, spacer, cs);\n\n      pinState = _getState(pin);\n    }\n\n    if (markers) {\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger[\"offset\" + direction.op.d2];\n\n      var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\n\n      markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));\n\n      if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\n        _makePositionable(isViewport ? _body : scroller);\n\n        gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n\n    if (containerAnimation) {\n      var oldOnUpdate = containerAnimation.vars.onUpdate,\n          oldParams = containerAnimation.vars.onUpdateParams;\n      containerAnimation.eventCallback(\"onUpdate\", function () {\n        self.update(0, 0, 1);\n        oldOnUpdate && oldOnUpdate.apply(oldParams || []);\n      });\n    }\n\n    self.previous = function () {\n      return _triggers[_triggers.indexOf(self) - 1];\n    };\n\n    self.next = function () {\n      return _triggers[_triggers.indexOf(self) + 1];\n    };\n\n    self.revert = function (revert, temp) {\n      if (!temp) {\n        return self.kill(true);\n      } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\n\n\n      var r = revert !== false || !self.enabled,\n          prevRefreshing = _refreshing;\n\n      if (r !== self.isReverted) {\n        if (r) {\n          // if (!self.scroll.rec && (_refreshing || _refreshingAll)) {\n          // \tself.scroll.rec = scrollFunc();\n          // \t_refreshingAll && scrollFunc(0);\n          // }\n          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n          return m.style.display = r ? \"none\" : \"block\";\n        });\n        r && (_refreshing = 1);\n        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\n        _refreshing = prevRefreshing;\n        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));\n        self.isReverted = r;\n      }\n    };\n\n    self.refresh = function (soft, force) {\n      if ((_refreshing || !self.enabled) && !force) {\n        return;\n      }\n\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n        return;\n      }\n\n      !_refreshingAll && onRefreshInit && onRefreshInit(self);\n      _refreshing = 1;\n      lastRefresh = _getTime();\n\n      if (tweenTo.tween) {\n        tweenTo.tween.kill();\n        tweenTo.tween = 0;\n      }\n\n      scrubTween && scrubTween.pause();\n      invalidateOnRefresh && animation && animation.revert({\n        kill: false\n      }).invalidate();\n      self.isReverted || self.revert(true, true);\n\n      var size = getScrollerSize(),\n          scrollerBounds = getScrollerOffsets(),\n          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),\n          offset = 0,\n          otherPinOffset = 0,\n          parsedEnd = vars.end,\n          parsedEndTrigger = vars.endTrigger || trigger,\n          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"),\n          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer),\n          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\n          i = triggerIndex,\n          cs,\n          bounds,\n          scroll,\n          isVertical,\n          override,\n          curTrigger,\n          curPin,\n          oppositeScroll,\n          initted,\n          revertedPins;\n\n      while (i--) {\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n        curTrigger = _triggers[i];\n        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n\n        curPin = curTrigger.pin;\n\n        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {\n          revertedPins || (revertedPins = []);\n          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n\n          curTrigger.revert(true, true);\n        }\n\n        if (curTrigger !== _triggers[i]) {\n          // in case it got removed.\n          triggerIndex--;\n          i--;\n        }\n      }\n\n      _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\n      if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n        if (~parsedEnd.indexOf(\" \")) {\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n        } else {\n          offset = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\n          parsedEndTrigger = trigger;\n        }\n      }\n\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;\n      change = end - start || (start -= 0.01) && 0.001;\n      offset = 0;\n      i = triggerIndex;\n\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n\n        if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {\n          cs = curTrigger.end - curTrigger.start;\n\n          if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {\n            // numeric start values shouldn't be offset at all - treat them as absolute\n            offset += cs * (1 - curTrigger.progress);\n          }\n\n          curPin === pin && (otherPinOffset += cs);\n        }\n      }\n\n      start += offset;\n      end += offset;\n      self._pinPush = otherPinOffset;\n\n      if (markerStart && offset) {\n        // offset the markers if necessary\n        cs = {};\n        cs[direction.a] = \"+=\" + offset;\n        pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n        gsap.set([markerStart, markerEnd], cs);\n      }\n\n      if (pin) {\n        cs = _getComputedStyle(pin);\n        isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\n        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n        !max && end > 1 && ((isViewport ? _body : scroller).style[\"overflow-\" + direction.a] = \"scroll\"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n\n        _swapPinIn(pin, spacer, cs);\n\n        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\n        bounds = _getBounds(pin, true);\n        oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\n\n        if (pinSpacing) {\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n\n          _setState(spacerState);\n\n          useFixedPosition && scrollFunc(prevScroll);\n        }\n\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n            boxSizing: \"border-box\",\n            position: \"fixed\"\n          };\n          override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n          override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n          override[_padding] = cs[_padding];\n          override[_padding + _Top] = cs[_padding + _Top];\n          override[_padding + _Right] = cs[_padding + _Right];\n          override[_padding + _Bottom] = cs[_padding + _Bottom];\n          override[_padding + _Left] = cs[_padding + _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n          _refreshingAll && scrollFunc(0);\n        }\n\n        if (animation) {\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n\n          _suppressOverwrites(1);\n\n          animation.render(animation.duration(), true, true);\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n          change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\n          animation.render(0, true, true);\n          initted || animation.invalidate(true);\n          animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\n\n          _suppressOverwrites(0);\n        } else {\n          pinChange = change;\n        }\n      } else if (trigger && scrollFunc() && !containerAnimation) {\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n        bounds = trigger.parentNode;\n\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n\n          bounds = bounds.parentNode;\n        }\n      }\n\n      revertedPins && revertedPins.forEach(function (t) {\n        return t.revert(false, true);\n      });\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\n\n      if (!containerAnimation && !_refreshingAll) {\n        scroll1 < prevScroll && scrollFunc(prevScroll);\n        self.scroll.rec = 0;\n      }\n\n      self.revert(false, true);\n\n      if (snapDelayedCall) {\n        lastSnap = -1;\n        self.isActive && scrollFunc(start + change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value\n\n        snapDelayedCall.restart(true);\n      }\n\n      _refreshing = 0;\n      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n\n      if (prevProgress !== self.progress || containerAnimation) {\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\n        self.progress = (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n      }\n\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //\t\t\tscrubTween && scrubTween.invalidate();\n\n      onRefresh && onRefresh(self);\n    };\n\n    self.getVelocity = function () {\n      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n    };\n\n    self.endAnimation = function () {\n      _endAnimation(self.callbackAnimation);\n\n      if (animation) {\n        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n      }\n    };\n\n    self.labelToScroll = function (label) {\n      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n    };\n\n    self.getTrailing = function (name) {\n      var i = _triggers.indexOf(self),\n          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n\n      return (_isString(name) ? a.filter(function (t) {\n        return t.vars.preventOverlaps === name;\n      }) : a).filter(function (t) {\n        return self.direction > 0 ? t.end <= start : t.start >= end;\n      });\n    };\n\n    self.update = function (reset, recordVelocity, forceFake) {\n      if (containerAnimation && !forceFake && !reset) {\n        return;\n      }\n\n      var scroll = _refreshingAll ? prevScroll : self.scroll(),\n          p = reset ? 0 : (scroll - start) / change,\n          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n          prevProgress = self.progress,\n          isActive,\n          wasActive,\n          toggleState,\n          action,\n          stateChanged,\n          toggled,\n          isAtMax,\n          isTakingAction;\n\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = containerAnimation ? scrollFunc() : scroll;\n\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\n\n      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);\n\n      if (clipped !== prevProgress && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress && prevProgress < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\n        self.direction = clipped > prevProgress ? 1 : -1;\n        self.progress = clipped;\n\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\n            isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n          }\n        }\n\n        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {\n          return t.endAnimation();\n        }));\n\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            (containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n\n            if (scrubTween.resetTo) {\n              scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n            } else {\n              // legacy support (courtesy), before 3.10.0\n              scrubTween.vars.totalProgress = clipped;\n              scrubTween.invalidate().restart();\n            }\n          } else if (animation) {\n            animation.totalProgress(clipped, !!_refreshing);\n          }\n        }\n\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\n          if (!useFixedPosition) {\n            pinSetter(_round(pinStart + pinChange * clipped));\n          } else if (stateChanged) {\n            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\n            if (pinReparent) {\n              if (!reset && (isActive || isAtMax)) {\n                var bounds = _getBounds(pin, true),\n                    _offset = scroll - start;\n\n                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px);\n              } else {\n                _reparent(pin, spacer);\n              }\n            }\n\n            _setState(isActive || isAtMax ? pinActiveState : pinState);\n\n            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n          }\n        }\n\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {\n          return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n        }); // classes could affect positioning, so do it even if reset or refreshing is true.\n\n        onUpdate && !isToggle && !reset && onUpdate(self);\n\n        if (stateChanged && !_refreshing) {\n          if (isToggle) {\n            if (isTakingAction) {\n              if (action === \"complete\") {\n                animation.pause().totalProgress(1);\n              } else if (action === \"reset\") {\n                animation.restart(true).pause();\n              } else if (action === \"restart\") {\n                animation.restart(true);\n              } else {\n                animation[action]();\n              }\n            }\n\n            onUpdate && onUpdate(self);\n          }\n\n          if (toggled || !_limitCallbacks) {\n            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n            onToggle && toggled && _callback(self, onToggle);\n            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n\n            if (!toggled) {\n              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            }\n          }\n\n          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n            _endAnimation(self.callbackAnimation);\n\n            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n\n\n      if (markerEndSetter) {\n        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(n);\n      }\n\n      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n    };\n\n    self.enable = function (reset, refresh) {\n      if (!self.enabled) {\n        self.enabled = true;\n\n        _addListener(scroller, \"resize\", _onResize);\n\n        _addListener(isViewport ? _doc : scroller, \"scroll\", _onScroll);\n\n        onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (reset !== false) {\n          self.progress = prevProgress = 0;\n          scroll1 = scroll2 = lastSnap = scrollFunc();\n        }\n\n        refresh !== false && self.refresh();\n      }\n    };\n\n    self.getTween = function (snap) {\n      return snap && tweenTo ? tweenTo.tween : scrubTween;\n    };\n\n    self.setPositions = function (newStart, newEnd) {\n      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n      if (pin) {\n        pinStart += newStart - start;\n        pinChange += newEnd - newStart - change;\n      }\n\n      self.start = start = newStart;\n      self.end = end = newEnd;\n      change = newEnd - newStart;\n      self.update();\n    };\n\n    self.disable = function (reset, allowAnimation) {\n      if (self.enabled) {\n        reset !== false && self.revert(true, true);\n        self.enabled = self.isActive = false;\n        allowAnimation || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n        }\n\n        if (!isViewport) {\n          var i = _triggers.length;\n\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return; //don't remove the listeners if there are still other triggers referencing it.\n            }\n          }\n\n          _removeListener(scroller, \"resize\", _onResize);\n\n          _removeListener(scroller, \"scroll\", _onScroll);\n        }\n      }\n    };\n\n    self.kill = function (revert, allowAnimation) {\n      self.disable(revert, allowAnimation);\n      scrubTween && !allowAnimation && scrubTween.kill();\n      id && delete _ids[id];\n\n      var i = _triggers.indexOf(self);\n\n      i >= 0 && _triggers.splice(i, 1);\n      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n\n      i = 0;\n\n      _triggers.forEach(function (t) {\n        return t.scroller === self.scroller && (i = 1);\n      });\n\n      i || _refreshingAll || (self.scroll.rec = 0);\n\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.revert({\n          kill: false\n        });\n        allowAnimation || animation.kill();\n      }\n\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n        return m.parentNode && m.parentNode.removeChild(m);\n      });\n      _primary === self && (_primary = 0);\n\n      if (pin) {\n        pinCache && (pinCache.uncache = 1);\n        i = 0;\n\n        _triggers.forEach(function (t) {\n          return t.pin === pin && i++;\n        });\n\n        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n      }\n\n      vars.onKill && vars.onKill(self);\n    };\n\n    self.enable(false, false);\n    customRevertReturn && customRevertReturn(self);\n    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {\n      return start || end || self.refresh();\n    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n  };\n\n  ScrollTrigger.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n      _windowExists() && window.document && ScrollTrigger.enable();\n      _coreInitted = _enabled;\n    }\n\n    return _coreInitted;\n  };\n\n  ScrollTrigger.defaults = function defaults(config) {\n    if (config) {\n      for (var p in config) {\n        _defaults[p] = config[p];\n      }\n    }\n\n    return _defaults;\n  };\n\n  ScrollTrigger.disable = function disable(reset, kill) {\n    _enabled = 0;\n\n    _triggers.forEach(function (trigger) {\n      return trigger[kill ? \"kill\" : \"disable\"](reset);\n    });\n\n    _removeListener(_win, \"wheel\", _onScroll);\n\n    _removeListener(_doc, \"scroll\", _onScroll);\n\n    clearInterval(_syncInterval);\n\n    _removeListener(_doc, \"touchcancel\", _passThrough);\n\n    _removeListener(_body, \"touchstart\", _passThrough);\n\n    _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n\n    _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n\n    _resizeDelay.kill();\n\n    _iterateAutoRefresh(_removeListener);\n\n    for (var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) {\n      _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n\n      _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n    }\n  };\n\n  ScrollTrigger.enable = function enable() {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _clamp = gsap.utils.clamp;\n      _context = gsap.core.context || _passThrough;\n      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n      _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n      gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\n      if (_body) {\n        _enabled = 1;\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\n        ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\n        _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n\n        _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n\n\n        _root = [_win, _doc, _docEl, _body];\n\n        if (gsap.matchMedia) {\n          ScrollTrigger.matchMedia = function (vars) {\n            var mm = gsap.matchMedia(),\n                p;\n\n            for (p in vars) {\n              mm.add(p, vars[p]);\n            }\n\n            return mm;\n          };\n\n          gsap.addEventListener(\"matchMediaInit\", function () {\n            return _revertAll();\n          });\n          gsap.addEventListener(\"matchMediaRevert\", function () {\n            return _revertRecorded();\n          });\n          gsap.addEventListener(\"matchMedia\", function () {\n            _refreshAll(0, 1);\n\n            _dispatch(\"matchMedia\");\n          });\n          gsap.matchMedia(\"(orientation: portrait)\", function () {\n            // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n            _setBaseDimensions();\n\n            return _setBaseDimensions;\n          });\n        } else {\n          console.warn(\"Requires GSAP 3.11.0 or later\");\n        }\n\n        _setBaseDimensions();\n\n        _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\n\n        var bodyStyle = _body.style,\n            border = bodyStyle.borderTopStyle,\n            AnimationProto = gsap.core.Animation.prototype,\n            bounds,\n            i;\n        AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n          value: function value() {\n            return this.time(-0.01, true);\n          }\n        }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\n\n        bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\n        bounds = _getBounds(_body);\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\n        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n\n        _syncInterval = setInterval(_sync, 250);\n        gsap.delayedCall(0.5, function () {\n          return _startup = 0;\n        });\n\n        _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\n\n        _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n\n        _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n\n        _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n\n        _transformProp = gsap.utils.checkPrefix(\"transform\");\n\n        _stateProps.push(_transformProp);\n\n        _coreInitted = _getTime();\n        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n        _autoRefresh = [_doc, \"visibilitychange\", function () {\n          var w = _win.innerWidth,\n              h = _win.innerHeight;\n\n          if (_doc.hidden) {\n            _prevWidth = w;\n            _prevHeight = h;\n          } else if (_prevWidth !== w || _prevHeight !== h) {\n            _onResize();\n          }\n        }, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", _refreshAll, _win, \"resize\", _onResize];\n\n        _iterateAutoRefresh(_addListener);\n\n        _triggers.forEach(function (trigger) {\n          return trigger.enable(0, 1);\n        });\n\n        for (i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) {\n          _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n\n          _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n        }\n      }\n    }\n  };\n\n  ScrollTrigger.config = function config(vars) {\n    \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    var ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n\n    if (\"autoRefreshEvents\" in vars) {\n      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n      _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n    }\n  };\n\n  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n    var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target),\n        i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t),\n        isViewport = _isViewport(t);\n\n    if (~i) {\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\n    }\n\n    if (vars) {\n      isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\n    }\n  };\n\n  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n    _triggers.forEach(function (t) {\n      return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n    });\n  };\n\n  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n    var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(),\n        offset = bounds[horizontal ? _width : _height] * ratio || 0;\n    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n  };\n\n  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n    _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\n    var bounds = element.getBoundingClientRect(),\n        size = bounds[horizontal ? _width : _height],\n        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n  };\n\n  ScrollTrigger.killAll = function killAll(allowListeners) {\n    _triggers.forEach(function (t) {\n      return t.vars.id !== \"ScrollSmoother\" && t.kill();\n    });\n\n    if (allowListeners !== true) {\n      var listeners = _listeners.killAll || [];\n      _listeners = {};\n      listeners.forEach(function (f) {\n        return f();\n      });\n    }\n  };\n\n  return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.11.2\";\n\nScrollTrigger.saveStyles = function (targets) {\n  return targets ? _toArray(targets).forEach(function (target) {\n    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n    if (target && target.style) {\n      var i = _savedStyles.indexOf(target);\n\n      i >= 0 && _savedStyles.splice(i, 5);\n\n      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n    }\n  }) : _savedStyles;\n};\n\nScrollTrigger.revert = function (soft, media) {\n  return _revertAll(!soft, media);\n};\n\nScrollTrigger.create = function (vars, animation) {\n  return new ScrollTrigger(vars, animation);\n};\n\nScrollTrigger.refresh = function (safe) {\n  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\n\nScrollTrigger.update = _updateAll;\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\n\nScrollTrigger.maxScroll = function (element, horizontal) {\n  return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\n\nScrollTrigger.getScrollFunc = function (element, horizontal) {\n  return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\n\nScrollTrigger.getById = function (id) {\n  return _ids[id];\n};\n\nScrollTrigger.getAll = function () {\n  return _triggers.filter(function (t) {\n    return t.vars.id !== \"ScrollSmoother\";\n  });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\n\n\nScrollTrigger.isScrolling = function () {\n  return !!_lastScrollTime;\n};\n\nScrollTrigger.snapDirectional = _snapDirectional;\n\nScrollTrigger.addEventListener = function (type, callback) {\n  var a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\n\nScrollTrigger.removeEventListener = function (type, callback) {\n  var a = _listeners[type],\n      i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\n\nScrollTrigger.batch = function (targets, vars) {\n  var result = [],\n      varsCopy = {},\n      interval = vars.interval || 0.016,\n      batchMax = vars.batchMax || 1e9,\n      proxyCallback = function proxyCallback(type, callback) {\n    var elements = [],\n        triggers = [],\n        delay = gsap.delayedCall(interval, function () {\n      callback(elements, triggers);\n      elements = [];\n      triggers = [];\n    }).pause();\n    return function (self) {\n      elements.length || delay.restart(true);\n      elements.push(self.trigger);\n      triggers.push(self);\n      batchMax <= elements.length && delay.progress(1);\n    };\n  },\n      p;\n\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n\n  if (_isFunction(batchMax)) {\n    batchMax = batchMax();\n\n    _addListener(ScrollTrigger, \"refresh\", function () {\n      return batchMax = vars.batchMax();\n    });\n  }\n\n  _toArray(targets).forEach(function (target) {\n    var config = {};\n\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n\n  return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\n\n\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n},\n    _allowNativePanning = function _allowNativePanning(target, direction) {\n  if (direction === true) {\n    target.style.removeProperty(\"touch-action\");\n  } else {\n    target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n  }\n\n  target === _docEl && _allowNativePanning(_body, direction);\n},\n    _overflow = {\n  auto: 1,\n  scroll: 1\n},\n    _nestedScroll = function _nestedScroll(_ref5) {\n  var event = _ref5.event,\n      target = _ref5.target,\n      axis = _ref5.axis;\n\n  var node = (event.changedTouches ? event.changedTouches[0] : event).target,\n      cache = node._gsap || gsap.core.getCache(node),\n      time = _getTime(),\n      cs;\n\n  if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n    // cache for 2 seconds to improve performance.\n    while (node && node.scrollHeight <= node.clientHeight) {\n      node = node.parentNode;\n    }\n\n    cache._isScroll = node && !_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n    cache._isScrollT = time;\n  }\n\n  if (cache._isScroll || axis === \"x\") {\n    event.stopPropagation();\n    event._gsapAllow = true;\n  }\n},\n    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n  return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\n    target: target,\n    capture: true,\n    debounce: false,\n    lockAxis: true,\n    type: type,\n    onWheel: nested = nested && _nestedScroll,\n    onPress: nested,\n    onDrag: nested,\n    onScroll: nested,\n    onEnable: function onEnable() {\n      return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\n    },\n    onDisable: function onDisable() {\n      return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\n    }\n  });\n},\n    _inputExp = /(input|label|select|textarea)/i,\n    _inputIsFocused,\n    _captureInputs = function _captureInputs(e) {\n  var isInput = _inputExp.test(e.target.tagName);\n\n  if (isInput || _inputIsFocused) {\n    e._gsapAllow = true;\n    _inputIsFocused = isInput;\n  }\n},\n    _getScrollNormalizer = function _getScrollNormalizer(vars) {\n  _isObject(vars) || (vars = {});\n  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n  vars.type || (vars.type = \"wheel,touch\");\n  vars.debounce = !!vars.debounce;\n  vars.id = vars.id || \"normalizer\";\n\n  var _vars2 = vars,\n      normalizeScrollX = _vars2.normalizeScrollX,\n      momentum = _vars2.momentum,\n      allowNestedScroll = _vars2.allowNestedScroll,\n      self,\n      maxY,\n      target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl,\n      smoother = gsap.core.globals().ScrollSmoother,\n      smootherInstance = smoother && smoother.get(),\n      content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),\n      scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n      scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal),\n      scale = 1,\n      initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,\n      wheelRefresh = 0,\n      resolveMomentumDuration = _isFunction(momentum) ? function () {\n    return momentum(self);\n  } : function () {\n    return momentum || 2.8;\n  },\n      lastRefreshID,\n      skipTouchMove,\n      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),\n      resumeTouchMove = function resumeTouchMove() {\n    return skipTouchMove = false;\n  },\n      scrollClampX = _passThrough,\n      scrollClampY = _passThrough,\n      updateClamps = function updateClamps() {\n    maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\n    lastRefreshID = _refreshID;\n  },\n      removeContentOffset = function removeContentOffset() {\n    content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n    content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n    scrollFuncY.offset = scrollFuncY.cacheID = 0;\n  },\n      ignoreDrag = function ignoreDrag() {\n    if (skipTouchMove) {\n      requestAnimationFrame(resumeTouchMove);\n\n      var offset = _round(self.deltaY / 2),\n          scroll = scrollClampY(scrollFuncY.v - offset);\n\n      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n        scrollFuncY.offset = scroll - scrollFuncY.v;\n\n        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n        content._gsap.y = y + \"px\";\n        scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n\n        _updateAll();\n      }\n\n      return true;\n    }\n\n    scrollFuncY.offset && removeContentOffset();\n    skipTouchMove = true;\n  },\n      tween,\n      startScrollX,\n      startScrollY,\n      onStopDelayedCall,\n      onResize = function onResize() {\n    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n    updateClamps();\n\n    if (tween.isActive() && tween.vars.scrollY > maxY) {\n      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n    }\n  };\n\n  content && gsap.set(content, {\n    y: \"+=0\"\n  }); // to ensure there's a cache (element._gsap)\n\n  vars.ignoreCheck = function (e) {\n    return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n  };\n\n  vars.onPress = function () {\n    var prevScale = scale;\n    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n    tween.pause();\n    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n    startScrollX = scrollFuncX();\n    startScrollY = scrollFuncY();\n    updateClamps();\n    lastRefreshID = _refreshID;\n  };\n\n  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {\n    scrollFuncY.offset && removeContentOffset();\n\n    if (!wasDragging) {\n      onStopDelayedCall.restart(true);\n    } else {\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // make sure we're pulling the non-cached value\n      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n\n      var dur = resolveMomentumDuration(),\n          currentScroll,\n          endScroll;\n\n      if (normalizeScrollX) {\n        currentScroll = scrollFuncX();\n        endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n\n        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\n        tween.vars.scrollX = scrollClampX(endScroll);\n      }\n\n      currentScroll = scrollFuncY();\n      endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n\n      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\n      tween.vars.scrollY = scrollClampY(endScroll);\n      tween.invalidate().duration(dur).play(0.01);\n\n      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n        // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n        gsap.to({}, {\n          onUpdate: onResize,\n          duration: dur\n        });\n      }\n    }\n  };\n\n  vars.onWheel = function () {\n    tween._ts && tween.pause();\n\n    if (_getTime() - wheelRefresh > 1000) {\n      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n      lastRefreshID = 0;\n      wheelRefresh = _getTime();\n    }\n  };\n\n  vars.onChange = function (self, dx, dy, xArray, yArray) {\n    _refreshID !== lastRefreshID && updateClamps();\n    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n\n    if (dy) {\n      scrollFuncY.offset && removeContentOffset();\n      var isTouch = yArray[2] === dy,\n          y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],\n          yClamped = scrollClampY(y);\n      isTouch && y !== yClamped && (startScrollY += yClamped - y);\n      scrollFuncY(yClamped);\n    }\n\n    (dy || dx) && _updateAll();\n  };\n\n  vars.onEnable = function () {\n    _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n\n    ScrollTrigger.addEventListener(\"refresh\", onResize);\n\n    _addListener(_win, \"resize\", onResize);\n\n    if (scrollFuncY.smooth) {\n      scrollFuncY.target.style.scrollBehavior = \"auto\";\n      scrollFuncY.smooth = scrollFuncX.smooth = false;\n    }\n\n    inputObserver.enable();\n  };\n\n  vars.onDisable = function () {\n    _allowNativePanning(target, true);\n\n    _removeListener(_win, \"resize\", onResize);\n\n    ScrollTrigger.removeEventListener(\"refresh\", onResize);\n    inputObserver.kill();\n  };\n\n  vars.lockAxis = vars.lockAxis !== false;\n  self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n\n  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n\n  _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\n\n  onStopDelayedCall = self._dc;\n  tween = gsap.to(self, {\n    ease: \"power4\",\n    paused: true,\n    scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n    scrollY: \"+=0.1\",\n    onComplete: onStopDelayedCall.vars.onComplete\n  });\n  return self;\n};\n\nScrollTrigger.sort = function (func) {\n  return _triggers.sort(func || function (a, b) {\n    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);\n  });\n};\n\nScrollTrigger.observe = function (vars) {\n  return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n};\n\nScrollTrigger.normalizeScroll = function (vars) {\n  if (typeof vars === \"undefined\") {\n    return _normalizer;\n  }\n\n  if (vars === true && _normalizer) {\n    return _normalizer.enable();\n  }\n\n  if (vars === false) {\n    return _normalizer && _normalizer.kill();\n  }\n\n  var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\n  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n  _isViewport(normalizer.target) && (_normalizer = normalizer);\n  return normalizer;\n};\n\nScrollTrigger.core = {\n  // smaller file size way to leverage in ScrollSmoother and Observer\n  _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\n  _inputObserver: _inputObserver,\n  _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\n  _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\n  bridge: {\n    // when normalizeScroll sets the scroll position (ss = setScroll)\n    ss: function ss() {\n      _lastScrollTime || _dispatch(\"scrollStart\");\n      _lastScrollTime = _getTime();\n    },\n    // a way to get the _refreshing value in Observer\n    ref: function ref() {\n      return _refreshing;\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvSjs7QUFFcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFNBQVMsMkRBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkRBQWE7QUFDM0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlCQUF5QiwwREFBZ0I7QUFDekM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUFhO0FBQ2xELENBQUM7QUFDRDtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsMkRBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkJBQTJCLG9CQUFvQiwrQkFBK0Isb0JBQW9CLG1CQUFtQiw2QkFBNkIsYUFBYSxnQkFBZ0IsZUFBZSxtQkFBbUI7O0FBRXpQLHdGQUF3RixjQUFjO0FBQ3RHLG9GQUFvRixtREFBUyxpRUFBaUU7QUFDOUosaURBQWlELGdCQUFnQix5Q0FBeUM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRSwwREFBZ0I7QUFDbEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBRSwwREFBZ0I7QUFDbEIsZ0NBQWdDLDREQUFrQjtBQUNsRDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRSw0REFBa0I7QUFDcEI7QUFDQSxHQUFHLEdBQUc7OztBQUdOOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSw0REFBa0I7QUFDcEI7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHLEdBQUc7OztBQUdOO0FBQ0E7QUFDQSxHQUFHLEdBQUc7OztBQUdOO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU4sRUFBRSw0REFBa0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscURBQVc7QUFDbkQseUNBQXlDLG1EQUFTO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkMseUNBQXlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0RBQVU7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BELDZCQUE2QiwwQkFBMEIsV0FBVyxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLDREQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7OztBQUczRDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHFEQUFXLEdBQUcsbURBQVM7QUFDckg7QUFDQSxtQkFBbUIsd0RBQVU7QUFDN0I7QUFDQTtBQUNBLCtEQUErRCwyREFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQSxzQ0FBc0MsbURBQVM7QUFDL0MsdUNBQXVDLHFEQUFXO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSw2QkFBNkIsd0RBQVUsa0JBQWtCOztBQUV6RDtBQUNBO0FBQ0EsbUNBQW1DLHdEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrSkFBK0o7O0FBRS9KO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFVO0FBQ2hDLDBHQUEwRzs7QUFFMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxRkFBcUY7O0FBRWhKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0RBQVUsQ0FBQywyREFBYTs7QUFFNUM7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyx5REFBZSxJQUFJLDJEQUFhO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsd0RBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTs7QUFFekU7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxtREFBUztBQUM1QywrQkFBK0I7O0FBRS9CO0FBQ0EsMEdBQTBHOztBQUUxRzs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0EsNkNBQTZDLDREQUFjLHdCQUF3QixxREFBVyxHQUFHLG1EQUFTOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBLDJHQUEyRzs7QUFFM0c7QUFDQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBLHlNQUF5TTs7QUFFek07QUFDQTtBQUNBLCtFQUErRTs7QUFFL0U7QUFDQTs7QUFFQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBLHVHQUF1Rzs7QUFFdkc7QUFDQSw0SUFBNEk7O0FBRTVJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esa0lBQWtJOztBQUVsSTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNkhBQTZIOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRUFBa0UsbURBQVMsb0RBQW9ELG1EQUFTO0FBQ3hJLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGOztBQUV4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsSUFBSSwyREFBaUIsRUFBRTtBQUMzQyxzQ0FBc0Msb0RBQVUsS0FBSyxvREFBVTs7QUFFL0Qsc0NBQXNDLG9EQUFVLEtBQUssb0RBQVU7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBLFFBQVEsMkRBQWlCLFFBQVE7O0FBRWpDLGdDQUFnQywwREFBZ0I7QUFDaEQscUJBQXFCLDBEQUFnQix5REFBeUQ7O0FBRTlGLGdEQUFnRDs7O0FBR2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7OztBQUdqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7O0FBRVosNENBQTRDOztBQUU1QztBQUNBLFFBQVEscURBQVcsMkJBQTJCLHNEQUFZLFVBQVU7O0FBRXBFLFFBQVEsdURBQWEsNEJBQTRCLHdEQUFjO0FBQy9ELG1HQUFtRzs7QUFFbkc7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx5REFBeUQ7OztBQUd6RCx5REFBeUQ7OztBQUd6RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxvQkFBb0IsSUFBSSwyREFBaUIsRUFBRTtBQUMzQywwQ0FBMEMsb0RBQVUsS0FBSyxvREFBVTs7QUFFbkUsMENBQTBDLG9EQUFVLEtBQUssb0RBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3REFBVTtBQUN0QixZQUFZLDREQUFrQjtBQUM5Qjs7QUFFQTtBQUNBLE1BQU0sMkRBQWlCO0FBQ3ZCOztBQUVBO0FBQ0EsbUJBQW1CLDBEQUFnQiwwQ0FBMEMsMERBQWdCO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsdUNBQXVDLHdEQUFVO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyx3REFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLHFEQUFXLEdBQUcsbURBQVM7QUFDakU7O0FBRUE7QUFDQSxTQUFTLDREQUFjLENBQUMsd0RBQVUsd0JBQXdCLHFEQUFXLEdBQUcsbURBQVM7QUFDakY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osK0ZBQStGLDBEQUFnQixpQ0FBaUM7QUFDaEo7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxTQUFTLHlEQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdFQUFzQjtBQUNoRSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsZ0VBQXNCO0FBQ3pEO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFVO0FBQ3pCO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQVU7QUFDekQsb0JBQW9CLDREQUFjLFNBQVMsbURBQVM7QUFDcEQsb0JBQW9CLDREQUFjLFNBQVMscURBQVc7QUFDdEQ7QUFDQSxzQkFBc0IsMERBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBUztBQUN2QztBQUNBLHFFQUFxRSxxREFBVztBQUNoRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWdCOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSwwREFBZ0IsSUFBSTtBQUMxQixxSkFBcUo7O0FBRXJKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFOztBQUUxRSw4R0FBOEcscURBQVc7QUFDekg7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTs7QUFFeEUsNEdBQTRHLG1EQUFTO0FBQ3JIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0pBQW9KOztBQUVwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrREFBUTtBQUNyQix5QkFBeUI7O0FBRXpCLGtEQUFrRDs7QUFFbEQsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWEsa0RBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsa0RBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwwREFBZ0I7QUFDcEM7QUFDQSxjQUFjLG9EQUFVO0FBQ3hCLFlBQVksa0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzP2UxMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTY3JvbGxUcmlnZ2VyIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IE9ic2VydmVyLCBfZ2V0VGFyZ2V0LCBfdmVydGljYWwsIF9ob3Jpem9udGFsLCBfc2Nyb2xsZXJzLCBfcHJveGllcywgX2dldFNjcm9sbEZ1bmMsIF9nZXRQcm94eVByb3AsIF9nZXRWZWxvY2l0eVByb3AgfSBmcm9tIFwiLi9PYnNlcnZlci5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfcm9vdCxcbiAgICBfcmVzaXplRGVsYXksXG4gICAgX3RvQXJyYXksXG4gICAgX2NsYW1wLFxuICAgIF90aW1lMixcbiAgICBfc3luY0ludGVydmFsLFxuICAgIF9yZWZyZXNoaW5nLFxuICAgIF9wb2ludGVySXNEb3duLFxuICAgIF90cmFuc2Zvcm1Qcm9wLFxuICAgIF9pLFxuICAgIF9wcmV2V2lkdGgsXG4gICAgX3ByZXZIZWlnaHQsXG4gICAgX2F1dG9SZWZyZXNoLFxuICAgIF9zb3J0LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX2lnbm9yZVJlc2l6ZSxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfaWdub3JlTW9iaWxlUmVzaXplLFxuICAgIF9iYXNlU2NyZWVuSGVpZ2h0LFxuICAgIF9iYXNlU2NyZWVuV2lkdGgsXG4gICAgX2ZpeElPU0J1ZyxcbiAgICBfY29udGV4dCxcbiAgICBfc2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgX2xpbWl0Q2FsbGJhY2tzLFxuICAgIC8vIGlmIHRydWUsIHdlJ2xsIG9ubHkgdHJpZ2dlciBjYWxsYmFja3MgaWYgdGhlIGFjdGl2ZSBzdGF0ZSB0b2dnbGVzLCBzbyBpZiB5b3Ugc2Nyb2xsIGltbWVkaWF0ZWx5IHBhc3QgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgYSBTY3JvbGxUcmlnZ2VyICh0aHVzIGluYWN0aXZlIHRvIGluYWN0aXZlKSwgbmVpdGhlciBpdHMgb25FbnRlciBub3Igb25MZWF2ZSB3aWxsIGJlIGNhbGxlZC4gVGhpcyBpcyB1c2VmdWwgZHVyaW5nIHN0YXJ0dXAuXG5fc3RhcnR1cCA9IDEsXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfdGltZTEgPSBfZ2V0VGltZSgpLFxuICAgIF9sYXN0U2Nyb2xsVGltZSA9IDAsXG4gICAgX2VuYWJsZWQgPSAwLFxuICAgIF9wb2ludGVyRG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfcG9pbnRlckRvd25IYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAxO1xufSxcbiAgICBfcG9pbnRlclVwSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyVXBIYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAwO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZSkge1xuICByZXR1cm4gISF+X3Jvb3QuaW5kZXhPZihlKTtcbn0sXG4gICAgX2dldEJvdW5kc0Z1bmMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSB7XG4gIHJldHVybiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IGZ1bmN0aW9uICgpIHtcbiAgICBfd2luT2Zmc2V0cy53aWR0aCA9IF93aW4uaW5uZXJXaWR0aDtcbiAgICBfd2luT2Zmc2V0cy5oZWlnaHQgPSBfd2luLmlubmVySGVpZ2h0O1xuICAgIHJldHVybiBfd2luT2Zmc2V0cztcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgfSk7XG59LFxuICAgIF9nZXRTaXplRnVuYyA9IGZ1bmN0aW9uIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgX3JlZikge1xuICB2YXIgZCA9IF9yZWYuZCxcbiAgICAgIGQyID0gX3JlZi5kMixcbiAgICAgIGEgPSBfcmVmLmE7XG4gIHJldHVybiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYSgpW2RdO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoaXNWaWV3cG9ydCA/IF93aW5bXCJpbm5lclwiICsgZDJdIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcbiAgfTtcbn0sXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcbiAgcmV0dXJuICFpc1ZpZXdwb3J0IHx8IH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpID8gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9O1xufSxcbiAgICBfbWF4U2Nyb2xsID0gZnVuY3Rpb24gX21heFNjcm9sbChlbGVtZW50LCBfcmVmMikge1xuICB2YXIgcyA9IF9yZWYyLnMsXG4gICAgICBkMiA9IF9yZWYyLmQyLFxuICAgICAgZCA9IF9yZWYyLmQsXG4gICAgICBhID0gX3JlZjIuYTtcbiAgcmV0dXJuIChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gKF9kb2NFbFtzXSB8fCBfYm9keVtzXSkgLSAoX3dpbltcImlubmVyXCIgKyBkMl0gfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkMl0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGQyXSkgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdO1xufSxcbiAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoID0gZnVuY3Rpb24gX2l0ZXJhdGVBdXRvUmVmcmVzaChmdW5jLCBldmVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXV0b1JlZnJlc2gubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2kgKyAxXSkpICYmIGZ1bmMoX2F1dG9SZWZyZXNoW2ldLCBfYXV0b1JlZnJlc2hbaSArIDFdLCBfYXV0b1JlZnJlc2hbaSArIDJdKTtcbiAgfVxufSxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2NhbGxJZkZ1bmMgPSBmdW5jdGlvbiBfY2FsbElmRnVuYyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpICYmIHZhbHVlKCk7XG59LFxuICAgIF9jb21iaW5lRnVuYyA9IGZ1bmN0aW9uIF9jb21iaW5lRnVuYyhmMSwgZjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0MSA9IF9jYWxsSWZGdW5jKGYxKSxcbiAgICAgICAgcmVzdWx0MiA9IF9jYWxsSWZGdW5jKGYyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfY2FsbElmRnVuYyhyZXN1bHQxKTtcblxuICAgICAgX2NhbGxJZkZ1bmMocmVzdWx0Mik7XG4gICAgfTtcbiAgfTtcbn0sXG4gICAgX2VuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCByZXZlcnNlZCwgcGF1c2UpIHtcbiAgcmV0dXJuIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocmV2ZXJzZWQgPyAwIDogMSkgJiYgcGF1c2UgJiYgYW5pbWF0aW9uLnBhdXNlKCk7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhzZWxmLCBmdW5jKSB7XG4gIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuYyhzZWxmKTtcbiAgICByZXN1bHQgJiYgcmVzdWx0LnRvdGFsVGltZSAmJiAoc2VsZi5jYWxsYmFja0FuaW1hdGlvbiA9IHJlc3VsdCk7XG4gIH1cbn0sXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX2xlZnQgPSBcImxlZnRcIixcbiAgICBfdG9wID0gXCJ0b3BcIixcbiAgICBfcmlnaHQgPSBcInJpZ2h0XCIsXG4gICAgX2JvdHRvbSA9IFwiYm90dG9tXCIsXG4gICAgX3dpZHRoID0gXCJ3aWR0aFwiLFxuICAgIF9oZWlnaHQgPSBcImhlaWdodFwiLFxuICAgIF9SaWdodCA9IFwiUmlnaHRcIixcbiAgICBfTGVmdCA9IFwiTGVmdFwiLFxuICAgIF9Ub3AgPSBcIlRvcFwiLFxuICAgIF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuICAgIF9wYWRkaW5nID0gXCJwYWRkaW5nXCIsXG4gICAgX21hcmdpbiA9IFwibWFyZ2luXCIsXG4gICAgX1dpZHRoID0gXCJXaWR0aFwiLFxuICAgIF9IZWlnaHQgPSBcIkhlaWdodFwiLFxuICAgIF9weCA9IFwicHhcIixcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0sXG4gICAgX21ha2VQb3NpdGlvbmFibGUgPSBmdW5jdGlvbiBfbWFrZVBvc2l0aW9uYWJsZShlbGVtZW50KSB7XG4gIC8vIGlmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIHBvc2l0aW9uOiBhYnNvbHV0ZSBvciBmaXhlZCwgbGVhdmUgdGhhdCwgb3RoZXJ3aXNlIG1ha2UgaXQgcG9zaXRpb246IHJlbGF0aXZlXG4gIHZhciBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBwb3NpdGlvbiA6IFwicmVsYXRpdmVcIjtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfZ2V0Qm91bmRzID0gZnVuY3Rpb24gX2dldEJvdW5kcyhlbGVtZW50LCB3aXRob3V0VHJhbnNmb3Jtcykge1xuICB2YXIgdHdlZW4gPSB3aXRob3V0VHJhbnNmb3JtcyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gIT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgJiYgZ3NhcC50byhlbGVtZW50LCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHhQZXJjZW50OiAwLFxuICAgIHlQZXJjZW50OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHJvdGF0aW9uWDogMCxcbiAgICByb3RhdGlvblk6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgc2tld1g6IDAsXG4gICAgc2tld1k6IDBcbiAgfSkucHJvZ3Jlc3MoMSksXG4gICAgICBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB0d2VlbiAmJiB0d2Vlbi5wcm9ncmVzcygwKS5raWxsKCk7XG4gIHJldHVybiBib3VuZHM7XG59LFxuICAgIF9nZXRTaXplID0gZnVuY3Rpb24gX2dldFNpemUoZWxlbWVudCwgX3JlZjMpIHtcbiAgdmFyIGQyID0gX3JlZjMuZDI7XG4gIHJldHVybiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDA7XG59LFxuICAgIF9nZXRMYWJlbFJhdGlvQXJyYXkgPSBmdW5jdGlvbiBfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBkdXJhdGlvbiA9IHRpbWVsaW5lLmR1cmF0aW9uKCksXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBhLnB1c2gobGFiZWxzW3BdIC8gZHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LFxuICAgIF9nZXRDbG9zZXN0TGFiZWwgPSBmdW5jdGlvbiBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdzYXAudXRpbHMuc25hcChfZ2V0TGFiZWxSYXRpb0FycmF5KGFuaW1hdGlvbiksIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgX3NuYXBEaXJlY3Rpb25hbCA9IGZ1bmN0aW9uIF9zbmFwRGlyZWN0aW9uYWwoc25hcEluY3JlbWVudE9yQXJyYXkpIHtcbiAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoc25hcEluY3JlbWVudE9yQXJyYXkpLFxuICAgICAgYSA9IEFycmF5LmlzQXJyYXkoc25hcEluY3JlbWVudE9yQXJyYXkpICYmIHNuYXBJbmNyZW1lbnRPckFycmF5LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICByZXR1cm4gYSA/IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIHNuYXAodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB2YWx1ZSAtPSB0aHJlc2hvbGQ7IC8vIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9ycy4gSWYgd2UncmUgdG9vIHN0cmljdCwgaXQgbWlnaHQgc25hcCBmb3J3YXJkLCB0aGVuIGltbWVkaWF0ZWx5IGFnYWluLCBhbmQgYWdhaW4uXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID49IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFbaSAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gYS5sZW5ndGg7XG4gICAgICB2YWx1ZSArPSB0aHJlc2hvbGQ7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGFbaV0gPD0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhWzBdO1xuICB9IDogZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMWUtMztcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZCA9IHNuYXAodmFsdWUpO1xuICAgIHJldHVybiAhZGlyZWN0aW9uIHx8IE1hdGguYWJzKHNuYXBwZWQgLSB2YWx1ZSkgPCB0aHJlc2hvbGQgfHwgc25hcHBlZCAtIHZhbHVlIDwgMCA9PT0gZGlyZWN0aW9uIDwgMCA/IHNuYXBwZWQgOiBzbmFwKGRpcmVjdGlvbiA8IDAgPyB2YWx1ZSAtIHNuYXBJbmNyZW1lbnRPckFycmF5IDogdmFsdWUgKyBzbmFwSW5jcmVtZW50T3JBcnJheSk7XG4gIH07XG59LFxuICAgIF9nZXRMYWJlbEF0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsQXREaXJlY3Rpb24odGltZWxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgc3QpIHtcbiAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSkodmFsdWUsIHN0LmRpcmVjdGlvbik7XG4gIH07XG59LFxuICAgIF9tdWx0aUxpc3RlbmVyID0gZnVuY3Rpb24gX211bHRpTGlzdGVuZXIoZnVuYywgZWxlbWVudCwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBmdW5jKGVsZW1lbnQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBub25QYXNzaXZlLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xuICAgIHBhc3NpdmU6ICFub25QYXNzaXZlLFxuICAgIGNhcHR1cmU6ICEhY2FwdHVyZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xufSxcbiAgICBfd2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uIF93aGVlbExpc3RlbmVyKGZ1bmMsIGVsLCBzY3JvbGxGdW5jKSB7XG4gIHJldHVybiBzY3JvbGxGdW5jICYmIHNjcm9sbEZ1bmMud2hlZWxIYW5kbGVyICYmIGZ1bmMoZWwsIFwid2hlZWxcIiwgc2Nyb2xsRnVuYyk7XG59LFxuICAgIF9tYXJrZXJEZWZhdWx0cyA9IHtcbiAgc3RhcnRDb2xvcjogXCJncmVlblwiLFxuICBlbmRDb2xvcjogXCJyZWRcIixcbiAgaW5kZW50OiAwLFxuICBmb250U2l6ZTogXCIxNnB4XCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICB0b2dnbGVBY3Rpb25zOiBcInBsYXlcIixcbiAgYW50aWNpcGF0ZVBpbjogMFxufSxcbiAgICBfa2V5d29yZHMgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgY2VudGVyOiAwLjUsXG4gIGJvdHRvbTogMSxcbiAgcmlnaHQ6IDFcbn0sXG4gICAgX29mZnNldFRvUHggPSBmdW5jdGlvbiBfb2Zmc2V0VG9QeCh2YWx1ZSwgc2l6ZSkge1xuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBlcUluZGV4ID0gdmFsdWUuaW5kZXhPZihcIj1cIiksXG4gICAgICAgIHJlbGF0aXZlID0gfmVxSW5kZXggPyArKHZhbHVlLmNoYXJBdChlcUluZGV4IC0gMSkgKyAxKSAqIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKGVxSW5kZXggKyAxKSkgOiAwO1xuXG4gICAgaWYgKH5lcUluZGV4KSB7XG4gICAgICB2YWx1ZS5pbmRleE9mKFwiJVwiKSA+IGVxSW5kZXggJiYgKHJlbGF0aXZlICo9IHNpemUgLyAxMDApO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleCAtIDEpO1xuICAgIH1cblxuICAgIHZhbHVlID0gcmVsYXRpdmUgKyAodmFsdWUgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3ZhbHVlXSAqIHNpemUgOiB+dmFsdWUuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHZhbHVlKSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn0sXG4gICAgX2NyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIF9jcmVhdGVNYXJrZXIodHlwZSwgbmFtZSwgY29udGFpbmVyLCBkaXJlY3Rpb24sIF9yZWY0LCBvZmZzZXQsIG1hdGNoV2lkdGhFbCwgY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gIHZhciBzdGFydENvbG9yID0gX3JlZjQuc3RhcnRDb2xvcixcbiAgICAgIGVuZENvbG9yID0gX3JlZjQuZW5kQ29sb3IsXG4gICAgICBmb250U2l6ZSA9IF9yZWY0LmZvbnRTaXplLFxuICAgICAgaW5kZW50ID0gX3JlZjQuaW5kZW50LFxuICAgICAgZm9udFdlaWdodCA9IF9yZWY0LmZvbnRXZWlnaHQ7XG5cbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICB1c2VGaXhlZFBvc2l0aW9uID0gX2lzVmlld3BvcnQoY29udGFpbmVyKSB8fCBfZ2V0UHJveHlQcm9wKGNvbnRhaW5lciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG4gICAgICBpc1Njcm9sbGVyID0gdHlwZS5pbmRleE9mKFwic2Nyb2xsZXJcIikgIT09IC0xLFxuICAgICAgcGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxuICAgICAgaXNTdGFydCA9IHR5cGUuaW5kZXhPZihcInN0YXJ0XCIpICE9PSAtMSxcbiAgICAgIGNvbG9yID0gaXNTdGFydCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcixcbiAgICAgIGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xuXG4gIGNzcyArPSBcInBvc2l0aW9uOlwiICsgKChpc1Njcm9sbGVyIHx8IGNvbnRhaW5lckFuaW1hdGlvbikgJiYgdXNlRml4ZWRQb3NpdGlvbiA/IFwiZml4ZWQ7XCIgOiBcImFic29sdXRlO1wiKTtcbiAgKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uIHx8ICF1c2VGaXhlZFBvc2l0aW9uKSAmJiAoY3NzICs9IChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9yaWdodCA6IF9ib3R0b20pICsgXCI6XCIgKyAob2Zmc2V0ICsgcGFyc2VGbG9hdChpbmRlbnQpKSArIFwicHg7XCIpO1xuICBtYXRjaFdpZHRoRWwgJiYgKGNzcyArPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6XCIgKyBtYXRjaFdpZHRoRWwub2Zmc2V0V2lkdGggKyBcInB4O1wiKTtcbiAgZS5faXNTdGFydCA9IGlzU3RhcnQ7XG4gIGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJnc2FwLW1hcmtlci1cIiArIHR5cGUgKyAobmFtZSA/IFwiIG1hcmtlci1cIiArIG5hbWUgOiBcIlwiKSk7XG4gIGUuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgZS5pbm5lclRleHQgPSBuYW1lIHx8IG5hbWUgPT09IDAgPyB0eXBlICsgXCItXCIgKyBuYW1lIDogdHlwZTtcbiAgcGFyZW50LmNoaWxkcmVuWzBdID8gcGFyZW50Lmluc2VydEJlZm9yZShlLCBwYXJlbnQuY2hpbGRyZW5bMF0pIDogcGFyZW50LmFwcGVuZENoaWxkKGUpO1xuICBlLl9vZmZzZXQgPSBlW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuXG4gIF9wb3NpdGlvbk1hcmtlcihlLCAwLCBkaXJlY3Rpb24sIGlzU3RhcnQpO1xuXG4gIHJldHVybiBlO1xufSxcbiAgICBfcG9zaXRpb25NYXJrZXIgPSBmdW5jdGlvbiBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBzdGFydCwgZGlyZWN0aW9uLCBmbGlwcGVkKSB7XG4gIHZhciB2YXJzID0ge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICB9LFxuICAgICAgc2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJvczJcIiA6IFwicDJcIl0sXG4gICAgICBvcHBvc2l0ZVNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwicDJcIiA6IFwib3MyXCJdO1xuICBtYXJrZXIuX2lzRmxpcHBlZCA9IGZsaXBwZWQ7XG4gIHZhcnNbZGlyZWN0aW9uLmEgKyBcIlBlcmNlbnRcIl0gPSBmbGlwcGVkID8gLTEwMCA6IDA7XG4gIHZhcnNbZGlyZWN0aW9uLmFdID0gZmxpcHBlZCA/IFwiMXB4XCIgOiAwO1xuICB2YXJzW1wiYm9yZGVyXCIgKyBzaWRlICsgX1dpZHRoXSA9IDE7XG4gIHZhcnNbXCJib3JkZXJcIiArIG9wcG9zaXRlU2lkZSArIF9XaWR0aF0gPSAwO1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IHN0YXJ0ICsgXCJweFwiO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICBfdHJpZ2dlcnMgPSBbXSxcbiAgICBfaWRzID0ge30sXG4gICAgX3JhZklELFxuICAgIF9zeW5jID0gZnVuY3Rpb24gX3N5bmMoKSB7XG4gIHJldHVybiBfZ2V0VGltZSgpIC0gX2xhc3RTY3JvbGxUaW1lID4gMzQgJiYgX3VwZGF0ZUFsbCgpO1xufSxcbiAgICBfb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gIC8vIHByZXZpb3VzbHksIHdlIHRyaWVkIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGJ5IGJhdGNoaW5nL2RlZmVycmluZyB0byB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSwgYnV0IGRpc2NvdmVyZWQgdGhhdCBTYWZhcmkgaGFzIGEgZmV3IGJ1Z3MgdGhhdCBtYWtlIHRoaXMgdW53b3JrYWJsZSAoZXNwZWNpYWxseSBvbiBpT1MpLiBTZWUgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMTZjNDM1YjEyZWYwOWMzODEyNTIwNDgxOGU3YjQ1ZmM/ZWRpdG9ycz0wMDEwIGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9Kak94WXBRLzNkZDY1Y2NlYzVhNjBmMWQ4NjJjMzU1ZDg0ZDE0NTYyP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vRXhiclBOYS8wODdjZWYxOTdkYzM1NDQ1YTA5NTFlODkzNWM0MTUwMz9lZGl0b3JzPTAwMTBcbiAgaWYgKCFfbm9ybWFsaXplciB8fCAhX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9ub3JtYWxpemVyLnN0YXJ0WCA+IF9ib2R5LmNsaWVudFdpZHRoKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIHNjcm9sbGJhciwgYWxsb3cgaXQuXG4gICAgX3Njcm9sbGVycy5jYWNoZSsrO1xuICAgIF9yYWZJRCB8fCAoX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF91cGRhdGVBbGwpKTtcbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgX2xhc3RTY3JvbGxUaW1lID0gX2dldFRpbWUoKTtcbiAgfVxufSxcbiAgICBfc2V0QmFzZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBfc2V0QmFzZURpbWVuc2lvbnMoKSB7XG4gIF9iYXNlU2NyZWVuV2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gIF9iYXNlU2NyZWVuSGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcbn0sXG4gICAgX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICFfcmVmcmVzaGluZyAmJiAhX2lnbm9yZVJlc2l6ZSAmJiAhX2RvYy5mdWxsc2NyZWVuRWxlbWVudCAmJiAhX2RvYy53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCAmJiAoIV9pZ25vcmVNb2JpbGVSZXNpemUgfHwgX2Jhc2VTY3JlZW5XaWR0aCAhPT0gX3dpbi5pbm5lcldpZHRoIHx8IE1hdGguYWJzKF93aW4uaW5uZXJIZWlnaHQgLSBfYmFzZVNjcmVlbkhlaWdodCkgPiBfd2luLmlubmVySGVpZ2h0ICogMC4yNSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9zb2Z0UmVmcmVzaCA9IGZ1bmN0aW9uIF9zb2Z0UmVmcmVzaCgpIHtcbiAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpO1xufSxcbiAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVyc1t0eXBlXSAmJiBfbGlzdGVuZXJzW3R5cGVdLm1hcChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKCk7XG4gIH0pIHx8IF9lbXB0eUFycmF5O1xufSxcbiAgICBfc2F2ZWRTdHlsZXMgPSBbXSxcbiAgICAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cbl9yZXZlcnRSZWNvcmRlZCA9IGZ1bmN0aW9uIF9yZXZlcnRSZWNvcmRlZChtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9zYXZlZFN0eWxlcy5sZW5ndGg7IGkgKz0gNSkge1xuICAgIGlmICghbWVkaWEgfHwgX3NhdmVkU3R5bGVzW2kgKyA0XSAmJiBfc2F2ZWRTdHlsZXNbaSArIDRdLnF1ZXJ5ID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKHRyaWdnZXIgJiYgKCFtZWRpYSB8fCB0cmlnZ2VyLl9jdHggPT09IG1lZGlhKSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbWVkaWEgJiYgX3JldmVydFJlY29yZGVkKG1lZGlhKTtcbiAgbWVkaWEgfHwgX2Rpc3BhdGNoKFwicmV2ZXJ0XCIpO1xufSxcbiAgICBfY2xlYXJTY3JvbGxNZW1vcnkgPSBmdW5jdGlvbiBfY2xlYXJTY3JvbGxNZW1vcnkoc2Nyb2xsUmVzdG9yYXRpb24sIGZvcmNlKSB7XG4gIC8vIHplcm8tb3V0IGFsbCB0aGUgcmVjb3JkZWQgc2Nyb2xsIHBvc2l0aW9ucy4gRG9uJ3QgdXNlIF90cmlnZ2VycyBiZWNhdXNlIGlmLCBmb3IgZXhhbXBsZSwgLm1hdGNoTWVkaWEoKSBpcyB1c2VkIHRvIGNyZWF0ZSBzb21lIFNjcm9sbFRyaWdnZXJzIGFuZCB0aGVuIHRoZSB1c2VyIHJlc2l6ZXMgYW5kIGl0IHJlbW92ZXMgQUxMIFNjcm9sbFRyaWdnZXJzLCBhbmQgdGhlbiBnbyBiYWNrIHRvIGEgc2l6ZSB3aGVyZSB0aGVyZSBhcmUgU2Nyb2xsVHJpZ2dlcnMsIGl0IHdvdWxkIGhhdmUga2VwdCB0aGUgcG9zaXRpb24ocykgc2F2ZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgX3Njcm9sbGVycy5jYWNoZSsrO1xuICAoZm9yY2UgfHwgIV9yZWZyZXNoaW5nQWxsKSAmJiBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBfaXNGdW5jdGlvbihvYmopICYmIG9iai5jYWNoZUlEKysgJiYgKG9iai5yZWMgPSAwKTtcbiAgfSk7XG4gIF9pc1N0cmluZyhzY3JvbGxSZXN0b3JhdGlvbikgJiYgKF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IF9zY3JvbGxSZXN0b3JhdGlvbiA9IHNjcm9sbFJlc3RvcmF0aW9uKTtcbn0sXG4gICAgX3JlZnJlc2hpbmdBbGwsXG4gICAgX3JlZnJlc2hJRCA9IDAsXG4gICAgX3JlZnJlc2hBbGwgPSBmdW5jdGlvbiBfcmVmcmVzaEFsbChmb3JjZSwgc2tpcFJldmVydCkge1xuICBpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFmb3JjZSkge1xuICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX3JlZnJlc2hpbmdBbGwgPSBTY3JvbGxUcmlnZ2VyLmlzUmVmcmVzaGluZyA9IHRydWU7XG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gX2lzRnVuY3Rpb24ob2JqKSAmJiBvYmouY2FjaGVJRCsrICYmIChvYmoucmVjID0gb2JqKCkpO1xuICB9KTsgLy8gZm9yY2UgdGhlIGNsZWFyaW5nIG9mIHRoZSBjYWNoZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGFrZSBhIGxpdHRsZSB3aGlsZSB0byBkaXNwYXRjaCB0aGUgXCJzY3JvbGxcIiBldmVudCBhbmQgdGhlIHVzZXIgbWF5IGhhdmUgY2hhbmdlZCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGVuIGNhbGxlZCBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSByaWdodCBhd2F5XG5cblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIG9iai5zbW9vdGggJiYgKG9iai50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIik7IC8vIHNtb290aCBzY3JvbGxpbmcgaW50ZXJmZXJlc1xuXG4gICAgICBvYmooMCk7XG4gICAgfVxuICB9KTtcblxuICBfdHJpZ2dlcnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnJlZnJlc2goKTtcbiAgfSk7IC8vIGRvbid0IGxvb3Agd2l0aCBfaSBiZWNhdXNlIGR1cmluZyBhIHJlZnJlc2goKSBzb21lb25lIGNvdWxkIGNhbGwgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKSB3aGljaCB3b3VsZCBpdGVyYXRlIHRocm91Z2ggX2kgcmVzdWx0aW5nIGluIGEgc2tpcC5cblxuXG4gIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudmFycy5lbmQgPT09IFwibWF4XCIgJiYgdC5zZXRQb3NpdGlvbnModC5zdGFydCwgTWF0aC5tYXgodC5zdGFydCArIDEsIF9tYXhTY3JvbGwodC5zY3JvbGxlciwgdC5fZGlyKSkpO1xuICB9KTsgLy8gdGhlIHNjcm9sbGVyJ3MgbWF4IHNjcm9sbCBwb3NpdGlvbiBtYXkgY2hhbmdlIGFmdGVyIGFsbCB0aGUgU2Nyb2xsVHJpZ2dlcnMgcmVmcmVzaGVkIChsaWtlIHBpbm5pbmcgY291bGQgcHVzaCBpdCBkb3duKSwgc28gd2UgbmVlZCB0byBsb29wIGJhY2sgYW5kIGNvcnJlY3QgYW55IHdpdGggZW5kOiBcIm1heFwiLlxuXG5cbiAgcmVmcmVzaEluaXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0LnJlbmRlciAmJiByZXN1bHQucmVuZGVyKC0xKTtcbiAgfSk7IC8vIGlmIHRoZSBvblJlZnJlc2hJbml0KCkgcmV0dXJucyBhbiBhbmltYXRpb24gKHR5cGljYWxseSBhIGdzYXAuc2V0KCkpLCByZXZlcnQgaXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBwdXQgdGhpbmdzIGluIGEgY2VydGFpbiBzcG90IGJlZm9yZSByZWZyZXNoaW5nIGZvciBtZWFzdXJlbWVudCBwdXJwb3NlcywgYW5kIHRoZW4gcHV0IHRoaW5ncyBiYWNrLlxuXG4gIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIG9iai5zbW9vdGggJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iai50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcInNtb290aFwiO1xuICAgICAgfSk7XG4gICAgICBvYmoucmVjICYmIG9iaihvYmoucmVjKTtcbiAgICB9XG4gIH0pO1xuXG4gIF9jbGVhclNjcm9sbE1lbW9yeShfc2Nyb2xsUmVzdG9yYXRpb24sIDEpO1xuXG4gIF9yZXNpemVEZWxheS5wYXVzZSgpO1xuXG4gIF9yZWZyZXNoSUQrKztcblxuICBfdXBkYXRlQWxsKDIpO1xuXG4gIF9yZWZyZXNoaW5nQWxsID0gU2Nyb2xsVHJpZ2dlci5pc1JlZnJlc2hpbmcgPSBmYWxzZTtcblxuICBfZGlzcGF0Y2goXCJyZWZyZXNoXCIpO1xufSxcbiAgICBfbGFzdFNjcm9sbCA9IDAsXG4gICAgX2RpcmVjdGlvbiA9IDEsXG4gICAgX3ByaW1hcnksXG4gICAgX3VwZGF0ZUFsbCA9IGZ1bmN0aW9uIF91cGRhdGVBbGwoZm9yY2UpIHtcbiAgaWYgKCFfcmVmcmVzaGluZ0FsbCB8fCBmb3JjZSA9PT0gMikge1xuICAgIFNjcm9sbFRyaWdnZXIuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgX3ByaW1hcnkgJiYgX3ByaW1hcnkudXBkYXRlKDApOyAvLyBTY3JvbGxTbW9vdGhlciB1c2VycyByZWZyZXNoUHJpb3JpdHkgLTk5OTkgdG8gYmVjb21lIHRoZSBwcmltYXJ5IHRoYXQgZ2V0cyB1cGRhdGVkIGJlZm9yZSBhbGwgb3RoZXJzIGJlY2F1c2UgaXQgYWZmZWN0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuXG4gICAgdmFyIGwgPSBfdHJpZ2dlcnMubGVuZ3RoLFxuICAgICAgICB0aW1lID0gX2dldFRpbWUoKSxcbiAgICAgICAgcmVjb3JkVmVsb2NpdHkgPSB0aW1lIC0gX3RpbWUxID49IDUwLFxuICAgICAgICBzY3JvbGwgPSBsICYmIF90cmlnZ2Vyc1swXS5zY3JvbGwoKTtcblxuICAgIF9kaXJlY3Rpb24gPSBfbGFzdFNjcm9sbCA+IHNjcm9sbCA/IC0xIDogMTtcbiAgICBfbGFzdFNjcm9sbCA9IHNjcm9sbDtcblxuICAgIGlmIChyZWNvcmRWZWxvY2l0eSkge1xuICAgICAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgdGltZSAtIF9sYXN0U2Nyb2xsVGltZSA+IDIwMCkge1xuICAgICAgICBfbGFzdFNjcm9sbFRpbWUgPSAwO1xuXG4gICAgICAgIF9kaXNwYXRjaChcInNjcm9sbEVuZFwiKTtcbiAgICAgIH1cblxuICAgICAgX3RpbWUyID0gX3RpbWUxO1xuICAgICAgX3RpbWUxID0gdGltZTtcbiAgICB9XG5cbiAgICBpZiAoX2RpcmVjdGlvbiA8IDApIHtcbiAgICAgIF9pID0gbDtcblxuICAgICAgd2hpbGUgKF9pLS0gPiAwKSB7XG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuICAgICAgfVxuXG4gICAgICBfZGlyZWN0aW9uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgbDsgX2krKykge1xuICAgICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIF9yYWZJRCA9IDA7XG59LFxuICAgIF9wcm9wTmFtZXNUb0NvcHkgPSBbX2xlZnQsIF90b3AsIF9ib3R0b20sIF9yaWdodCwgX21hcmdpbiArIF9Cb3R0b20sIF9tYXJnaW4gKyBfUmlnaHQsIF9tYXJnaW4gKyBfVG9wLCBfbWFyZ2luICsgX0xlZnQsIFwiZGlzcGxheVwiLCBcImZsZXhTaHJpbmtcIiwgXCJmbG9hdFwiLCBcInpJbmRleFwiLCBcImdyaWRDb2x1bW5TdGFydFwiLCBcImdyaWRDb2x1bW5FbmRcIiwgXCJncmlkUm93U3RhcnRcIiwgXCJncmlkUm93RW5kXCIsIFwiZ3JpZEFyZWFcIiwgXCJqdXN0aWZ5U2VsZlwiLCBcImFsaWduU2VsZlwiLCBcInBsYWNlU2VsZlwiLCBcIm9yZGVyXCJdLFxuICAgIF9zdGF0ZVByb3BzID0gX3Byb3BOYW1lc1RvQ29weS5jb25jYXQoW193aWR0aCwgX2hlaWdodCwgXCJib3hTaXppbmdcIiwgXCJtYXhcIiArIF9XaWR0aCwgXCJtYXhcIiArIF9IZWlnaHQsIFwicG9zaXRpb25cIiwgX21hcmdpbiwgX3BhZGRpbmcsIF9wYWRkaW5nICsgX1RvcCwgX3BhZGRpbmcgKyBfUmlnaHQsIF9wYWRkaW5nICsgX0JvdHRvbSwgX3BhZGRpbmcgKyBfTGVmdF0pLFxuICAgIF9zd2FwUGluT3V0ID0gZnVuY3Rpb24gX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHN0YXRlKSB7XG4gIF9zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgdmFyIGNhY2hlID0gcGluLl9nc2FwO1xuXG4gIGlmIChjYWNoZS5zcGFjZXJJc05hdGl2ZSkge1xuICAgIF9zZXRTdGF0ZShjYWNoZS5zcGFjZXJTdGF0ZSk7XG4gIH0gZWxzZSBpZiAocGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBwYXJlbnQgPSBzcGFjZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUocGluLCBzcGFjZXIpO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XG4gICAgfVxuICB9XG5cbiAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IGZhbHNlO1xufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmICghcGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBpID0gX3Byb3BOYW1lc1RvQ29weS5sZW5ndGgsXG4gICAgICAgIHNwYWNlclN0eWxlID0gc3BhY2VyLnN0eWxlLFxuICAgICAgICBwaW5TdHlsZSA9IHBpbi5zdHlsZSxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHAgPSBfcHJvcE5hbWVzVG9Db3B5W2ldO1xuICAgICAgc3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcbiAgICB9XG5cbiAgICBzcGFjZXJTdHlsZS5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIgPyBcImFic29sdXRlXCIgOiBcInJlbGF0aXZlXCI7XG4gICAgY3MuZGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuICAgIHBpblN0eWxlW19ib3R0b21dID0gcGluU3R5bGVbX3JpZ2h0XSA9IFwiYXV0b1wiO1xuICAgIHNwYWNlclN0eWxlLmZsZXhCYXNpcyA9IGNzLmZsZXhCYXNpcyB8fCBcImF1dG9cIjtcbiAgICBzcGFjZXJTdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICAgIHNwYWNlclN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgIHNwYWNlclN0eWxlW193aWR0aF0gPSBfZ2V0U2l6ZShwaW4sIF9ob3Jpem9udGFsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfaGVpZ2h0XSA9IF9nZXRTaXplKHBpbiwgX3ZlcnRpY2FsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfcGFkZGluZ10gPSBwaW5TdHlsZVtfbWFyZ2luXSA9IHBpblN0eWxlW190b3BdID0gcGluU3R5bGVbX2xlZnRdID0gXCIwXCI7XG5cbiAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgcGluU3R5bGVbX3dpZHRoXSA9IHBpblN0eWxlW1wibWF4XCIgKyBfV2lkdGhdID0gY3NbX3dpZHRoXTtcbiAgICBwaW5TdHlsZVtfaGVpZ2h0XSA9IHBpblN0eWxlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IGNzW19oZWlnaHRdO1xuICAgIHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblxuICAgIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgICBwaW4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BhY2VyLCBwaW4pO1xuICAgICAgc3BhY2VyLmFwcGVuZENoaWxkKHBpbik7XG4gICAgfVxuXG4gICAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IHRydWU7XG4gIH1cbn0sXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9zZXRTdGF0ZSA9IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50LnN0eWxlLFxuICAgICAgICBsID0gc3RhdGUubGVuZ3RoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcCxcbiAgICAgICAgdmFsdWU7XG4gICAgKHN0YXRlLnQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHN0YXRlLnQpKS51bmNhY2hlID0gMTsgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybXMgbWF5IGJlIG9mZlxuXG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGVbaSArIDFdO1xuICAgICAgcCA9IHN0YXRlW2ldO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVbcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVbcF0pIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0YXRlID0gZnVuY3Rpb24gX2dldFN0YXRlKGVsZW1lbnQpIHtcbiAgLy8gcmV0dXJucyBhbiBBcnJheSB3aXRoIGFsdGVybmF0aW5nIHZhbHVlcyBsaWtlIFtwcm9wZXJ0eSwgdmFsdWUsIHByb3BlcnR5LCB2YWx1ZV0gYW5kIGEgXCJ0XCIgcHJvcGVydHkgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCAoZWxlbWVudCkuIE1ha2VzIGl0IGZhc3QgYW5kIGNoZWFwLlxuICB2YXIgbCA9IF9zdGF0ZVByb3BzLmxlbmd0aCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIHN0YXRlID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG4gIH1cblxuICBzdGF0ZS50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHN0YXRlO1xufSxcbiAgICBfY29weVN0YXRlID0gZnVuY3Rpb24gX2NvcHlTdGF0ZShzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpID0gb21pdE9mZnNldHMgPyA4IDogMCxcbiAgICAgIC8vIHNraXAgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIGlmIG9taXRPZmZzZXRzIGlzIHRydWVcbiAgcDtcblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHAgPSBzdGF0ZVtpXTtcbiAgICByZXN1bHQucHVzaChwLCBwIGluIG92ZXJyaWRlID8gb3ZlcnJpZGVbcF0gOiBzdGF0ZVtpICsgMV0pO1xuICB9XG5cbiAgcmVzdWx0LnQgPSBzdGF0ZS50O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfd2luT2Zmc2V0cyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiAwXG59LFxuICAgIC8vIC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAoPykgQWxsb3cgdXNlcnMgdG8gY2FsY3VsYXRlIHdoZXJlIGEgdHJpZ2dlciBoaXRzIChzY3JvbGwgcG9zaXRpb24pIGxpa2UgZ2V0U2Nyb2xsUG9zaXRpb24oXCIjaWRcIiwgXCJ0b3AgYm90dG9tXCIpXG4vLyBfZ2V0U2Nyb2xsUG9zaXRpb24gPSAodHJpZ2dlciwgcG9zaXRpb24sIHtzY3JvbGxlciwgY29udGFpbmVyQW5pbWF0aW9uLCBob3Jpem9udGFsfSkgPT4ge1xuLy8gXHRzY3JvbGxlciA9IF9nZXRUYXJnZXQoc2Nyb2xsZXIgfHwgX3dpbik7XG4vLyBcdGxldCBkaXJlY3Rpb24gPSBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4vLyBcdFx0aXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKTtcbi8vIFx0X2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pO1xuLy8gXHRyZXR1cm4gX3BhcnNlUG9zaXRpb24ocG9zaXRpb24sIF9nZXRUYXJnZXQodHJpZ2dlciksIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSgpLCBkaXJlY3Rpb24sIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pKCksIDAsIDAsIDAsIF9nZXRPZmZzZXRzRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCkoKSwgaXNWaWV3cG9ydCA/IDAgOiBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVtcImJvcmRlclwiICsgZGlyZWN0aW9uLnAyICsgX1dpZHRoXSkgfHwgMCwgMCwgY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyKSwgY29udGFpbmVyQW5pbWF0aW9uKTtcbi8vIH0sXG5fcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4LCBjb250YWluZXJBbmltYXRpb24pIHtcbiAgX2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwibWF4XCIpIHtcbiAgICB2YWx1ZSA9IHNjcm9sbGVyTWF4ICsgKHZhbHVlLmNoYXJBdCg0KSA9PT0gXCI9XCIgPyBfb2Zmc2V0VG9QeChcIjBcIiArIHZhbHVlLnN1YnN0cigzKSwgc2Nyb2xsZXJTaXplKSA6IDApO1xuICB9XG5cbiAgdmFyIHRpbWUgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZSgpIDogMCxcbiAgICAgIHAxLFxuICAgICAgcDIsXG4gICAgICBlbGVtZW50O1xuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoMCk7XG5cbiAgaWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgX2lzRnVuY3Rpb24odHJpZ2dlcikgJiYgKHRyaWdnZXIgPSB0cmlnZ2VyKHNlbGYpKTtcbiAgICB2YXIgb2Zmc2V0cyA9ICh2YWx1ZSB8fCBcIjBcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlcikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSBpZiAobWFya2VyU2Nyb2xsZXIpIHtcbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChtYXJrZXIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB2YWx1ZSArIHNjcm9sbGVyU2l6ZSxcbiAgICAgICAgaXNTdGFydCA9IG1hcmtlci5faXNTdGFydDtcbiAgICBwMSA9IFwic2Nyb2xsXCIgKyBkaXJlY3Rpb24uZDI7XG5cbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBwb3NpdGlvbiwgZGlyZWN0aW9uLCBpc1N0YXJ0ICYmIHBvc2l0aW9uID4gMjAgfHwgIWlzU3RhcnQgJiYgKHVzZUZpeGVkUG9zaXRpb24gPyBNYXRoLm1heChfYm9keVtwMV0sIF9kb2NFbFtwMV0pIDogbWFya2VyLnBhcmVudE5vZGVbcDFdKSA8PSBwb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgIHNjcm9sbGVyQm91bmRzID0gX2dldEJvdW5kcyhtYXJrZXJTY3JvbGxlcik7XG4gICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIChtYXJrZXIuc3R5bGVbZGlyZWN0aW9uLm9wLnBdID0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLm9wLnBdIC0gZGlyZWN0aW9uLm9wLm0gLSBtYXJrZXIuX29mZnNldCArIF9weCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiBlbGVtZW50KSB7XG4gICAgcDEgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKHNjcm9sbGVyTWF4KTtcbiAgICBwMiA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgPSBwMVtkaXJlY3Rpb24ucF0gLSBwMltkaXJlY3Rpb24ucF07XG4gICAgdmFsdWUgPSB2YWx1ZSAvIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ICogc2Nyb2xsZXJNYXg7XG4gIH1cblxuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsodGltZSk7XG4gIHJldHVybiBjb250YWluZXJBbmltYXRpb24gPyB2YWx1ZSA6IE1hdGgucm91bmQodmFsdWUpO1xufSxcbiAgICBfcHJlZml4RXhwID0gLyh3ZWJraXR8bW96fGxlbmd0aHxjc3NUZXh0fGluc2V0KS9pLFxuICAgIF9yZXBhcmVudCA9IGZ1bmN0aW9uIF9yZXBhcmVudChlbGVtZW50LCBwYXJlbnQsIHRvcCwgbGVmdCkge1xuICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgICBwLFxuICAgICAgICBjcztcblxuICAgIGlmIChwYXJlbnQgPT09IF9ib2R5KSB7XG4gICAgICBlbGVtZW50Ll9zdE9yaWcgPSBzdHlsZS5jc3NUZXh0OyAvLyByZWNvcmQgb3JpZ2luYWwgaW5saW5lIHN0eWxlcyBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZW0gbGF0ZXJcblxuICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgICAgZm9yIChwIGluIGNzKSB7XG4gICAgICAgIC8vIG11c3QgY29weSBhbGwgcmVsZXZhbnQgc3R5bGVzIHRvIGVuc3VyZSB0aGF0IG5vdGhpbmcgY2hhbmdlcyB2aXN1YWxseSB3aGVuIHdlIHJlcGFyZW50IHRvIHRoZSA8Ym9keT4uIFNraXAgdGhlIHZlbmRvciBwcmVmaXhlZCBvbmVzLlxuICAgICAgICBpZiAoIStwICYmICFfcHJlZml4RXhwLnRlc3QocCkgJiYgY3NbcF0gJiYgdHlwZW9mIHN0eWxlW3BdID09PSBcInN0cmluZ1wiICYmIHAgIT09IFwiMFwiKSB7XG4gICAgICAgICAgc3R5bGVbcF0gPSBjc1twXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHlsZS50b3AgPSB0b3A7XG4gICAgICBzdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuY3NzVGV4dCA9IGVsZW1lbnQuX3N0T3JpZztcbiAgICB9XG5cbiAgICBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCkudW5jYWNoZSA9IDE7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIC8vIF9tZXJnZUFuaW1hdGlvbnMgPSBhbmltYXRpb25zID0+IHtcbi8vIFx0bGV0IHRsID0gZ3NhcC50aW1lbGluZSh7c21vb3RoQ2hpbGRUaW1pbmc6IHRydWV9KS5zdGFydFRpbWUoTWF0aC5taW4oLi4uYW5pbWF0aW9ucy5tYXAoYSA9PiBhLmdsb2JhbFRpbWUoMCkpKSk7XG4vLyBcdGFuaW1hdGlvbnMuZm9yRWFjaChhID0+IHtsZXQgdGltZSA9IGEudG90YWxUaW1lKCk7IHRsLmFkZChhKTsgYS50b3RhbFRpbWUodGltZSk7IH0pO1xuLy8gXHR0bC5zbW9vdGhDaGlsZFRpbWluZyA9IGZhbHNlO1xuLy8gXHRyZXR1cm4gdGw7XG4vLyB9LFxuLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHByb3ZpZGVkLCBhbmQgd2hlbiBkb2luZyBzbyBpdCdsbCBhZGQgYSAudHdlZW4gcHJvcGVydHkgdG8gdGhlIEZVTkNUSU9OIGl0c2VsZiwgYW5kIHJlbW92ZSBpdCB3aGVuIHRoZSB0d2VlbiBjb21wbGV0ZXMgb3IgZ2V0cyBraWxsZWQuIFRoaXMgZ2l2ZXMgdXMgYSB3YXkgdG8gaGF2ZSBtdWx0aXBsZSBTY3JvbGxUcmlnZ2VycyB1c2UgYSBjZW50cmFsIGZ1bmN0aW9uIGZvciBhbnkgZ2l2ZW4gc2Nyb2xsZXIgYW5kIHNlZSBpZiB0aGVyZSdzIGEgc2Nyb2xsIHR3ZWVuIHJ1bm5pbmcgKHdoaWNoIHdvdWxkIGFmZmVjdCBpZi9ob3cgdGhpbmdzIGdldCB1cGRhdGVkKVxuX2dldFR3ZWVuQ3JlYXRvciA9IGZ1bmN0aW9uIF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIGRpcmVjdGlvbikge1xuICB2YXIgZ2V0U2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICBwcm9wID0gXCJfc2Nyb2xsXCIgKyBkaXJlY3Rpb24ucDIsXG4gICAgICAvLyBhZGQgYSB0d2VlbmFibGUgcHJvcGVydHkgdG8gdGhlIHNjcm9sbGVyIHRoYXQncyBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24sIGxpa2UgX3Njcm9sbFRvcCBvciBfc2Nyb2xsTGVmdC4gVGhpcyB3YXksIGlmIHNvbWVvbmUgZG9lcyBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxlcikgaXQnbGwga2lsbCB0aGUgc2Nyb2xsIHR3ZWVuLlxuICBsYXN0U2Nyb2xsMSxcbiAgICAgIGxhc3RTY3JvbGwyLFxuICAgICAgZ2V0VHdlZW4gPSBmdW5jdGlvbiBnZXRUd2VlbihzY3JvbGxUbywgdmFycywgaW5pdGlhbFZhbHVlLCBjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4sXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXG4gICAgICAgIG1vZGlmaWVycyA9IHt9O1xuICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSB8fCBnZXRTY3JvbGwoKTtcbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxuXG4gICAgY2hhbmdlMSA9IGNoYW5nZTEgfHwgc2Nyb2xsVG8gLSBpbml0aWFsVmFsdWU7XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZChpbml0aWFsVmFsdWUpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKGdldFNjcm9sbCgpKTsgLy8gcm91bmQgYmVjYXVzZSBpbiBzb21lIFt2ZXJ5IHVuY29tbW9uXSBXaW5kb3dzIGVudmlyb25tZW50cywgaXQgY2FuIGdldCByZXBvcnRlZCB3aXRoIGRlY2ltYWxzIGV2ZW4gdGhvdWdoIGl0IHdhcyBzZXQgd2l0aG91dC5cblxuICAgICAgaWYgKHZhbHVlICE9PSBsYXN0U2Nyb2xsMSAmJiB2YWx1ZSAhPT0gbGFzdFNjcm9sbDIgJiYgTWF0aC5hYnModmFsdWUgLSBsYXN0U2Nyb2xsMSkgPiAzICYmIE1hdGguYWJzKHZhbHVlIC0gbGFzdFNjcm9sbDIpID4gMykge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBzY3JvbGxzLCBraWxsIHRoZSB0d2Vlbi4gaU9TIFNhZmFyaSBpbnRlcm1pdHRlbnRseSBtaXNyZXBvcnRzIHRoZSBzY3JvbGwgcG9zaXRpb24sIGl0IG1heSBiZSB0aGUgbW9zdCByZWNlbnRseS1zZXQgb25lIG9yIHRoZSBvbmUgYmVmb3JlIHRoYXQhIFdoZW4gU2FmYXJpIGlzIHpvb21lZCAoQ01ELSspLCBpdCBvZnRlbiBtaXNyZXBvcnRzIGFzIDEgcGl4ZWwgb2ZmIHRvbyEgU28gaWYgd2Ugc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gMTI1LCBmb3IgZXhhbXBsZSwgaXQnbGwgYWN0dWFsbHkgcmVwb3J0IGl0IGFzIDEyNC5cbiAgICAgICAgdHdlZW4ua2lsbCgpO1xuICAgICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGluaXRpYWxWYWx1ZSArIGNoYW5nZTEgKiB0d2Vlbi5yYXRpbyArIGNoYW5nZTIgKiB0d2Vlbi5yYXRpbyAqIHR3ZWVuLnJhdGlvO1xuICAgICAgfVxuXG4gICAgICBsYXN0U2Nyb2xsMiA9IGxhc3RTY3JvbGwxO1xuICAgICAgcmV0dXJuIGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhcnMub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZS5jYWxsKHR3ZWVuKTtcbiAgICB9O1xuXG4gICAgdHdlZW4gPSBnZXRUd2Vlbi50d2VlbiA9IGdzYXAudG8oc2Nyb2xsZXIsIHZhcnMpO1xuICAgIHJldHVybiB0d2VlbjtcbiAgfTtcblxuICBzY3JvbGxlcltwcm9wXSA9IGdldFNjcm9sbDtcblxuICBnZXRTY3JvbGwud2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRUd2Vlbi50d2VlbiAmJiBnZXRUd2Vlbi50d2Vlbi5raWxsKCkgJiYgKGdldFR3ZWVuLnR3ZWVuID0gMCk7XG4gIH07XG5cbiAgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcIndoZWVsXCIsIGdldFNjcm9sbC53aGVlbEhhbmRsZXIpOyAvLyBXaW5kb3dzIG1hY2hpbmVzIGhhbmRsZSBtb3VzZXdoZWVsIHNjcm9sbGluZyBpbiBjaHVua3MgKGxpa2UgXCIzIGxpbmVzIHBlciBzY3JvbGxcIikgbWVhbmluZyB0aGUgdHlwaWNhbCBzdHJhdGVneSBmb3IgY2FuY2VsbGluZyB0aGUgc2Nyb2xsIGlzbid0IGFzIHNlbnNpdGl2ZS4gSXQncyBtdWNoIG1vcmUgbGlrZWx5IHRvIG1hdGNoIG9uZSBvZiB0aGUgcHJldmlvdXMgMiBzY3JvbGwgZXZlbnQgcG9zaXRpb25zLiBTbyB3ZSBraWxsIGFueSBzbmFwcGluZyBhcyBzb29uIGFzIHRoZXJlJ3MgYSB3aGVlbCBldmVudC5cblxuXG4gIHJldHVybiBnZXRUd2Vlbjtcbn07XG5cbmV4cG9ydCB2YXIgU2Nyb2xsVHJpZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjcm9sbFRyaWdnZXIodmFycywgYW5pbWF0aW9uKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIoZ3NhcCkgfHwgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcilcIik7XG4gICAgdGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsVHJpZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnZhcnMgJiYgdGhpcy5raWxsKHRydWUsIHRydWUpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXG4gICAgaWYgKCFfZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnJlZnJlc2ggPSB0aGlzLmtpbGwgPSBfcGFzc1Rocm91Z2g7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFycyA9IF9zZXREZWZhdWx0cyhfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUgPyB7XG4gICAgICB0cmlnZ2VyOiB2YXJzXG4gICAgfSA6IHZhcnMsIF9kZWZhdWx0cyk7XG5cbiAgICB2YXIgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBvblVwZGF0ZSA9IF92YXJzLm9uVXBkYXRlLFxuICAgICAgICB0b2dnbGVDbGFzcyA9IF92YXJzLnRvZ2dsZUNsYXNzLFxuICAgICAgICBpZCA9IF92YXJzLmlkLFxuICAgICAgICBvblRvZ2dsZSA9IF92YXJzLm9uVG9nZ2xlLFxuICAgICAgICBvblJlZnJlc2ggPSBfdmFycy5vblJlZnJlc2gsXG4gICAgICAgIHNjcnViID0gX3ZhcnMuc2NydWIsXG4gICAgICAgIHRyaWdnZXIgPSBfdmFycy50cmlnZ2VyLFxuICAgICAgICBwaW4gPSBfdmFycy5waW4sXG4gICAgICAgIHBpblNwYWNpbmcgPSBfdmFycy5waW5TcGFjaW5nLFxuICAgICAgICBpbnZhbGlkYXRlT25SZWZyZXNoID0gX3ZhcnMuaW52YWxpZGF0ZU9uUmVmcmVzaCxcbiAgICAgICAgYW50aWNpcGF0ZVBpbiA9IF92YXJzLmFudGljaXBhdGVQaW4sXG4gICAgICAgIG9uU2NydWJDb21wbGV0ZSA9IF92YXJzLm9uU2NydWJDb21wbGV0ZSxcbiAgICAgICAgb25TbmFwQ29tcGxldGUgPSBfdmFycy5vblNuYXBDb21wbGV0ZSxcbiAgICAgICAgb25jZSA9IF92YXJzLm9uY2UsXG4gICAgICAgIHNuYXAgPSBfdmFycy5zbmFwLFxuICAgICAgICBwaW5SZXBhcmVudCA9IF92YXJzLnBpblJlcGFyZW50LFxuICAgICAgICBwaW5TcGFjZXIgPSBfdmFycy5waW5TcGFjZXIsXG4gICAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiA9IF92YXJzLmNvbnRhaW5lckFuaW1hdGlvbixcbiAgICAgICAgZmFzdFNjcm9sbEVuZCA9IF92YXJzLmZhc3RTY3JvbGxFbmQsXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyA9IF92YXJzLnByZXZlbnRPdmVybGFwcyxcbiAgICAgICAgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsIHx8IHZhcnMuY29udGFpbmVyQW5pbWF0aW9uICYmIHZhcnMuaG9yaXpvbnRhbCAhPT0gZmFsc2UgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbiAgICAgICAgaXNUb2dnbGUgPSAhc2NydWIgJiYgc2NydWIgIT09IDAsXG4gICAgICAgIHNjcm9sbGVyID0gX2dldFRhcmdldCh2YXJzLnNjcm9sbGVyIHx8IF93aW4pLFxuICAgICAgICBzY3JvbGxlckNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHNjcm9sbGVyKSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKSxcbiAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiA9IChcInBpblR5cGVcIiBpbiB2YXJzID8gdmFycy5waW5UeXBlIDogX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpIHx8IGlzVmlld3BvcnQgJiYgXCJmaXhlZFwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuICAgICAgICB0b2dnbGVBY3Rpb25zID0gaXNUb2dnbGUgJiYgdmFycy50b2dnbGVBY3Rpb25zLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgbWFya2VycyA9IFwibWFya2Vyc1wiIGluIHZhcnMgPyB2YXJzLm1hcmtlcnMgOiBfZGVmYXVsdHMubWFya2VycyxcbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb25SZWZyZXNoSW5pdCA9IHZhcnMub25SZWZyZXNoSW5pdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFycy5vblJlZnJlc2hJbml0KHNlbGYpO1xuICAgIH0sXG4gICAgICAgIGdldFNjcm9sbGVyU2l6ZSA9IF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcbiAgICAgICAgbGFzdFNuYXAgPSAwLFxuICAgICAgICBsYXN0UmVmcmVzaCA9IDAsXG4gICAgICAgIHNjcm9sbEZ1bmMgPSBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgdHdlZW5UbyxcbiAgICAgICAgcGluQ2FjaGUsXG4gICAgICAgIHNuYXBGdW5jLFxuICAgICAgICBzY3JvbGwxLFxuICAgICAgICBzY3JvbGwyLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBtYXJrZXJTdGFydCxcbiAgICAgICAgbWFya2VyRW5kLFxuICAgICAgICBtYXJrZXJTdGFydFRyaWdnZXIsXG4gICAgICAgIG1hcmtlckVuZFRyaWdnZXIsXG4gICAgICAgIG1hcmtlclZhcnMsXG4gICAgICAgIGNoYW5nZSxcbiAgICAgICAgcGluT3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgcGluQWN0aXZlU3RhdGUsXG4gICAgICAgIHBpblN0YXRlLFxuICAgICAgICBzcGFjZXIsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgcGluR2V0dGVyLFxuICAgICAgICBwaW5TZXR0ZXIsXG4gICAgICAgIHBpblN0YXJ0LFxuICAgICAgICBwaW5DaGFuZ2UsXG4gICAgICAgIHNwYWNpbmdTdGFydCxcbiAgICAgICAgc3BhY2VyU3RhdGUsXG4gICAgICAgIG1hcmtlclN0YXJ0U2V0dGVyLFxuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIsXG4gICAgICAgIGNzLFxuICAgICAgICBzbmFwMSxcbiAgICAgICAgc25hcDIsXG4gICAgICAgIHNjcnViVHdlZW4sXG4gICAgICAgIHNjcnViU21vb3RoLFxuICAgICAgICBzbmFwRHVyQ2xhbXAsXG4gICAgICAgIHNuYXBEZWxheWVkQ2FsbCxcbiAgICAgICAgcHJldlByb2dyZXNzLFxuICAgICAgICBwcmV2U2Nyb2xsLFxuICAgICAgICBwcmV2QW5pbVByb2dyZXNzLFxuICAgICAgICBjYU1hcmtlclNldHRlcixcbiAgICAgICAgY3VzdG9tUmV2ZXJ0UmV0dXJuO1xuXG4gICAgX2NvbnRleHQoc2VsZik7XG5cbiAgICBzZWxmLl9kaXIgPSBkaXJlY3Rpb247XG4gICAgYW50aWNpcGF0ZVBpbiAqPSA0NTtcbiAgICBzZWxmLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG4gICAgc2VsZi5zY3JvbGwgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZS5iaW5kKGNvbnRhaW5lckFuaW1hdGlvbikgOiBzY3JvbGxGdW5jO1xuICAgIHNjcm9sbDEgPSBzY3JvbGxGdW5jKCk7XG4gICAgc2VsZi52YXJzID0gdmFycztcbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24gfHwgdmFycy5hbmltYXRpb247XG5cbiAgICBpZiAoXCJyZWZyZXNoUHJpb3JpdHlcIiBpbiB2YXJzKSB7XG4gICAgICBfc29ydCA9IDE7XG4gICAgICB2YXJzLnJlZnJlc2hQcmlvcml0eSA9PT0gLTk5OTkgJiYgKF9wcmltYXJ5ID0gc2VsZik7IC8vIHVzZWQgYnkgU2Nyb2xsU21vb3RoZXJcbiAgICB9XG5cbiAgICBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCB8fCB7XG4gICAgICB0b3A6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF92ZXJ0aWNhbCksXG4gICAgICBsZWZ0OiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfaG9yaXpvbnRhbClcbiAgICB9O1xuICAgIHNlbGYudHdlZW5UbyA9IHR3ZWVuVG8gPSBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsW2RpcmVjdGlvbi5wXTtcblxuICAgIHNlbGYuc2NydWJEdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc2NydWJTbW9vdGggPSBfaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlO1xuXG4gICAgICBpZiAoIXNjcnViU21vb3RoKSB7XG4gICAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wcm9ncmVzcygxKS5raWxsKCk7XG4gICAgICAgIHNjcnViVHdlZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4uZHVyYXRpb24odmFsdWUpIDogc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7XG4gICAgICAgICAgZWFzZTogXCJleHBvXCIsXG4gICAgICAgICAgdG90YWxQcm9ncmVzczogXCIrPTAuMDAxXCIsXG4gICAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uU2NydWJDb21wbGV0ZSAmJiBvblNjcnViQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uLl9pbml0dGVkIHx8IGFuaW1hdGlvbi52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgdmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIGFuaW1hdGlvbi5kdXJhdGlvbigpICYmIGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBzZWxmLmFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBzZWxmO1xuICAgICAgc2VsZi5zY3J1YkR1cmF0aW9uKHNjcnViKTtcbiAgICAgIHNuYXAxID0gMDtcbiAgICAgIGlkIHx8IChpZCA9IGFuaW1hdGlvbi52YXJzLmlkKTtcbiAgICB9XG5cbiAgICBfdHJpZ2dlcnMucHVzaChzZWxmKTtcblxuICAgIGlmIChzbmFwKSB7XG4gICAgICAvLyBUT0RPOiBwb3RlbnRpYWwgaWRlYTogdXNlIGxlZ2l0aW1hdGUgQ1NTIHNjcm9sbCBzbmFwcGluZyBieSBwdXNoaW5nIGludmlzaWJsZSBlbGVtZW50cyBpbnRvIHRoZSBET00gdGhhdCBzZXJ2ZSBhcyBzbmFwIHBvc2l0aW9ucywgYW5kIHRvZ2dsZSB0aGUgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zdHlsZS5zY3JvbGxTbmFwVHlwZSBvblRvZ2dsZS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0pqTHJnV00gZm9yIGEgcXVpY2sgcHJvb2Ygb2YgY29uY2VwdC5cbiAgICAgIGlmICghX2lzT2JqZWN0KHNuYXApIHx8IHNuYXAucHVzaCkge1xuICAgICAgICBzbmFwID0ge1xuICAgICAgICAgIHNuYXBUbzogc25hcFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBcInNjcm9sbEJlaGF2aW9yXCIgaW4gX2JvZHkuc3R5bGUgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7XG4gICAgICAgIHNjcm9sbEJlaGF2aW9yOiBcImF1dG9cIlxuICAgICAgfSk7IC8vIHNtb290aCBzY3JvbGxpbmcgZG9lc24ndCB3b3JrIHdpdGggc25hcC5cblxuICAgICAgc25hcEZ1bmMgPSBfaXNGdW5jdGlvbihzbmFwLnNuYXBUbykgPyBzbmFwLnNuYXBUbyA6IHNuYXAuc25hcFRvID09PSBcImxhYmVsc1wiID8gX2dldENsb3Nlc3RMYWJlbChhbmltYXRpb24pIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzRGlyZWN0aW9uYWxcIiA/IF9nZXRMYWJlbEF0RGlyZWN0aW9uKGFuaW1hdGlvbikgOiBzbmFwLmRpcmVjdGlvbmFsICE9PSBmYWxzZSA/IGZ1bmN0aW9uICh2YWx1ZSwgc3QpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwRGlyZWN0aW9uYWwoc25hcC5zbmFwVG8pKHZhbHVlLCBfZ2V0VGltZSgpIC0gbGFzdFJlZnJlc2ggPCA1MDAgPyAwIDogc3QuZGlyZWN0aW9uKTtcbiAgICAgIH0gOiBnc2FwLnV0aWxzLnNuYXAoc25hcC5zbmFwVG8pO1xuICAgICAgc25hcER1ckNsYW1wID0gc25hcC5kdXJhdGlvbiB8fCB7XG4gICAgICAgIG1pbjogMC4xLFxuICAgICAgICBtYXg6IDJcbiAgICAgIH07XG4gICAgICBzbmFwRHVyQ2xhbXAgPSBfaXNPYmplY3Qoc25hcER1ckNsYW1wKSA/IF9jbGFtcChzbmFwRHVyQ2xhbXAubWluLCBzbmFwRHVyQ2xhbXAubWF4KSA6IF9jbGFtcChzbmFwRHVyQ2xhbXAsIHNuYXBEdXJDbGFtcCk7XG4gICAgICBzbmFwRGVsYXllZENhbGwgPSBnc2FwLmRlbGF5ZWRDYWxsKHNuYXAuZGVsYXkgfHwgc2NydWJTbW9vdGggLyAyIHx8IDAuMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Nyb2xsID0gc2Nyb2xsRnVuYygpLFxuICAgICAgICAgICAgcmVmcmVzaGVkUmVjZW50bHkgPSBfZ2V0VGltZSgpIC0gbGFzdFJlZnJlc2ggPCA1MDAsXG4gICAgICAgICAgICB0d2VlbiA9IHR3ZWVuVG8udHdlZW47XG5cbiAgICAgICAgaWYgKChyZWZyZXNoZWRSZWNlbnRseSB8fCBNYXRoLmFicyhzZWxmLmdldFZlbG9jaXR5KCkpIDwgMTApICYmICF0d2VlbiAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgbGFzdFNuYXAgIT09IHNjcm9sbCkge1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXG4gICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IHByb2dyZXNzLFxuICAgICAgICAgICAgICB2ZWxvY2l0eSA9IHJlZnJlc2hlZFJlY2VudGx5ID8gMCA6ICh0b3RhbFByb2dyZXNzIC0gc25hcDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogMTAwMCB8fCAwLFxuICAgICAgICAgICAgICBjaGFuZ2UxID0gZ3NhcC51dGlscy5jbGFtcCgtcHJvZ3Jlc3MsIDEgLSBwcm9ncmVzcywgX2Ficyh2ZWxvY2l0eSAvIDIpICogdmVsb2NpdHkgLyAwLjE4NSksXG4gICAgICAgICAgICAgIG5hdHVyYWxFbmQgPSBwcm9ncmVzcyArIChzbmFwLmluZXJ0aWEgPT09IGZhbHNlID8gMCA6IGNoYW5nZTEpLFxuICAgICAgICAgICAgICBlbmRWYWx1ZSA9IF9jbGFtcCgwLCAxLCBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKSksXG4gICAgICAgICAgICAgIGVuZFNjcm9sbCA9IE1hdGgucm91bmQoc3RhcnQgKyBlbmRWYWx1ZSAqIGNoYW5nZSksXG4gICAgICAgICAgICAgIF9zbmFwID0gc25hcCxcbiAgICAgICAgICAgICAgb25TdGFydCA9IF9zbmFwLm9uU3RhcnQsXG4gICAgICAgICAgICAgIF9vbkludGVycnVwdCA9IF9zbmFwLm9uSW50ZXJydXB0LFxuICAgICAgICAgICAgICBfb25Db21wbGV0ZSA9IF9zbmFwLm9uQ29tcGxldGU7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsIDw9IGVuZCAmJiBzY3JvbGwgPj0gc3RhcnQgJiYgZW5kU2Nyb2xsICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICAgIGlmICh0d2VlbiAmJiAhdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uZGF0YSA8PSBfYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCkpIHtcbiAgICAgICAgICAgICAgLy8gdGhlcmUncyBhbiBvdmVybGFwcGluZyBzbmFwISBTbyB3ZSBtdXN0IGZpZ3VyZSBvdXQgd2hpY2ggb25lIGlzIGNsb3NlciBhbmQgbGV0IHRoYXQgdHdlZW4gbGl2ZS5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5pbmVydGlhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBjaGFuZ2UxID0gZW5kVmFsdWUgLSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHdlZW5UbyhlbmRTY3JvbGwsIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKE1hdGgubWF4KF9hYnMobmF0dXJhbEVuZCAtIHRvdGFsUHJvZ3Jlc3MpLCBfYWJzKGVuZFZhbHVlIC0gdG90YWxQcm9ncmVzcykpICogMC4xODUgLyB2ZWxvY2l0eSAvIDAuMDUgfHwgMCkpLFxuICAgICAgICAgICAgICBlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcbiAgICAgICAgICAgICAgZGF0YTogX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpLFxuICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGRpc3RhbmNlIHNvIHRoYXQgaWYgYW5vdGhlciBzbmFwIHR3ZWVuIG9jY3VycyAoY29uZmxpY3QpIHdlIGNhbiBwcmlvcml0aXplIHRoZSBjbG9zZXN0IHNuYXAuXG4gICAgICAgICAgICAgIG9uSW50ZXJydXB0OiBmdW5jdGlvbiBvbkludGVycnVwdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgX29uSW50ZXJydXB0ICYmIF9vbkludGVycnVwdChzZWxmKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuICAgICAgICAgICAgICAgIHNuYXAxID0gc25hcDIgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgb25TbmFwQ29tcGxldGUgJiYgb25TbmFwQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgICAgX29uQ29tcGxldGUgJiYgX29uQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNjcm9sbCwgY2hhbmdlMSAqIGNoYW5nZSwgZW5kU2Nyb2xsIC0gc2Nyb2xsIC0gY2hhbmdlMSAqIGNoYW5nZSk7XG4gICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaXNBY3RpdmUgJiYgbGFzdFNuYXAgIT09IHNjcm9sbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KS5wYXVzZSgpO1xuICAgIH1cblxuICAgIGlkICYmIChfaWRzW2lkXSA9IHNlbGYpO1xuICAgIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXIgPSBfZ2V0VGFyZ2V0KHRyaWdnZXIgfHwgcGluKTsgLy8gaWYgYSB0cmlnZ2VyIGhhcyBzb21lIGtpbmQgb2Ygc2Nyb2xsLXJlbGF0ZWQgZWZmZWN0IGFwcGxpZWQgdGhhdCBjb3VsZCBjb250YW1pbmF0ZSB0aGUgXCJ5XCIgb3IgXCJ4XCIgcG9zaXRpb24gKGxpa2UgYSBTY3JvbGxTbW9vdGhlciBlZmZlY3QpLCB3ZSBuZWVkZWQgYSB3YXkgdG8gdGVtcG9yYXJpbHkgcmV2ZXJ0IGl0LCBzbyB3ZSB1c2UgdGhlIHN0UmV2ZXJ0IHByb3BlcnR5IG9mIHRoZSBnc0NhY2hlLiBJdCBjYW4gcmV0dXJuIGFub3RoZXIgZnVuY3Rpb24gdGhhdCB3ZSdsbCBjYWxsIGF0IHRoZSBlbmQgc28gaXQgY2FuIHJldHVybiB0byBpdHMgbm9ybWFsIHN0YXRlLlxuXG4gICAgY3VzdG9tUmV2ZXJ0UmV0dXJuID0gdHJpZ2dlciAmJiB0cmlnZ2VyLl9nc2FwICYmIHRyaWdnZXIuX2dzYXAuc3RSZXZlcnQ7XG4gICAgY3VzdG9tUmV2ZXJ0UmV0dXJuICYmIChjdXN0b21SZXZlcnRSZXR1cm4gPSBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZikpO1xuICAgIHBpbiA9IHBpbiA9PT0gdHJ1ZSA/IHRyaWdnZXIgOiBfZ2V0VGFyZ2V0KHBpbik7XG4gICAgX2lzU3RyaW5nKHRvZ2dsZUNsYXNzKSAmJiAodG9nZ2xlQ2xhc3MgPSB7XG4gICAgICB0YXJnZXRzOiB0cmlnZ2VyLFxuICAgICAgY2xhc3NOYW1lOiB0b2dnbGVDbGFzc1xuICAgIH0pO1xuXG4gICAgaWYgKHBpbikge1xuICAgICAgcGluU3BhY2luZyA9PT0gZmFsc2UgfHwgcGluU3BhY2luZyA9PT0gX21hcmdpbiB8fCAocGluU3BhY2luZyA9ICFwaW5TcGFjaW5nICYmIF9nZXRDb21wdXRlZFN0eWxlKHBpbi5wYXJlbnROb2RlKS5kaXNwbGF5ID09PSBcImZsZXhcIiA/IGZhbHNlIDogX3BhZGRpbmcpOyAvLyBpZiB0aGUgcGFyZW50IGlzIGRpc3BsYXk6IGZsZXgsIGRvbid0IGFwcGx5IHBpblNwYWNpbmcgYnkgZGVmYXVsdC5cblxuICAgICAgc2VsZi5waW4gPSBwaW47XG4gICAgICBwaW5DYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShwaW4pO1xuXG4gICAgICBpZiAoIXBpbkNhY2hlLnNwYWNlcikge1xuICAgICAgICAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuICAgICAgICBpZiAocGluU3BhY2VyKSB7XG4gICAgICAgICAgcGluU3BhY2VyID0gX2dldFRhcmdldChwaW5TcGFjZXIpO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAhcGluU3BhY2VyLm5vZGVUeXBlICYmIChwaW5TcGFjZXIgPSBwaW5TcGFjZXIuY3VycmVudCB8fCBwaW5TcGFjZXIubmF0aXZlRWxlbWVudCk7IC8vIGZvciBSZWFjdCAmIEFuZ3VsYXJcblxuICAgICAgICAgIHBpbkNhY2hlLnNwYWNlcklzTmF0aXZlID0gISFwaW5TcGFjZXI7XG4gICAgICAgICAgcGluU3BhY2VyICYmIChwaW5DYWNoZS5zcGFjZXJTdGF0ZSA9IF9nZXRTdGF0ZShwaW5TcGFjZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBpbkNhY2hlLnNwYWNlciA9IHNwYWNlciA9IHBpblNwYWNlciB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlclwiKTtcbiAgICAgICAgaWQgJiYgc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJwaW4tc3BhY2VyLVwiICsgaWQpO1xuICAgICAgICBwaW5DYWNoZS5waW5TdGF0ZSA9IHBpbk9yaWdpbmFsU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUgPSBwaW5DYWNoZS5waW5TdGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFycy5mb3JjZTNEICE9PSBmYWxzZSAmJiBnc2FwLnNldChwaW4sIHtcbiAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNwYWNlciA9IHNwYWNlciA9IHBpbkNhY2hlLnNwYWNlcjtcbiAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgIHNwYWNpbmdTdGFydCA9IGNzW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXTtcbiAgICAgIHBpbkdldHRlciA9IGdzYXAuZ2V0UHJvcGVydHkocGluKTtcbiAgICAgIHBpblNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIocGluLCBkaXJlY3Rpb24uYSwgX3B4KTsgLy8gcGluLmZpcnN0Q2hpbGQgJiYgIV9tYXhTY3JvbGwocGluLCBkaXJlY3Rpb24pICYmIChwaW4uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiKTsgLy8gcHJvdGVjdHMgZnJvbSBjb2xsYXBzaW5nIG1hcmdpbnMsIGJ1dCBjYW4gaGF2ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMWU0MmM3YTczYmZhNDA5ZDJjZjFlMTg0ZTdhNDI0OGQgc28gaXQgd2FzIHJlbW92ZWQgaW4gZmF2b3Igb2YganVzdCB0ZWxsaW5nIHBlb3BsZSB0byBzZXQgdXAgdGhlaXIgQ1NTIHRvIGF2b2lkIHRoZSBjb2xsYXBzaW5nIG1hcmdpbnMgKG92ZXJmbG93OiBoaWRkZW4gfCBhdXRvIGlzIGp1c3Qgb25lIG9wdGlvbi4gQW5vdGhlciBpcyBib3JkZXItdG9wOiAxcHggc29saWQgdHJhbnNwYXJlbnQpLlxuXG4gICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBjcyk7XG5cbiAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgIG1hcmtlclZhcnMgPSBfaXNPYmplY3QobWFya2VycykgPyBfc2V0RGVmYXVsdHMobWFya2VycywgX21hcmtlckRlZmF1bHRzKSA6IF9tYXJrZXJEZWZhdWx0cztcbiAgICAgIG1hcmtlclN0YXJ0VHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1zdGFydFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCk7XG4gICAgICBtYXJrZXJFbmRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLWVuZFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCwgbWFya2VyU3RhcnRUcmlnZ2VyKTtcbiAgICAgIG9mZnNldCA9IG1hcmtlclN0YXJ0VHJpZ2dlcltcIm9mZnNldFwiICsgZGlyZWN0aW9uLm9wLmQyXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBfZ2V0VGFyZ2V0KF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiY29udGVudFwiKSB8fCBzY3JvbGxlcik7XG5cbiAgICAgIG1hcmtlclN0YXJ0ID0gdGhpcy5tYXJrZXJTdGFydCA9IF9jcmVhdGVNYXJrZXIoXCJzdGFydFwiLCBpZCwgY29udGVudCwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCBvZmZzZXQsIDAsIGNvbnRhaW5lckFuaW1hdGlvbik7XG4gICAgICBtYXJrZXJFbmQgPSB0aGlzLm1hcmtlckVuZCA9IF9jcmVhdGVNYXJrZXIoXCJlbmRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uICYmIChjYU1hcmtlclNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIoW21hcmtlclN0YXJ0LCBtYXJrZXJFbmRdLCBkaXJlY3Rpb24uYSwgX3B4KSk7XG5cbiAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbiAmJiAhKF9wcm94aWVzLmxlbmd0aCAmJiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImZpeGVkTWFya2Vyc1wiKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgX21ha2VQb3NpdGlvbmFibGUoaXNWaWV3cG9ydCA/IF9ib2R5IDogc2Nyb2xsZXIpO1xuXG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLCB7XG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICAgIG1hcmtlckVuZFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbikge1xuICAgICAgdmFyIG9sZE9uVXBkYXRlID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGUsXG4gICAgICAgICAgb2xkUGFyYW1zID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGVQYXJhbXM7XG4gICAgICBjb250YWluZXJBbmltYXRpb24uZXZlbnRDYWxsYmFjayhcIm9uVXBkYXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoMCwgMCwgMSk7XG4gICAgICAgIG9sZE9uVXBkYXRlICYmIG9sZE9uVXBkYXRlLmFwcGx5KG9sZFBhcmFtcyB8fCBbXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxmLnByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSAtIDFdO1xuICAgIH07XG5cbiAgICBzZWxmLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RyaWdnZXJzW190cmlnZ2Vycy5pbmRleE9mKHNlbGYpICsgMV07XG4gICAgfTtcblxuICAgIHNlbGYucmV2ZXJ0ID0gZnVuY3Rpb24gKHJldmVydCwgdGVtcCkge1xuICAgICAgaWYgKCF0ZW1wKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmtpbGwodHJ1ZSk7XG4gICAgICB9IC8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZ3NhcC5jb250ZXh0KCkgYW5kIGdzYXAubWF0Y2hNZWRpYSgpIHdoaWNoIGNhbGwgcmV2ZXJ0KClcblxuXG4gICAgICB2YXIgciA9IHJldmVydCAhPT0gZmFsc2UgfHwgIXNlbGYuZW5hYmxlZCxcbiAgICAgICAgICBwcmV2UmVmcmVzaGluZyA9IF9yZWZyZXNoaW5nO1xuXG4gICAgICBpZiAociAhPT0gc2VsZi5pc1JldmVydGVkKSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgLy8gaWYgKCFzZWxmLnNjcm9sbC5yZWMgJiYgKF9yZWZyZXNoaW5nIHx8IF9yZWZyZXNoaW5nQWxsKSkge1xuICAgICAgICAgIC8vIFx0c2VsZi5zY3JvbGwucmVjID0gc2Nyb2xsRnVuYygpO1xuICAgICAgICAgIC8vIFx0X3JlZnJlc2hpbmdBbGwgJiYgc2Nyb2xsRnVuYygwKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgcHJldlNjcm9sbCA9IE1hdGgubWF4KHNjcm9sbEZ1bmMoKSwgc2VsZi5zY3JvbGwucmVjIHx8IDApOyAvLyByZWNvcmQgdGhlIHNjcm9sbCBzbyB3ZSBjYW4gcmV2ZXJ0IGxhdGVyIChyZXBvc2l0aW9uaW5nL3Bpbm5pbmcgdGhpbmdzIGNhbiBhZmZlY3Qgc2Nyb2xsIHBvc2l0aW9uKS4gSW4gdGhlIHN0YXRpYyByZWZyZXNoKCkgbWV0aG9kLCB3ZSBmaXJzdCByZWNvcmQgYWxsIHRoZSBzY3JvbGwgcG9zaXRpb25zIGFzIGEgcmVmZXJlbmNlLlxuXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcztcbiAgICAgICAgICBwcmV2QW5pbVByb2dyZXNzID0gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyU3RhcnQgJiYgW21hcmtlclN0YXJ0LCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgbWFya2VyRW5kVHJpZ2dlcl0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLnN0eWxlLmRpc3BsYXkgPSByID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG4gICAgICAgIH0pO1xuICAgICAgICByICYmIChfcmVmcmVzaGluZyA9IDEpO1xuICAgICAgICBzZWxmLnVwZGF0ZShyKTsgLy8gbWFrZSBzdXJlIHRoZSBwaW4gaXMgYmFjayBpbiBpdHMgb3JpZ2luYWwgcG9zaXRpb24gc28gdGhhdCBhbGwgdGhlIG1lYXN1cmVtZW50cyBhcmUgY29ycmVjdC5cblxuICAgICAgICBfcmVmcmVzaGluZyA9IHByZXZSZWZyZXNoaW5nO1xuICAgICAgICBwaW4gJiYgKHIgPyBfc3dhcFBpbk91dChwaW4sIHNwYWNlciwgcGluT3JpZ2luYWxTdGF0ZSkgOiAoIXBpblJlcGFyZW50IHx8ICFzZWxmLmlzQWN0aXZlKSAmJiBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pLCBzcGFjZXJTdGF0ZSkpO1xuICAgICAgICBzZWxmLmlzUmV2ZXJ0ZWQgPSByO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoc29mdCwgZm9yY2UpIHtcbiAgICAgIGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbiAmJiBzb2Z0ICYmIF9sYXN0U2Nyb2xsVGltZSkge1xuICAgICAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICFfcmVmcmVzaGluZ0FsbCAmJiBvblJlZnJlc2hJbml0ICYmIG9uUmVmcmVzaEluaXQoc2VsZik7XG4gICAgICBfcmVmcmVzaGluZyA9IDE7XG4gICAgICBsYXN0UmVmcmVzaCA9IF9nZXRUaW1lKCk7XG5cbiAgICAgIGlmICh0d2VlblRvLnR3ZWVuKSB7XG4gICAgICAgIHR3ZWVuVG8udHdlZW4ua2lsbCgpO1xuICAgICAgICB0d2VlblRvLnR3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XG4gICAgICBpbnZhbGlkYXRlT25SZWZyZXNoICYmIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmV2ZXJ0KHtcbiAgICAgICAga2lsbDogZmFsc2VcbiAgICAgIH0pLmludmFsaWRhdGUoKTtcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCB8fCBzZWxmLnJldmVydCh0cnVlLCB0cnVlKTtcblxuICAgICAgdmFyIHNpemUgPSBnZXRTY3JvbGxlclNpemUoKSxcbiAgICAgICAgICBzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuICAgICAgICAgIG1heCA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpIDogX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIG90aGVyUGluT2Zmc2V0ID0gMCxcbiAgICAgICAgICBwYXJzZWRFbmQgPSB2YXJzLmVuZCxcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG4gICAgICAgICAgcGFyc2VkU3RhcnQgPSB2YXJzLnN0YXJ0IHx8ICh2YXJzLnN0YXJ0ID09PSAwIHx8ICF0cmlnZ2VyID8gMCA6IHBpbiA/IFwiMCAwXCIgOiBcIjAgMTAwJVwiKSxcbiAgICAgICAgICBwaW5uZWRDb250YWluZXIgPSBzZWxmLnBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnM7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSAxKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblxuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcblxuICAgICAgICBpZiAoY3VyUGluICYmIChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW4pICYmICFjdXJUcmlnZ2VyLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgICByZXZlcnRlZFBpbnMgfHwgKHJldmVydGVkUGlucyA9IFtdKTtcbiAgICAgICAgICByZXZlcnRlZFBpbnMudW5zaGlmdChjdXJUcmlnZ2VyKTsgLy8gd2UnbGwgcmV2ZXJ0IGZyb20gZmlyc3QgdG8gbGFzdCB0byBtYWtlIHN1cmUgdGhpbmdzIHJlYWNoIHRoZWlyIGVuZCBzdGF0ZSBwcm9wZXJseVxuXG4gICAgICAgICAgY3VyVHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VyVHJpZ2dlciAhPT0gX3RyaWdnZXJzW2ldKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBpdCBnb3QgcmVtb3ZlZC5cbiAgICAgICAgICB0cmlnZ2VySW5kZXgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2lzRnVuY3Rpb24ocGFyc2VkU3RhcnQpICYmIChwYXJzZWRTdGFydCA9IHBhcnNlZFN0YXJ0KHNlbGYpKTtcbiAgICAgIHN0YXJ0ID0gX3BhcnNlUG9zaXRpb24ocGFyc2VkU3RhcnQsIHRyaWdnZXIsIHNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsRnVuYygpLCBtYXJrZXJTdGFydCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uKSB8fCAocGluID8gLTAuMDAxIDogMCk7XG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRFbmQpICYmIChwYXJzZWRFbmQgPSBwYXJzZWRFbmQoc2VsZikpO1xuXG4gICAgICBpZiAoX2lzU3RyaW5nKHBhcnNlZEVuZCkgJiYgIXBhcnNlZEVuZC5pbmRleE9mKFwiKz1cIikpIHtcbiAgICAgICAgaWYgKH5wYXJzZWRFbmQuaW5kZXhPZihcIiBcIikpIHtcbiAgICAgICAgICBwYXJzZWRFbmQgPSAoX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0LnNwbGl0KFwiIFwiKVswXSA6IFwiXCIpICsgcGFyc2VkRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXRUb1B4KHBhcnNlZEVuZC5zdWJzdHIoMiksIHNpemUpO1xuICAgICAgICAgIHBhcnNlZEVuZCA9IF9pc1N0cmluZyhwYXJzZWRTdGFydCkgPyBwYXJzZWRTdGFydCA6IHN0YXJ0ICsgb2Zmc2V0OyAvLyBfcGFyc2VQb3NpdGlvbiB3b24ndCBmYWN0b3IgaW4gdGhlIG9mZnNldCBpZiB0aGUgc3RhcnQgaXMgYSBudW1iZXIsIHNvIGRvIGl0IGhlcmUuXG5cbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbmQgPSBNYXRoLm1heChzdGFydCwgX3BhcnNlUG9zaXRpb24ocGFyc2VkRW5kIHx8IChwYXJzZWRFbmRUcmlnZ2VyID8gXCIxMDAlIDBcIiA6IG1heCksIHBhcnNlZEVuZFRyaWdnZXIsIHNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsRnVuYygpICsgb2Zmc2V0LCBtYXJrZXJFbmQsIG1hcmtlckVuZFRyaWdnZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgbWF4LCBjb250YWluZXJBbmltYXRpb24pKSB8fCAtMC4wMDE7XG4gICAgICBjaGFuZ2UgPSBlbmQgLSBzdGFydCB8fCAoc3RhcnQgLT0gMC4wMSkgJiYgMC4wMDE7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgaSA9IHRyaWdnZXJJbmRleDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjdXJUcmlnZ2VyID0gX3RyaWdnZXJzW2ldO1xuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcblxuICAgICAgICBpZiAoY3VyUGluICYmIGN1clRyaWdnZXIuc3RhcnQgLSBjdXJUcmlnZ2VyLl9waW5QdXNoIDwgc3RhcnQgJiYgIWNvbnRhaW5lckFuaW1hdGlvbiAmJiBjdXJUcmlnZ2VyLmVuZCA+IDApIHtcbiAgICAgICAgICBjcyA9IGN1clRyaWdnZXIuZW5kIC0gY3VyVHJpZ2dlci5zdGFydDtcblxuICAgICAgICAgIGlmICgoY3VyUGluID09PSB0cmlnZ2VyIHx8IGN1clBpbiA9PT0gcGlubmVkQ29udGFpbmVyKSAmJiAhX2lzTnVtYmVyKHBhcnNlZFN0YXJ0KSkge1xuICAgICAgICAgICAgLy8gbnVtZXJpYyBzdGFydCB2YWx1ZXMgc2hvdWxkbid0IGJlIG9mZnNldCBhdCBhbGwgLSB0cmVhdCB0aGVtIGFzIGFic29sdXRlXG4gICAgICAgICAgICBvZmZzZXQgKz0gY3MgKiAoMSAtIGN1clRyaWdnZXIucHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1clBpbiA9PT0gcGluICYmIChvdGhlclBpbk9mZnNldCArPSBjcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICAgIHNlbGYuX3BpblB1c2ggPSBvdGhlclBpbk9mZnNldDtcblxuICAgICAgaWYgKG1hcmtlclN0YXJ0ICYmIG9mZnNldCkge1xuICAgICAgICAvLyBvZmZzZXQgdGhlIG1hcmtlcnMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGNzID0ge307XG4gICAgICAgIGNzW2RpcmVjdGlvbi5hXSA9IFwiKz1cIiArIG9mZnNldDtcbiAgICAgICAgcGlubmVkQ29udGFpbmVyICYmIChjc1tkaXJlY3Rpb24ucF0gPSBcIi09XCIgKyBzY3JvbGxGdW5jKCkpO1xuICAgICAgICBnc2FwLnNldChbbWFya2VyU3RhcnQsIG1hcmtlckVuZF0sIGNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG4gICAgICAgIGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbDtcbiAgICAgICAgc2Nyb2xsID0gc2Nyb2xsRnVuYygpOyAvLyByZWNhbGN1bGF0ZSBiZWNhdXNlIHRoZSB0cmlnZ2VycyBjYW4gYWZmZWN0IHRoZSBzY3JvbGxcblxuICAgICAgICBwaW5TdGFydCA9IHBhcnNlRmxvYXQocGluR2V0dGVyKGRpcmVjdGlvbi5hKSkgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgIW1heCAmJiBlbmQgPiAxICYmICgoaXNWaWV3cG9ydCA/IF9ib2R5IDogc2Nyb2xsZXIpLnN0eWxlW1wib3ZlcmZsb3ctXCIgKyBkaXJlY3Rpb24uYV0gPSBcInNjcm9sbFwiKTsgLy8gbWFrZXMgc3VyZSB0aGUgc2Nyb2xsZXIgaGFzIGEgc2Nyb2xsYmFyLCBvdGhlcndpc2UgaWYgc29tZXRoaW5nIGhhcyB3aWR0aDogMTAwJSwgZm9yIGV4YW1wbGUsIGl0IHdvdWxkIGJlIHRvbyBiaWcgKGV4Y2x1ZGUgdGhlIHNjcm9sbGJhcikuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzI1MTgyLXNjcm9sbHRyaWdnZXItd2lkdGgtb2YtcGFnZS1pbmNyZWFzZS13aGVyZS1tYXJrZXJzLWFyZS1zZXQtdG8tZmFsc2UvXG5cbiAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7IC8vIHRyYW5zZm9ybXMgd2lsbCBpbnRlcmZlcmUgd2l0aCB0aGUgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHBsYWNlbWVudCwgc28gcmVtb3ZlIHRoZW0gdGVtcG9yYXJpbHkuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGZhY3RvcnMgaW4gdHJhbnNmb3Jtcy5cblxuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSk7XG4gICAgICAgIG9wcG9zaXRlU2Nyb2xsID0gdXNlRml4ZWRQb3NpdGlvbiAmJiBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgaXNWZXJ0aWNhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKSgpO1xuXG4gICAgICAgIGlmIChwaW5TcGFjaW5nKSB7XG4gICAgICAgICAgc3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcbiAgICAgICAgICBzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuICAgICAgICAgIGkgPSBwaW5TcGFjaW5nID09PSBfcGFkZGluZyA/IF9nZXRTaXplKHBpbiwgZGlyZWN0aW9uKSArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0IDogMDtcbiAgICAgICAgICBpICYmIHNwYWNlclN0YXRlLnB1c2goZGlyZWN0aW9uLmQsIGkgKyBfcHgpOyAvLyBmb3IgYm94LXNpemluZzogYm9yZGVyLWJveCAobXVzdCBpbmNsdWRlIHBhZGRpbmcpLlxuXG4gICAgICAgICAgX3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblxuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgb3ZlcnJpZGUgPSB7XG4gICAgICAgICAgICB0b3A6IGJvdW5kcy50b3AgKyAoaXNWZXJ0aWNhbCA/IHNjcm9sbCAtIHN0YXJ0IDogb3Bwb3NpdGVTY3JvbGwpICsgX3B4LFxuICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IG9wcG9zaXRlU2Nyb2xsIDogc2Nyb2xsIC0gc3RhcnQpICsgX3B4LFxuICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIG92ZXJyaWRlW193aWR0aF0gPSBvdmVycmlkZVtcIm1heFwiICsgX1dpZHRoXSA9IE1hdGguY2VpbChib3VuZHMud2lkdGgpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19oZWlnaHRdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9IZWlnaHRdID0gTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19tYXJnaW5dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Ub3BdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9SaWdodF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0JvdHRvbV0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0xlZnRdID0gXCIwXCI7XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmddID0gY3NbX3BhZGRpbmddO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1RvcF0gPSBjc1tfcGFkZGluZyArIF9Ub3BdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1JpZ2h0XSA9IGNzW19wYWRkaW5nICsgX1JpZ2h0XTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Cb3R0b21dID0gY3NbX3BhZGRpbmcgKyBfQm90dG9tXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9MZWZ0XSA9IGNzW19wYWRkaW5nICsgX0xlZnRdO1xuICAgICAgICAgIHBpbkFjdGl2ZVN0YXRlID0gX2NvcHlTdGF0ZShwaW5PcmlnaW5hbFN0YXRlLCBvdmVycmlkZSwgcGluUmVwYXJlbnQpO1xuICAgICAgICAgIF9yZWZyZXNoaW5nQWxsICYmIHNjcm9sbEZ1bmMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgaW5pdHRlZCA9IGFuaW1hdGlvbi5faW5pdHRlZDsgLy8gaWYgbm90LCB3ZSBtdXN0IGludmFsaWRhdGUoKSBhZnRlciB0aGlzIHN0ZXAsIG90aGVyd2lzZSBpdCBjb3VsZCBsb2NrIGluIHN0YXJ0aW5nIHZhbHVlcyBwcmVtYXR1cmVseS5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMSk7XG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgICBjaGFuZ2UgIT09IHBpbkNoYW5nZSAmJiB1c2VGaXhlZFBvc2l0aW9uICYmIHBpbkFjdGl2ZVN0YXRlLnNwbGljZShwaW5BY3RpdmVTdGF0ZS5sZW5ndGggLSAyLCAyKTsgLy8gdHJhbnNmb3JtIGlzIHRoZSBsYXN0IHByb3BlcnR5L3ZhbHVlIHNldCBpbiB0aGUgc3RhdGUgQXJyYXkuIFNpbmNlIHRoZSBhbmltYXRpb24gaXMgY29udHJvbGxpbmcgdGhhdCwgd2Ugc2hvdWxkIG9taXQgaXQuXG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGluaXR0ZWQgfHwgYW5pbWF0aW9uLmludmFsaWRhdGUodHJ1ZSk7XG4gICAgICAgICAgYW5pbWF0aW9uLnBhcmVudCB8fCBhbmltYXRpb24udG90YWxUaW1lKGFuaW1hdGlvbi50b3RhbFRpbWUoKSk7IC8vIGlmLCBmb3IgZXhhbXBsZSwgYSB0b2dnbGVBY3Rpb24gY2FsbGVkIHBsYXkoKSBhbmQgdGhlbiByZWZyZXNoKCkgaGFwcGVucyBhbmQgd2hlbiB3ZSByZW5kZXIoMSkgYWJvdmUsIGl0IHdvdWxkIGNhdXNlIHRoZSBhbmltYXRpb24gdG8gY29tcGxldGUgYW5kIGdldCByZW1vdmVkIGZyb20gaXRzIHBhcmVudCwgc28gdGhpcyBtYWtlcyBzdXJlIGl0IGdldHMgcHV0IGJhY2sgaW4uXG5cbiAgICAgICAgICBfc3VwcHJlc3NPdmVyd3JpdGVzKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBpbkNoYW5nZSA9IGNoYW5nZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICYmIHNjcm9sbEZ1bmMoKSAmJiAhY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGl0IG1heSBiZSBJTlNJREUgYSBwaW5uZWQgZWxlbWVudCwgc28gd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBmb3IgYW55IGVsZW1lbnRzIHdpdGggX3Bpbk9mZnNldCB0byBjb21wZW5zYXRlIGJlY2F1c2UgYW55dGhpbmcgd2l0aCBwaW5TcGFjaW5nIHRoYXQncyBhbHJlYWR5IHNjcm9sbGVkIHdvdWxkIHRocm93IG9mZiB0aGUgbWVhc3VyZW1lbnRzIGluIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGJvdW5kcyA9IHRyaWdnZXIucGFyZW50Tm9kZTtcblxuICAgICAgICB3aGlsZSAoYm91bmRzICYmIGJvdW5kcyAhPT0gX2JvZHkpIHtcbiAgICAgICAgICBpZiAoYm91bmRzLl9waW5PZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YXJ0IC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgICAgZW5kIC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldmVydGVkUGlucyAmJiByZXZlcnRlZFBpbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBzZWxmLmVuZCA9IGVuZDtcbiAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gX3JlZnJlc2hpbmdBbGwgPyBwcmV2U2Nyb2xsIDogc2Nyb2xsRnVuYygpOyAvLyByZXNldCB2ZWxvY2l0eVxuXG4gICAgICBpZiAoIWNvbnRhaW5lckFuaW1hdGlvbiAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2Nyb2xsMSA8IHByZXZTY3JvbGwgJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgc2VsZi5zY3JvbGwucmVjID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXZlcnQoZmFsc2UsIHRydWUpO1xuXG4gICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgIGxhc3RTbmFwID0gLTE7XG4gICAgICAgIHNlbGYuaXNBY3RpdmUgJiYgc2Nyb2xsRnVuYyhzdGFydCArIGNoYW5nZSAqIHByZXZQcm9ncmVzcyk7IC8vIGp1c3Qgc28gc25hcHBpbmcgZ2V0cyByZS1lbmFibGVkLCBjbGVhciBvdXQgYW55IHJlY29yZGVkIGxhc3QgdmFsdWVcblxuICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgX3JlZnJlc2hpbmcgPSAwO1xuICAgICAgYW5pbWF0aW9uICYmIGlzVG9nZ2xlICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgcHJldkFuaW1Qcm9ncmVzcykgJiYgYW5pbWF0aW9uLnByb2dyZXNzKCkgIT09IHByZXZBbmltUHJvZ3Jlc3MgJiYgYW5pbWF0aW9uLnByb2dyZXNzKHByZXZBbmltUHJvZ3Jlc3MsIHRydWUpLnJlbmRlcihhbmltYXRpb24udGltZSgpLCB0cnVlLCB0cnVlKTsgLy8gbXVzdCBmb3JjZSBhIHJlLXJlbmRlciBiZWNhdXNlIGlmIHNhdmVTdHlsZXMoKSB3YXMgdXNlZCBvbiB0aGUgdGFyZ2V0KHMpLCB0aGUgc3R5bGVzIGNvdWxkIGhhdmUgYmVlbiB3aXBlZCBvdXQgZHVyaW5nIHRoZSByZWZyZXNoKCkuXG5cbiAgICAgIGlmIChwcmV2UHJvZ3Jlc3MgIT09IHNlbGYucHJvZ3Jlc3MgfHwgY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGVuc3VyZXMgdGhhdCB0aGUgZGlyZWN0aW9uIGlzIHNldCBwcm9wZXJseSAod2hlbiByZWZyZXNoaW5nLCBwcm9ncmVzcyBpcyBzZXQgYmFjayB0byAwIGluaXRpYWxseSwgdGhlbiBiYWNrIGFnYWluIHRvIHdoZXJldmVyIGl0IG5lZWRzIHRvIGJlKSBhbmQgdGhhdCBjYWxsYmFja3MgYXJlIHRyaWdnZXJlZC5cbiAgICAgICAgYW5pbWF0aW9uICYmICFpc1RvZ2dsZSAmJiBhbmltYXRpb24udG90YWxQcm9ncmVzcyhwcmV2UHJvZ3Jlc3MsIHRydWUpOyAvLyB0byBhdm9pZCBpc3N1ZXMgd2hlcmUgYW5pbWF0aW9uIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQgYXJlbid0IHRyaWdnZXJlZC5cblxuICAgICAgICBzZWxmLnByb2dyZXNzID0gKHNjcm9sbDEgLSBzdGFydCkgLyBjaGFuZ2UgPT09IHByZXZQcm9ncmVzcyA/IDAgOiBwcmV2UHJvZ3Jlc3M7XG4gICAgICB9XG5cbiAgICAgIHBpbiAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuX3Bpbk9mZnNldCA9IE1hdGgucm91bmQoc2VsZi5wcm9ncmVzcyAqIHBpbkNoYW5nZSkpOyAvL1x0XHRcdHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCk7XG5cbiAgICAgIG9uUmVmcmVzaCAmJiBvblJlZnJlc2goc2VsZik7XG4gICAgfTtcblxuICAgIHNlbGYuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHNjcm9sbEZ1bmMoKSAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogMTAwMCB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLmVuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkgOiAhYW5pbWF0aW9uLnBhdXNlZCgpID8gX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIGFuaW1hdGlvbi5yZXZlcnNlZCgpKSA6IGlzVG9nZ2xlIHx8IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBzZWxmLmRpcmVjdGlvbiA8IDAsIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmxhYmVsVG9TY3JvbGwgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgIHJldHVybiBhbmltYXRpb24gJiYgYW5pbWF0aW9uLmxhYmVscyAmJiAoc3RhcnQgfHwgc2VsZi5yZWZyZXNoKCkgfHwgc3RhcnQpICsgYW5pbWF0aW9uLmxhYmVsc1tsYWJlbF0gLyBhbmltYXRpb24uZHVyYXRpb24oKSAqIGNoYW5nZSB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLmdldFRyYWlsaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZiksXG4gICAgICAgICAgYSA9IHNlbGYuZGlyZWN0aW9uID4gMCA/IF90cmlnZ2Vycy5zbGljZSgwLCBpKS5yZXZlcnNlKCkgOiBfdHJpZ2dlcnMuc2xpY2UoaSArIDEpO1xuXG4gICAgICByZXR1cm4gKF9pc1N0cmluZyhuYW1lKSA/IGEuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnZhcnMucHJldmVudE92ZXJsYXBzID09PSBuYW1lO1xuICAgICAgfSkgOiBhKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGlyZWN0aW9uID4gMCA/IHQuZW5kIDw9IHN0YXJ0IDogdC5zdGFydCA+PSBlbmQ7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAocmVzZXQsIHJlY29yZFZlbG9jaXR5LCBmb3JjZUZha2UpIHtcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24gJiYgIWZvcmNlRmFrZSAmJiAhcmVzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsID0gX3JlZnJlc2hpbmdBbGwgPyBwcmV2U2Nyb2xsIDogc2VsZi5zY3JvbGwoKSxcbiAgICAgICAgICBwID0gcmVzZXQgPyAwIDogKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcbiAgICAgICAgICBjbGlwcGVkID0gcCA8IDAgPyAwIDogcCA+IDEgPyAxIDogcCB8fCAwLFxuICAgICAgICAgIHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3MsXG4gICAgICAgICAgaXNBY3RpdmUsXG4gICAgICAgICAgd2FzQWN0aXZlLFxuICAgICAgICAgIHRvZ2dsZVN0YXRlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBzdGF0ZUNoYW5nZWQsXG4gICAgICAgICAgdG9nZ2xlZCxcbiAgICAgICAgICBpc0F0TWF4LFxuICAgICAgICAgIGlzVGFraW5nQWN0aW9uO1xuXG4gICAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgICAgc2Nyb2xsMiA9IHNjcm9sbDE7XG4gICAgICAgIHNjcm9sbDEgPSBjb250YWluZXJBbmltYXRpb24gPyBzY3JvbGxGdW5jKCkgOiBzY3JvbGw7XG5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICBzbmFwMiA9IHNuYXAxO1xuICAgICAgICAgIHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFudGljaXBhdGUgdGhlIHBpbm5pbmcgYSBmZXcgdGlja3MgYWhlYWQgb2YgdGltZSBiYXNlZCBvbiB2ZWxvY2l0eSB0byBhdm9pZCBhIHZpc3VhbCBnbGl0Y2ggZHVlIHRvIHRoZSBmYWN0IHRoYXQgbW9zdCBicm93c2VycyBkbyBzY3JvbGxpbmcgb24gYSBzZXBhcmF0ZSB0aHJlYWQgKG5vdCBzeW5jZWQgd2l0aCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLlxuXG5cbiAgICAgIGFudGljaXBhdGVQaW4gJiYgIWNsaXBwZWQgJiYgcGluICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgX2xhc3RTY3JvbGxUaW1lICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbiAmJiAoY2xpcHBlZCA9IDAuMDAwMSk7XG5cbiAgICAgIGlmIChjbGlwcGVkICE9PSBwcmV2UHJvZ3Jlc3MgJiYgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgIGlzQWN0aXZlID0gc2VsZi5pc0FjdGl2ZSA9ICEhY2xpcHBlZCAmJiBjbGlwcGVkIDwgMTtcbiAgICAgICAgd2FzQWN0aXZlID0gISFwcmV2UHJvZ3Jlc3MgJiYgcHJldlByb2dyZXNzIDwgMTtcbiAgICAgICAgdG9nZ2xlZCA9IGlzQWN0aXZlICE9PSB3YXNBY3RpdmU7XG4gICAgICAgIHN0YXRlQ2hhbmdlZCA9IHRvZ2dsZWQgfHwgISFjbGlwcGVkICE9PSAhIXByZXZQcm9ncmVzczsgLy8gY291bGQgZ28gZnJvbSBzdGFydCBhbGwgdGhlIHdheSB0byBlbmQsIHRodXMgaXQgZGlkbid0IHRvZ2dsZSBidXQgaXQgZGlkIGNoYW5nZSBzdGF0ZSBpbiBhIHNlbnNlIChtYXkgbmVlZCB0byBmaXJlIGEgY2FsbGJhY2spXG5cbiAgICAgICAgc2VsZi5kaXJlY3Rpb24gPSBjbGlwcGVkID4gcHJldlByb2dyZXNzID8gMSA6IC0xO1xuICAgICAgICBzZWxmLnByb2dyZXNzID0gY2xpcHBlZDtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCAmJiAhcHJldlByb2dyZXNzID8gMCA6IGNsaXBwZWQgPT09IDEgPyAxIDogcHJldlByb2dyZXNzID09PSAxID8gMiA6IDM7IC8vIDAgPSBlbnRlciwgMSA9IGxlYXZlLCAyID0gZW50ZXJCYWNrLCAzID0gbGVhdmVCYWNrICh3ZSBwcmlvcml0aXplIHRoZSBGSVJTVCBlbmNvdW50ZXIsIHRodXMgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCBwYXN0IHRoZSBvbkVudGVyIGFuZCBvbkxlYXZlIGluIG9uZSB0aWNrLCBpdCdkIHByaW9yaXRpemUgb25FbnRlci5cblxuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgYWN0aW9uID0gIXRvZ2dsZWQgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdICE9PSBcIm5vbmVcIiAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gfHwgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZV07IC8vIGlmIGl0IGRpZG4ndCB0b2dnbGUsIHRoYXQgbWVhbnMgaXQgc2hvdCByaWdodCBwYXN0IGFuZCBzaW5jZSB3ZSBwcmlvcml0aXplIHRoZSBcImVudGVyXCIgYWN0aW9uLCB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBcImxlYXZlXCIgaW4gdGhpcyBjYXNlIChidXQgb25seSBpZiBvbmUgaXMgZGVmaW5lZClcblxuICAgICAgICAgICAgaXNUYWtpbmdBY3Rpb24gPSBhbmltYXRpb24gJiYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiIHx8IGFjdGlvbiA9PT0gXCJyZXNldFwiIHx8IGFjdGlvbiBpbiBhbmltYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyAmJiAodG9nZ2xlZCB8fCBpc1Rha2luZ0FjdGlvbikgJiYgKGlzVGFraW5nQWN0aW9uIHx8IHNjcnViIHx8ICFhbmltYXRpb24pICYmIChfaXNGdW5jdGlvbihwcmV2ZW50T3ZlcmxhcHMpID8gcHJldmVudE92ZXJsYXBzKHNlbGYpIDogc2VsZi5nZXRUcmFpbGluZyhwcmV2ZW50T3ZlcmxhcHMpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5lbmRBbmltYXRpb24oKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICghaXNUb2dnbGUpIHtcbiAgICAgICAgICBpZiAoc2NydWJUd2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwKSB7XG4gICAgICAgICAgICAoY29udGFpbmVyQW5pbWF0aW9uIHx8IF9wcmltYXJ5ICYmIF9wcmltYXJ5ICE9PSBzZWxmKSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxuXG4gICAgICAgICAgICBpZiAoc2NydWJUd2Vlbi5yZXNldFRvKSB7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWdhY3kgc3VwcG9ydCAoY291cnRlc3kpLCBiZWZvcmUgMy4xMC4wXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcbiAgICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIV9yZWZyZXNoaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGluKSB7XG4gICAgICAgICAgcmVzZXQgJiYgcGluU3BhY2luZyAmJiAoc3BhY2VyLnN0eWxlW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXSA9IHNwYWNpbmdTdGFydCk7XG5cbiAgICAgICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBpblNldHRlcihfcm91bmQocGluU3RhcnQgKyBwaW5DaGFuZ2UgKiBjbGlwcGVkKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlzQXRNYXggPSAhcmVzZXQgJiYgY2xpcHBlZCA+IHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cbiAgICAgICAgICAgIGlmIChwaW5SZXBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc2V0ICYmIChpc0FjdGl2ZSB8fCBpc0F0TWF4KSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcblxuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIF9ib2R5LCBib3VuZHMudG9wICsgKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX29mZnNldCA6IDApICsgX3B4LCBib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBfb2Zmc2V0KSArIF9weCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3JlcGFyZW50KHBpbiwgc3BhY2VyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2V0U3RhdGUoaXNBY3RpdmUgfHwgaXNBdE1heCA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXG4gICAgICAgICAgICBwaW5DaGFuZ2UgIT09IGNoYW5nZSAmJiBjbGlwcGVkIDwgMSAmJiBpc0FjdGl2ZSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhaXNBdE1heCA/IHBpbkNoYW5nZSA6IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IG9uY2UgJiYgY2xpcHBlZCAmJiAoY2xpcHBlZCA8IDEgfHwgIV9saW1pdENhbGxiYWNrcykpICYmIF90b0FycmF5KHRvZ2dsZUNsYXNzLnRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFtpc0FjdGl2ZSB8fCBvbmNlID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKHRvZ2dsZUNsYXNzLmNsYXNzTmFtZSk7XG4gICAgICAgIH0pOyAvLyBjbGFzc2VzIGNvdWxkIGFmZmVjdCBwb3NpdGlvbmluZywgc28gZG8gaXQgZXZlbiBpZiByZXNldCBvciByZWZyZXNoaW5nIGlzIHRydWUuXG5cbiAgICAgICAgb25VcGRhdGUgJiYgIWlzVG9nZ2xlICYmICFyZXNldCAmJiBvblVwZGF0ZShzZWxmKTtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgaWYgKGlzVGFraW5nQWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpLnRvdGFsUHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25bYWN0aW9uXSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uVXBkYXRlICYmIG9uVXBkYXRlKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2dnbGVkIHx8ICFfbGltaXRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIG9uIHN0YXJ0dXAsIHRoZSBwYWdlIGNvdWxkIGJlIHNjcm9sbGVkIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgY2FsbGJhY2tzIHRoYXQgZGlkbid0IHRvZ2dsZS4gRm9yIGV4YW1wbGUgb25FbnRlciBzaG91bGRuJ3QgZmlyZSBpZiB0aGUgU2Nyb2xsVHJpZ2dlciBpc24ndCBhY3R1YWxseSBlbnRlcmVkLlxuICAgICAgICAgICAgb25Ub2dnbGUgJiYgdG9nZ2xlZCAmJiBfY2FsbGJhY2soc2VsZiwgb25Ub2dnbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICBvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gPSAwKTsgLy8gYSBjYWxsYmFjayBzaG91bGRuJ3QgYmUgY2FsbGVkIGFnYWluIGlmIG9uY2UgaXMgdHJ1ZS5cblxuICAgICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG4gICAgICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuICAgICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIF9jYWxsYmFjayhzZWxmLCBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmFzdFNjcm9sbEVuZCAmJiAhaXNBY3RpdmUgJiYgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA+IChfaXNOdW1iZXIoZmFzdFNjcm9sbEVuZCkgPyBmYXN0U2Nyb2xsRW5kIDogMjUwMCkpIHtcbiAgICAgICAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIGFjdGlvbiA9PT0gXCJyZXZlcnNlXCIgPyAxIDogIWNsaXBwZWQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1RvZ2dsZSAmJiBvblVwZGF0ZSAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICBvblVwZGF0ZShzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB1cGRhdGUgYWJzb2x1dGVseS1wb3NpdGlvbmVkIG1hcmtlcnMgKG9ubHkgaWYgdGhlIHNjcm9sbGVyIGlzbid0IHRoZSB2aWV3cG9ydClcblxuXG4gICAgICBpZiAobWFya2VyRW5kU2V0dGVyKSB7XG4gICAgICAgIHZhciBuID0gY29udGFpbmVyQW5pbWF0aW9uID8gc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkgOiBzY3JvbGw7XG4gICAgICAgIG1hcmtlclN0YXJ0U2V0dGVyKG4gKyAobWFya2VyU3RhcnRUcmlnZ2VyLl9pc0ZsaXBwZWQgPyAxIDogMCkpO1xuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIobik7XG4gICAgICB9XG5cbiAgICAgIGNhTWFya2VyU2V0dGVyICYmIGNhTWFya2VyU2V0dGVyKC1zY3JvbGwgLyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSAqIChjb250YWluZXJBbmltYXRpb24uX2NhU2Nyb2xsRGlzdCB8fCAwKSk7XG4gICAgfTtcblxuICAgIHNlbGYuZW5hYmxlID0gZnVuY3Rpb24gKHJlc2V0LCByZWZyZXNoKSB7XG4gICAgICBpZiAoIXNlbGYuZW5hYmxlZCkge1xuICAgICAgICBzZWxmLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoaXNWaWV3cG9ydCA/IF9kb2MgOiBzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgICAgICBvblJlZnJlc2hJbml0ICYmIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hJbml0XCIsIG9uUmVmcmVzaEluaXQpO1xuXG4gICAgICAgIGlmIChyZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZWxmLnByb2dyZXNzID0gcHJldlByb2dyZXNzID0gMDtcbiAgICAgICAgICBzY3JvbGwxID0gc2Nyb2xsMiA9IGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmcmVzaCAhPT0gZmFsc2UgJiYgc2VsZi5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuZ2V0VHdlZW4gPSBmdW5jdGlvbiAoc25hcCkge1xuICAgICAgcmV0dXJuIHNuYXAgJiYgdHdlZW5UbyA/IHR3ZWVuVG8udHdlZW4gOiBzY3J1YlR3ZWVuO1xuICAgIH07XG5cbiAgICBzZWxmLnNldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChuZXdTdGFydCwgbmV3RW5kKSB7XG4gICAgICAvLyBkb2Vzbid0IHBlcnNpc3QgYWZ0ZXIgcmVmcmVzaCgpISBJbnRlbmRlZCB0byBiZSBhIHdheSB0byBvdmVycmlkZSB2YWx1ZXMgdGhhdCB3ZXJlIHNldCBkdXJpbmcgcmVmcmVzaCgpLCBsaWtlIHlvdSBjb3VsZCBzZXQgaXQgaW4gb25SZWZyZXNoKClcbiAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgcGluU3RhcnQgKz0gbmV3U3RhcnQgLSBzdGFydDtcbiAgICAgICAgcGluQ2hhbmdlICs9IG5ld0VuZCAtIG5ld1N0YXJ0IC0gY2hhbmdlO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnN0YXJ0ID0gc3RhcnQgPSBuZXdTdGFydDtcbiAgICAgIHNlbGYuZW5kID0gZW5kID0gbmV3RW5kO1xuICAgICAgY2hhbmdlID0gbmV3RW5kIC0gbmV3U3RhcnQ7XG4gICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBzZWxmLmRpc2FibGUgPSBmdW5jdGlvbiAocmVzZXQsIGFsbG93QW5pbWF0aW9uKSB7XG4gICAgICBpZiAoc2VsZi5lbmFibGVkKSB7XG4gICAgICAgIHJlc2V0ICE9PSBmYWxzZSAmJiBzZWxmLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gc2VsZi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgICAgcHJldlNjcm9sbCA9IDA7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgICAgIHR3ZWVuVG8udHdlZW4gJiYgdHdlZW5Uby50d2Vlbi5raWxsKCkgJiYgKHR3ZWVuVG8udHdlZW4gPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWaWV3cG9ydCkge1xuICAgICAgICAgIHZhciBpID0gX3RyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChfdHJpZ2dlcnNbaV0uc2Nyb2xsZXIgPT09IHNjcm9sbGVyICYmIF90cmlnZ2Vyc1tpXSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICByZXR1cm47IC8vZG9uJ3QgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgaWYgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHRyaWdnZXJzIHJlZmVyZW5jaW5nIGl0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmtpbGwgPSBmdW5jdGlvbiAocmV2ZXJ0LCBhbGxvd0FuaW1hdGlvbikge1xuICAgICAgc2VsZi5kaXNhYmxlKHJldmVydCwgYWxsb3dBbmltYXRpb24pO1xuICAgICAgc2NydWJUd2VlbiAmJiAhYWxsb3dBbmltYXRpb24gJiYgc2NydWJUd2Vlbi5raWxsKCk7XG4gICAgICBpZCAmJiBkZWxldGUgX2lkc1tpZF07XG5cbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgaSA9PT0gX2kgJiYgX2RpcmVjdGlvbiA+IDAgJiYgX2ktLTsgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlZnJlc2goKSBvciB1cGRhdGUoKSwgc3BsaWNpbmcgd291bGQgY2F1c2Ugc2tpcHMgaW4gdGhlIGluZGV4LCBzbyBhZGp1c3QuLi5cbiAgICAgIC8vIGlmIG5vIG90aGVyIFNjcm9sbFRyaWdnZXIgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHNjcm9sbGVyIGFyZSBmb3VuZCwgd2lwZSBvdXQgYW55IHJlY29yZGVkIHNjcm9sbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLCBpbiBhIHNpbmdsZSBwYWdlIGFwcGxpY2F0aW9uLCBmb3IgZXhhbXBsZSwgaXQgY291bGQgbWFpbnRhaW4gc2Nyb2xsIHBvc2l0aW9uIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndC5cblxuICAgICAgaSA9IDA7XG5cbiAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnNjcm9sbGVyID09PSBzZWxmLnNjcm9sbGVyICYmIChpID0gMSk7XG4gICAgICB9KTtcblxuICAgICAgaSB8fCBfcmVmcmVzaGluZ0FsbCB8fCAoc2VsZi5zY3JvbGwucmVjID0gMCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuICAgICAgICByZXZlcnQgJiYgYW5pbWF0aW9uLnJldmVydCh7XG4gICAgICAgICAga2lsbDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5raWxsKCk7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlclN0YXJ0ICYmIFttYXJrZXJTdGFydCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ucGFyZW50Tm9kZSAmJiBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XG4gICAgICB9KTtcbiAgICAgIF9wcmltYXJ5ID09PSBzZWxmICYmIChfcHJpbWFyeSA9IDApO1xuXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQucGluID09PSBwaW4gJiYgaSsrO1xuICAgICAgICB9KTtcblxuICAgICAgICBpIHx8IChwaW5DYWNoZS5zcGFjZXIgPSAwKTsgLy8gaWYgdGhlcmUgYXJlbid0IGFueSBtb3JlIFNjcm9sbFRyaWdnZXJzIHdpdGggdGhlIHNhbWUgcGluLCByZW1vdmUgdGhlIHNwYWNlciwgb3RoZXJ3aXNlIGl0IGNvdWxkIGJlIGNvbnRhbWluYXRlZCB3aXRoIG9sZC9zdGFsZSB2YWx1ZXMgaWYgdGhlIHVzZXIgcmUtY3JlYXRlcyBhIFNjcm9sbFRyaWdnZXIgZm9yIHRoZSBzYW1lIGVsZW1lbnQuXG4gICAgICB9XG5cbiAgICAgIHZhcnMub25LaWxsICYmIHZhcnMub25LaWxsKHNlbGYpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZik7XG4gICAgIWFuaW1hdGlvbiB8fCAhYW5pbWF0aW9uLmFkZCB8fCBjaGFuZ2UgPyBzZWxmLnJlZnJlc2goKSA6IGdzYXAuZGVsYXllZENhbGwoMC4wMSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXJ0IHx8IGVuZCB8fCBzZWxmLnJlZnJlc2goKTtcbiAgICB9KSAmJiAoY2hhbmdlID0gMC4wMSkgJiYgKHN0YXJ0ID0gZW5kID0gMCk7IC8vIGlmIHRoZSBhbmltYXRpb24gaXMgYSB0aW1lbGluZSwgaXQgbWF5IG5vdCBoYXZlIGJlZW4gcG9wdWxhdGVkIHlldCwgc28gaXQgd291bGRuJ3QgcmVuZGVyIGF0IHRoZSBwcm9wZXIgcGxhY2Ugb24gdGhlIGZpcnN0IHJlZnJlc2goKSwgdGh1cyB3ZSBzaG91bGQgc2NoZWR1bGUgb25lIGZvciB0aGUgbmV4dCB0aWNrLiBJZiBcImNoYW5nZVwiIGlzIGRlZmluZWQsIHdlIGtub3cgaXQgbXVzdCBiZSByZS1lbmFibGluZywgdGh1cyB3ZSBjYW4gcmVmcmVzaCgpIHJpZ2h0IGF3YXkuXG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcbiAgICAgIF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgU2Nyb2xsVHJpZ2dlci5lbmFibGUoKTtcbiAgICAgIF9jb3JlSW5pdHRlZCA9IF9lbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGNvbmZpZykge1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XG4gICAgICAgIF9kZWZhdWx0c1twXSA9IGNvbmZpZ1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2RlZmF1bHRzO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUocmVzZXQsIGtpbGwpIHtcbiAgICBfZW5hYmxlZCA9IDA7XG5cbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgcmV0dXJuIHRyaWdnZXJba2lsbCA/IFwia2lsbFwiIDogXCJkaXNhYmxlXCJdKHJlc2V0KTtcbiAgICB9KTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcIndoZWVsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVyZG93bix0b3VjaHN0YXJ0LG1vdXNlZG93blwiLCBfcG9pbnRlckRvd25IYW5kbGVyKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICBfcmVzaXplRGVsYXkua2lsbCgpO1xuXG4gICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDFdKTtcblxuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuXG4gICAgaWYgKGdzYXApIHtcbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICAgIF9jb250ZXh0ID0gZ3NhcC5jb3JlLmNvbnRleHQgfHwgX3Bhc3NUaHJvdWdoO1xuICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcyA9IGdzYXAuY29yZS5zdXBwcmVzc092ZXJ3cml0ZXMgfHwgX3Bhc3NUaHJvdWdoO1xuICAgICAgX3Njcm9sbFJlc3RvcmF0aW9uID0gX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uIHx8IFwiYXV0b1wiO1xuICAgICAgZ3NhcC5jb3JlLmdsb2JhbHMoXCJTY3JvbGxUcmlnZ2VyXCIsIFNjcm9sbFRyaWdnZXIpOyAvLyBtdXN0IHJlZ2lzdGVyIHRoZSBnbG9iYWwgbWFudWFsbHkgYmVjYXVzZSBpbiBJbnRlcm5ldCBFeHBsb3JlciwgZnVuY3Rpb25zIChjbGFzc2VzKSBkb24ndCBoYXZlIGEgXCJuYW1lXCIgcHJvcGVydHkuXG5cbiAgICAgIGlmIChfYm9keSkge1xuICAgICAgICBfZW5hYmxlZCA9IDE7XG4gICAgICAgIE9ic2VydmVyLnJlZ2lzdGVyKGdzYXApOyAvLyBpc1RvdWNoIGlzIDAgaWYgbm8gdG91Y2gsIDEgaWYgT05MWSB0b3VjaCwgYW5kIDIgaWYgaXQgY2FuIGFjY29tbW9kYXRlIHRvdWNoIGJ1dCBhbHNvIG90aGVyIHR5cGVzIGxpa2UgbW91c2UvcG9pbnRlci5cblxuICAgICAgICBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPSBPYnNlcnZlci5pc1RvdWNoO1xuICAgICAgICBfZml4SU9TQnVnID0gT2JzZXJ2ZXIuaXNUb3VjaCAmJiAvKGlQYWR8aVBob25lfGlQb2R8TWFjKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIHNpbmNlIDIwMTcsIGlPUyBoYXMgaGFkIGEgYnVnIHRoYXQgY2F1c2VzIGV2ZW50LmNsaWVudFgvWSB0byBiZSBpbmFjY3VyYXRlIHdoZW4gYSBzY3JvbGwgb2NjdXJzLCB0aHVzIHdlIG11c3QgYWx0ZXJuYXRlIGlnbm9yaW5nIGV2ZXJ5IG90aGVyIHRvdWNobW92ZSBldmVudCB0byB3b3JrIGFyb3VuZCBpdC4gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODE5NTQgYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0V4YnJQTmEvMDg3Y2VmMTk3ZGMzNTQ0NWEwOTUxZTg5MzVjNDE1MDNcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpOyAvLyBtb3N0bHkgZm9yIDNyZCBwYXJ0eSBzbW9vdGggc2Nyb2xsaW5nIGxpYnJhcmllcy5cblxuXG4gICAgICAgIF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuXG4gICAgICAgIGlmIChnc2FwLm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICBTY3JvbGxUcmlnZ2VyLm1hdGNoTWVkaWEgPSBmdW5jdGlvbiAodmFycykge1xuICAgICAgICAgICAgdmFyIG1tID0gZ3NhcC5tYXRjaE1lZGlhKCksXG4gICAgICAgICAgICAgICAgcDtcblxuICAgICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgICAgbW0uYWRkKHAsIHZhcnNbcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbW07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFJbml0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmV2ZXJ0QWxsKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZ3NhcC5hZGRFdmVudExpc3RlbmVyKFwibWF0Y2hNZWRpYVJldmVydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JldmVydFJlY29yZGVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZ3NhcC5hZGRFdmVudExpc3RlbmVyKFwibWF0Y2hNZWRpYVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfcmVmcmVzaEFsbCgwLCAxKTtcblxuICAgICAgICAgICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnc2FwLm1hdGNoTWVkaWEoXCIob3JpZW50YXRpb246IHBvcnRyYWl0KVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB3aGVuIG9yaWVudGF0aW9uIGNoYW5nZXMsIHdlIHNob3VsZCB0YWtlIG5ldyBiYXNlIG1lYXN1cmVtZW50cyBmb3IgdGhlIGlnbm9yZU1vYmlsZVJlc2l6ZSBmZWF0dXJlLlxuICAgICAgICAgICAgX3NldEJhc2VEaW1lbnNpb25zKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfc2V0QmFzZURpbWVuc2lvbnM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiUmVxdWlyZXMgR1NBUCAzLjExLjAgb3IgbGF0ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0QmFzZURpbWVuc2lvbnMoKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUpLCB0aGUgd2luZG93IHN0b3BzIGRpc3BhdGNoaW5nIHNjcm9sbCBldmVudHMgb24gdGhlIHdpbmRvdyBpZiB5b3Ugc2Nyb2xsIHJlYWxseSBmYXN0LCBidXQgaXQncyBjb25zaXN0ZW50IG9uIHRoZSBkb2N1bWVudCFcblxuXG4gICAgICAgIHZhciBib2R5U3R5bGUgPSBfYm9keS5zdHlsZSxcbiAgICAgICAgICAgIGJvcmRlciA9IGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSxcbiAgICAgICAgICAgIEFuaW1hdGlvblByb3RvID0gZ3NhcC5jb3JlLkFuaW1hdGlvbi5wcm90b3R5cGUsXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBpO1xuICAgICAgICBBbmltYXRpb25Qcm90by5yZXZlcnQgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblByb3RvLCBcInJldmVydFwiLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZSgtMC4wMSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKEFuaW1hdGlvbi5yZXZlcnQoKSB3YXMgYWRkZWQgYWZ0ZXIgMy4xMC40KVxuXG4gICAgICAgIGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSA9IFwic29saWRcIjsgLy8gd29ya3MgYXJvdW5kIGFuIGlzc3VlIHdoZXJlIGEgbWFyZ2luIG9mIGEgY2hpbGQgZWxlbWVudCBjb3VsZCB0aHJvdyBvZmYgdGhlIGJvdW5kcyBvZiB0aGUgX2JvZHksIG1ha2luZyBpdCBzZWVtIGxpa2UgdGhlcmUncyBhIG1hcmdpbiB3aGVuIHRoZXJlIGFjdHVhbGx5IGlzbid0LiBUaGUgYm9yZGVyIGVuc3VyZXMgdGhhdCB0aGUgYm91bmRzIGFyZSBhY2N1cmF0ZS5cblxuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKF9ib2R5KTtcbiAgICAgICAgX3ZlcnRpY2FsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy50b3AgKyBfdmVydGljYWwuc2MoKSkgfHwgMDsgLy8gYWNjb21tb2RhdGUgdGhlIG9mZnNldCBvZiB0aGUgPGJvZHk+IGNhdXNlZCBieSBtYXJnaW5zIGFuZC9vciBwYWRkaW5nXG5cbiAgICAgICAgX2hvcml6b250YWwubSA9IE1hdGgucm91bmQoYm91bmRzLmxlZnQgKyBfaG9yaXpvbnRhbC5zYygpKSB8fCAwO1xuICAgICAgICBib3JkZXIgPyBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBib3JkZXIgOiBib2R5U3R5bGUucmVtb3ZlUHJvcGVydHkoXCJib3JkZXItdG9wLXN0eWxlXCIpOyAvLyBUT0RPOiAoPykgbWF5YmUgbW92ZSB0byBsZXZlcmFnaW5nIHRoZSB2ZWxvY2l0eSBtZWNoYW5pc20gaW4gT2JzZXJ2ZXIgYW5kIHNraXAgaW50ZXJ2YWxzLlxuXG4gICAgICAgIF9zeW5jSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChfc3luYywgMjUwKTtcbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3N0YXJ0dXAgPSAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpOyAvLyBzb21lIG9sZGVyIEFuZHJvaWQgZGV2aWNlcyBpbnRlcm1pdHRlbnRseSBzdG9wIGRpc3BhdGNoaW5nIFwidG91Y2htb3ZlXCIgZXZlbnRzIGlmIHdlIGRvbid0IGxpc3RlbiBmb3IgXCJ0b3VjaGNhbmNlbFwiIG9uIHRoZSBkb2N1bWVudC5cblxuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIF9wYXNzVGhyb3VnaCk7IC8vd29ya3MgYXJvdW5kIFNhZmFyaSBidWc6IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cblxuICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgX3BvaW50ZXJEb3duSGFuZGxlcik7XG5cbiAgICAgICAgX211bHRpTGlzdGVuZXIoX2FkZExpc3RlbmVyLCBfZG9jLCBcInBvaW50ZXJ1cCx0b3VjaGVuZCxtb3VzZXVwXCIsIF9wb2ludGVyVXBIYW5kbGVyKTtcblxuICAgICAgICBfdHJhbnNmb3JtUHJvcCA9IGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0cmFuc2Zvcm1cIik7XG5cbiAgICAgICAgX3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgICAgX2NvcmVJbml0dGVkID0gX2dldFRpbWUoKTtcbiAgICAgICAgX3Jlc2l6ZURlbGF5ID0gZ3NhcC5kZWxheWVkQ2FsbCgwLjIsIF9yZWZyZXNoQWxsKS5wYXVzZSgpO1xuICAgICAgICBfYXV0b1JlZnJlc2ggPSBbX2RvYywgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdyA9IF93aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgaCA9IF93aW4uaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAoX2RvYy5oaWRkZW4pIHtcbiAgICAgICAgICAgIF9wcmV2V2lkdGggPSB3O1xuICAgICAgICAgICAgX3ByZXZIZWlnaHQgPSBoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3ByZXZXaWR0aCAhPT0gdyB8fCBfcHJldkhlaWdodCAhPT0gaCkge1xuICAgICAgICAgICAgX29uUmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwibG9hZFwiLCBfcmVmcmVzaEFsbCwgX3dpbiwgXCJyZXNpemVcIiwgX29uUmVzaXplXTtcblxuICAgICAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9hZGRMaXN0ZW5lcik7XG5cbiAgICAgICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlci5lbmFibGUoMCwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAxXSk7XG5cbiAgICAgICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmNvbmZpZyA9IGZ1bmN0aW9uIGNvbmZpZyh2YXJzKSB7XG4gICAgXCJsaW1pdENhbGxiYWNrc1wiIGluIHZhcnMgJiYgKF9saW1pdENhbGxiYWNrcyA9ICEhdmFycy5saW1pdENhbGxiYWNrcyk7XG4gICAgdmFyIG1zID0gdmFycy5zeW5jSW50ZXJ2YWw7XG4gICAgbXMgJiYgY2xlYXJJbnRlcnZhbChfc3luY0ludGVydmFsKSB8fCAoX3N5bmNJbnRlcnZhbCA9IG1zKSAmJiBzZXRJbnRlcnZhbChfc3luYywgbXMpO1xuICAgIFwiaWdub3JlTW9iaWxlUmVzaXplXCIgaW4gdmFycyAmJiAoX2lnbm9yZU1vYmlsZVJlc2l6ZSA9IFNjcm9sbFRyaWdnZXIuaXNUb3VjaCA9PT0gMSAmJiB2YXJzLmlnbm9yZU1vYmlsZVJlc2l6ZSk7XG5cbiAgICBpZiAoXCJhdXRvUmVmcmVzaEV2ZW50c1wiIGluIHZhcnMpIHtcbiAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX3JlbW92ZUxpc3RlbmVyKSB8fCBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9hZGRMaXN0ZW5lciwgdmFycy5hdXRvUmVmcmVzaEV2ZW50cyB8fCBcIm5vbmVcIik7XG4gICAgICBfaWdub3JlUmVzaXplID0gKHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgKyBcIlwiKS5pbmRleE9mKFwicmVzaXplXCIpID09PSAtMTtcbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5zY3JvbGxlclByb3h5ID0gZnVuY3Rpb24gc2Nyb2xsZXJQcm94eSh0YXJnZXQsIHZhcnMpIHtcbiAgICB2YXIgdCA9IF9nZXRUYXJnZXQodGFyZ2V0KSxcbiAgICAgICAgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZih0KSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHQpO1xuXG4gICAgaWYgKH5pKSB7XG4gICAgICBfc2Nyb2xsZXJzLnNwbGljZShpLCBpc1ZpZXdwb3J0ID8gNiA6IDIpO1xuICAgIH1cblxuICAgIGlmICh2YXJzKSB7XG4gICAgICBpc1ZpZXdwb3J0ID8gX3Byb3hpZXMudW5zaGlmdChfd2luLCB2YXJzLCBfYm9keSwgdmFycywgX2RvY0VsLCB2YXJzKSA6IF9wcm94aWVzLnVuc2hpZnQodCwgdmFycyk7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuY2xlYXJNYXRjaE1lZGlhID0gZnVuY3Rpb24gY2xlYXJNYXRjaE1lZGlhKHF1ZXJ5KSB7XG4gICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0Ll9jdHggJiYgdC5fY3R4LnF1ZXJ5ID09PSBxdWVyeSAmJiB0Ll9jdHgua2lsbCh0cnVlLCB0cnVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmlzSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIGlzSW5WaWV3cG9ydChlbGVtZW50LCByYXRpbywgaG9yaXpvbnRhbCkge1xuICAgIHZhciBib3VuZHMgPSAoX2lzU3RyaW5nKGVsZW1lbnQpID8gX2dldFRhcmdldChlbGVtZW50KSA6IGVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBvZmZzZXQgPSBib3VuZHNbaG9yaXpvbnRhbCA/IF93aWR0aCA6IF9oZWlnaHRdICogcmF0aW8gfHwgMDtcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IGJvdW5kcy5yaWdodCAtIG9mZnNldCA+IDAgJiYgYm91bmRzLmxlZnQgKyBvZmZzZXQgPCBfd2luLmlubmVyV2lkdGggOiBib3VuZHMuYm90dG9tIC0gb2Zmc2V0ID4gMCAmJiBib3VuZHMudG9wICsgb2Zmc2V0IDwgX3dpbi5pbm5lckhlaWdodDtcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLnBvc2l0aW9uSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIHBvc2l0aW9uSW5WaWV3cG9ydChlbGVtZW50LCByZWZlcmVuY2VQb2ludCwgaG9yaXpvbnRhbCkge1xuICAgIF9pc1N0cmluZyhlbGVtZW50KSAmJiAoZWxlbWVudCA9IF9nZXRUYXJnZXQoZWxlbWVudCkpO1xuICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBzaXplID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSxcbiAgICAgICAgb2Zmc2V0ID0gcmVmZXJlbmNlUG9pbnQgPT0gbnVsbCA/IHNpemUgLyAyIDogcmVmZXJlbmNlUG9pbnQgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3JlZmVyZW5jZVBvaW50XSAqIHNpemUgOiB+cmVmZXJlbmNlUG9pbnQuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHJlZmVyZW5jZVBvaW50KSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHJlZmVyZW5jZVBvaW50KSB8fCAwO1xuICAgIHJldHVybiBob3Jpem9udGFsID8gKGJvdW5kcy5sZWZ0ICsgb2Zmc2V0KSAvIF93aW4uaW5uZXJXaWR0aCA6IChib3VuZHMudG9wICsgb2Zmc2V0KSAvIF93aW4uaW5uZXJIZWlnaHQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5raWxsQWxsID0gZnVuY3Rpb24ga2lsbEFsbChhbGxvd0xpc3RlbmVycykge1xuICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC52YXJzLmlkICE9PSBcIlNjcm9sbFNtb290aGVyXCIgJiYgdC5raWxsKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoYWxsb3dMaXN0ZW5lcnMgIT09IHRydWUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzLmtpbGxBbGwgfHwgW107XG4gICAgICBfbGlzdGVuZXJzID0ge307XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTY3JvbGxUcmlnZ2VyO1xufSgpO1xuU2Nyb2xsVHJpZ2dlci52ZXJzaW9uID0gXCIzLjExLjJcIjtcblxuU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgcmV0dXJuIHRhcmdldHMgPyBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAvLyBzYXZlZCBzdHlsZXMgYXJlIHJlY29yZGVkIGluIGEgY29uc2VjdXRpdmUgYWx0ZXJuYXRpbmcgQXJyYXksIGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIGNhY2hlLCBtYXRjaE1lZGlhLCAuLi5dXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuc3R5bGUpIHtcbiAgICAgIHZhciBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaSA+PSAwICYmIF9zYXZlZFN0eWxlcy5zcGxpY2UoaSwgNSk7XG5cbiAgICAgIF9zYXZlZFN0eWxlcy5wdXNoKHRhcmdldCwgdGFyZ2V0LnN0eWxlLmNzc1RleHQsIHRhcmdldC5nZXRCQm94ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksIGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLCBfY29udGV4dCgpKTtcbiAgICB9XG4gIH0pIDogX3NhdmVkU3R5bGVzO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZXZlcnQgPSBmdW5jdGlvbiAoc29mdCwgbWVkaWEpIHtcbiAgcmV0dXJuIF9yZXZlcnRBbGwoIXNvZnQsIG1lZGlhKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuY3JlYXRlID0gZnVuY3Rpb24gKHZhcnMsIGFuaW1hdGlvbikge1xuICByZXR1cm4gbmV3IFNjcm9sbFRyaWdnZXIodmFycywgYW5pbWF0aW9uKTtcbn07XG5cblNjcm9sbFRyaWdnZXIucmVmcmVzaCA9IGZ1bmN0aW9uIChzYWZlKSB7XG4gIHJldHVybiBzYWZlID8gX29uUmVzaXplKCkgOiAoX2NvcmVJbml0dGVkIHx8IFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIoKSkgJiYgX3JlZnJlc2hBbGwodHJ1ZSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnVwZGF0ZSA9IF91cGRhdGVBbGw7XG5TY3JvbGxUcmlnZ2VyLmNsZWFyU2Nyb2xsTWVtb3J5ID0gX2NsZWFyU2Nyb2xsTWVtb3J5O1xuXG5TY3JvbGxUcmlnZ2VyLm1heFNjcm9sbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBob3Jpem9udGFsKSB7XG4gIHJldHVybiBfbWF4U2Nyb2xsKGVsZW1lbnQsIGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldFNjcm9sbEZ1bmMgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xuICByZXR1cm4gX2dldFNjcm9sbEZ1bmMoX2dldFRhcmdldChlbGVtZW50KSwgaG9yaXpvbnRhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gX2lkc1tpZF07XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF90cmlnZ2Vycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC52YXJzLmlkICE9PSBcIlNjcm9sbFNtb290aGVyXCI7XG4gIH0pO1xufTsgLy8gaXQncyBjb21tb24gZm9yIHBlb3BsZSB0byBTY3JvbGxUcmlnZ2VyLmdldEFsbCh0ID0+IHQua2lsbCgpKSBvbiBwYWdlIHJvdXRlcywgZm9yIGV4YW1wbGUsIGFuZCB3ZSBkb24ndCB3YW50IGl0IHRvIHJ1aW4gc21vb3RoIHNjcm9sbGluZyBieSBraWxsaW5nIHRoZSBtYWluIFNjcm9sbFNtb290aGVyIG9uZS5cblxuXG5TY3JvbGxUcmlnZ2VyLmlzU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISFfbGFzdFNjcm9sbFRpbWU7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnNuYXBEaXJlY3Rpb25hbCA9IF9zbmFwRGlyZWN0aW9uYWw7XG5cblNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0gfHwgKF9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gIH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgaSA9IGEgJiYgYS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5iYXRjaCA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHZhcnNDb3B5ID0ge30sXG4gICAgICBpbnRlcnZhbCA9IHZhcnMuaW50ZXJ2YWwgfHwgMC4wMTYsXG4gICAgICBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXggfHwgMWU5LFxuICAgICAgcHJveHlDYWxsYmFjayA9IGZ1bmN0aW9uIHByb3h5Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXSxcbiAgICAgICAgdHJpZ2dlcnMgPSBbXSxcbiAgICAgICAgZGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKGludGVydmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlbGVtZW50cywgdHJpZ2dlcnMpO1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgIHRyaWdnZXJzID0gW107XG4gICAgfSkucGF1c2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgIGVsZW1lbnRzLmxlbmd0aCB8fCBkZWxheS5yZXN0YXJ0KHRydWUpO1xuICAgICAgZWxlbWVudHMucHVzaChzZWxmLnRyaWdnZXIpO1xuICAgICAgdHJpZ2dlcnMucHVzaChzZWxmKTtcbiAgICAgIGJhdGNoTWF4IDw9IGVsZW1lbnRzLmxlbmd0aCAmJiBkZWxheS5wcm9ncmVzcygxKTtcbiAgICB9O1xuICB9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIHZhcnNDb3B5W3BdID0gcC5zdWJzdHIoMCwgMikgPT09IFwib25cIiAmJiBfaXNGdW5jdGlvbih2YXJzW3BdKSAmJiBwICE9PSBcIm9uUmVmcmVzaEluaXRcIiA/IHByb3h5Q2FsbGJhY2socCwgdmFyc1twXSkgOiB2YXJzW3BdO1xuICB9XG5cbiAgaWYgKF9pc0Z1bmN0aW9uKGJhdGNoTWF4KSkge1xuICAgIGJhdGNoTWF4ID0gYmF0Y2hNYXgoKTtcblxuICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RvQXJyYXkodGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgZm9yIChwIGluIHZhcnNDb3B5KSB7XG4gICAgICBjb25maWdbcF0gPSB2YXJzQ29weVtwXTtcbiAgICB9XG5cbiAgICBjb25maWcudHJpZ2dlciA9IHRhcmdldDtcbiAgICByZXN1bHQucHVzaChTY3JvbGxUcmlnZ2VyLmNyZWF0ZShjb25maWcpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07IC8vIHRvIHJlZHVjZSBmaWxlIHNpemUuIGNsYW1wcyB0aGUgc2Nyb2xsIGFuZCBhbHNvIHJldHVybnMgYSBkdXJhdGlvbiBtdWx0aXBsaWVyIHNvIHRoYXQgaWYgdGhlIHNjcm9sbCBnZXRzIGNob3BwZWQgc2hvcnRlciwgdGhlIGR1cmF0aW9uIGdldHMgY3VydGFpbGVkIGFzIHdlbGwgKG90aGVyd2lzZSBpZiB5b3UncmUgdmVyeSBjbG9zZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLCBmb3IgZXhhbXBsZSwgYW5kIHN3aXBlIHVwIHJlYWxseSBmYXN0LCBpdCdsbCBzdWRkZW5seSBzbG93IGRvd24gYW5kIHRha2UgYSBsb25nIHRpbWUgdG8gcmVhY2ggdGhlIHRvcCkuXG5cblxudmFyIF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllciA9IGZ1bmN0aW9uIF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllcihzY3JvbGxGdW5jLCBjdXJyZW50LCBlbmQsIG1heCkge1xuICBjdXJyZW50ID4gbWF4ID8gc2Nyb2xsRnVuYyhtYXgpIDogY3VycmVudCA8IDAgJiYgc2Nyb2xsRnVuYygwKTtcbiAgcmV0dXJuIGVuZCA+IG1heCA/IChtYXggLSBjdXJyZW50KSAvIChlbmQgLSBjdXJyZW50KSA6IGVuZCA8IDAgPyBjdXJyZW50IC8gKGN1cnJlbnQgLSBlbmQpIDogMTtcbn0sXG4gICAgX2FsbG93TmF0aXZlUGFubmluZyA9IGZ1bmN0aW9uIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRvdWNoLWFjdGlvblwiKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuc3R5bGUudG91Y2hBY3Rpb24gPSBkaXJlY3Rpb24gPT09IHRydWUgPyBcImF1dG9cIiA6IGRpcmVjdGlvbiA/IFwicGFuLVwiICsgZGlyZWN0aW9uICsgKE9ic2VydmVyLmlzVG91Y2ggPyBcIiBwaW5jaC16b29tXCIgOiBcIlwiKSA6IFwibm9uZVwiOyAvLyBub3RlOiBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBpdCBwaW5jaC16b29tIHByb3Blcmx5LCBhdCBsZWFzdCBpbiBhZGRpdGlvbiB0byBhIHBhbi14IG9yIHBhbi15LlxuICB9XG5cbiAgdGFyZ2V0ID09PSBfZG9jRWwgJiYgX2FsbG93TmF0aXZlUGFubmluZyhfYm9keSwgZGlyZWN0aW9uKTtcbn0sXG4gICAgX292ZXJmbG93ID0ge1xuICBhdXRvOiAxLFxuICBzY3JvbGw6IDFcbn0sXG4gICAgX25lc3RlZFNjcm9sbCA9IGZ1bmN0aW9uIF9uZXN0ZWRTY3JvbGwoX3JlZjUpIHtcbiAgdmFyIGV2ZW50ID0gX3JlZjUuZXZlbnQsXG4gICAgICB0YXJnZXQgPSBfcmVmNS50YXJnZXQsXG4gICAgICBheGlzID0gX3JlZjUuYXhpcztcblxuICB2YXIgbm9kZSA9IChldmVudC5jaGFuZ2VkVG91Y2hlcyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQpLnRhcmdldCxcbiAgICAgIGNhY2hlID0gbm9kZS5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUobm9kZSksXG4gICAgICB0aW1lID0gX2dldFRpbWUoKSxcbiAgICAgIGNzO1xuXG4gIGlmICghY2FjaGUuX2lzU2Nyb2xsVCB8fCB0aW1lIC0gY2FjaGUuX2lzU2Nyb2xsVCA+IDIwMDApIHtcbiAgICAvLyBjYWNoZSBmb3IgMiBzZWNvbmRzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5zY3JvbGxIZWlnaHQgPD0gbm9kZS5jbGllbnRIZWlnaHQpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgY2FjaGUuX2lzU2Nyb2xsID0gbm9kZSAmJiAhX2lzVmlld3BvcnQobm9kZSkgJiYgbm9kZSAhPT0gdGFyZ2V0ICYmIChfb3ZlcmZsb3dbKGNzID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSkpLm92ZXJmbG93WV0gfHwgX292ZXJmbG93W2NzLm92ZXJmbG93WF0pO1xuICAgIGNhY2hlLl9pc1Njcm9sbFQgPSB0aW1lO1xuICB9XG5cbiAgaWYgKGNhY2hlLl9pc1Njcm9sbCB8fCBheGlzID09PSBcInhcIikge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50Ll9nc2FwQWxsb3cgPSB0cnVlO1xuICB9XG59LFxuICAgIC8vIGNhcHR1cmUgZXZlbnRzIG9uIHNjcm9sbGFibGUgZWxlbWVudHMgSU5TSURFIHRoZSA8Ym9keT4gYW5kIGFsbG93IHRob3NlIGJ5IGNhbGxpbmcgc3RvcFByb3BhZ2F0aW9uKCkgd2hlbiB3ZSBmaW5kIGEgc2Nyb2xsYWJsZSBhbmNlc3RvclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XG4gIHJldHVybiBPYnNlcnZlci5jcmVhdGUoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGVib3VuY2U6IGZhbHNlLFxuICAgIGxvY2tBeGlzOiB0cnVlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgb25XaGVlbDogbmVzdGVkID0gbmVzdGVkICYmIF9uZXN0ZWRTY3JvbGwsXG4gICAgb25QcmVzczogbmVzdGVkLFxuICAgIG9uRHJhZzogbmVzdGVkLFxuICAgIG9uU2Nyb2xsOiBuZXN0ZWQsXG4gICAgb25FbmFibGU6IGZ1bmN0aW9uIG9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gb25EaXNhYmxlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0sXG4gICAgX2lucHV0RXhwID0gLyhpbnB1dHxsYWJlbHxzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgX2lucHV0SXNGb2N1c2VkLFxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xuICB2YXIgaXNJbnB1dCA9IF9pbnB1dEV4cC50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xuICAgIGUuX2dzYXBBbGxvdyA9IHRydWU7XG4gICAgX2lucHV0SXNGb2N1c2VkID0gaXNJbnB1dDtcbiAgfVxufSxcbiAgICBfZ2V0U2Nyb2xsTm9ybWFsaXplciA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpIHtcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xuICB2YXJzLnByZXZlbnREZWZhdWx0ID0gdmFycy5pc05vcm1hbGl6ZXIgPSB2YXJzLmFsbG93Q2xpY2tzID0gdHJ1ZTtcbiAgdmFycy50eXBlIHx8ICh2YXJzLnR5cGUgPSBcIndoZWVsLHRvdWNoXCIpO1xuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xuICB2YXJzLmlkID0gdmFycy5pZCB8fCBcIm5vcm1hbGl6ZXJcIjtcblxuICB2YXIgX3ZhcnMyID0gdmFycyxcbiAgICAgIG5vcm1hbGl6ZVNjcm9sbFggPSBfdmFyczIubm9ybWFsaXplU2Nyb2xsWCxcbiAgICAgIG1vbWVudHVtID0gX3ZhcnMyLm1vbWVudHVtLFxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXG4gICAgICBzZWxmLFxuICAgICAgbWF4WSxcbiAgICAgIHRhcmdldCA9IF9nZXRUYXJnZXQodmFycy50YXJnZXQpIHx8IF9kb2NFbCxcbiAgICAgIHNtb290aGVyID0gZ3NhcC5jb3JlLmdsb2JhbHMoKS5TY3JvbGxTbW9vdGhlcixcbiAgICAgIHNtb290aGVySW5zdGFuY2UgPSBzbW9vdGhlciAmJiBzbW9vdGhlci5nZXQoKSxcbiAgICAgIGNvbnRlbnQgPSBfZml4SU9TQnVnICYmICh2YXJzLmNvbnRlbnQgJiYgX2dldFRhcmdldCh2YXJzLmNvbnRlbnQpIHx8IHNtb290aGVySW5zdGFuY2UgJiYgdmFycy5jb250ZW50ICE9PSBmYWxzZSAmJiAhc21vb3RoZXJJbnN0YW5jZS5zbW9vdGgoKSAmJiBzbW9vdGhlckluc3RhbmNlLmNvbnRlbnQoKSksXG4gICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICBzY2FsZSA9IDEsXG4gICAgICBpbml0aWFsU2NhbGUgPSAoT2JzZXJ2ZXIuaXNUb3VjaCAmJiBfd2luLnZpc3VhbFZpZXdwb3J0ID8gX3dpbi52aXN1YWxWaWV3cG9ydC5zY2FsZSAqIF93aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiBfd2luLm91dGVyV2lkdGgpIC8gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgd2hlZWxSZWZyZXNoID0gMCxcbiAgICAgIHJlc29sdmVNb21lbnR1bUR1cmF0aW9uID0gX2lzRnVuY3Rpb24obW9tZW50dW0pID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtb21lbnR1bShzZWxmKTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0gfHwgMi44O1xuICB9LFxuICAgICAgbGFzdFJlZnJlc2hJRCxcbiAgICAgIHNraXBUb3VjaE1vdmUsXG4gICAgICBpbnB1dE9ic2VydmVyID0gX2lucHV0T2JzZXJ2ZXIodGFyZ2V0LCB2YXJzLnR5cGUsIHRydWUsIGFsbG93TmVzdGVkU2Nyb2xsKSxcbiAgICAgIHJlc3VtZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIHJlc3VtZVRvdWNoTW92ZSgpIHtcbiAgICByZXR1cm4gc2tpcFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9LFxuICAgICAgc2Nyb2xsQ2xhbXBYID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgc2Nyb2xsQ2xhbXBZID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgdXBkYXRlQ2xhbXBzID0gZnVuY3Rpb24gdXBkYXRlQ2xhbXBzKCkge1xuICAgIG1heFkgPSBfbWF4U2Nyb2xsKHRhcmdldCwgX3ZlcnRpY2FsKTtcbiAgICBzY3JvbGxDbGFtcFkgPSBfY2xhbXAoX2ZpeElPU0J1ZyA/IDEgOiAwLCBtYXhZKTtcbiAgICBub3JtYWxpemVTY3JvbGxYICYmIChzY3JvbGxDbGFtcFggPSBfY2xhbXAoMCwgX21heFNjcm9sbCh0YXJnZXQsIF9ob3Jpem9udGFsKSkpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9LFxuICAgICAgcmVtb3ZlQ29udGVudE9mZnNldCA9IGZ1bmN0aW9uIHJlbW92ZUNvbnRlbnRPZmZzZXQoKSB7XG4gICAgY29udGVudC5fZ3NhcC55ID0gX3JvdW5kKHBhcnNlRmxvYXQoY29udGVudC5fZ3NhcC55KSArIHNjcm9sbEZ1bmNZLm9mZnNldCkgKyBcInB4XCI7XG4gICAgY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgcGFyc2VGbG9hdChjb250ZW50Ll9nc2FwLnkpICsgXCIsIDAsIDEpXCI7XG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ID0gc2Nyb2xsRnVuY1kuY2FjaGVJRCA9IDA7XG4gIH0sXG4gICAgICBpZ25vcmVEcmFnID0gZnVuY3Rpb24gaWdub3JlRHJhZygpIHtcbiAgICBpZiAoc2tpcFRvdWNoTW92ZSkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZVRvdWNoTW92ZSk7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBfcm91bmQoc2VsZi5kZWx0YVkgLyAyKSxcbiAgICAgICAgICBzY3JvbGwgPSBzY3JvbGxDbGFtcFkoc2Nyb2xsRnVuY1kudiAtIG9mZnNldCk7XG5cbiAgICAgIGlmIChjb250ZW50ICYmIHNjcm9sbCAhPT0gc2Nyb2xsRnVuY1kudiArIHNjcm9sbEZ1bmNZLm9mZnNldCkge1xuICAgICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGwgLSBzY3JvbGxGdW5jWS52O1xuXG4gICAgICAgIHZhciB5ID0gX3JvdW5kKChwYXJzZUZsb2F0KGNvbnRlbnQgJiYgY29udGVudC5fZ3NhcC55KSB8fCAwKSAtIHNjcm9sbEZ1bmNZLm9mZnNldCk7XG5cbiAgICAgICAgY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgeSArIFwiLCAwLCAxKVwiO1xuICAgICAgICBjb250ZW50Ll9nc2FwLnkgPSB5ICsgXCJweFwiO1xuICAgICAgICBzY3JvbGxGdW5jWS5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcblxuICAgICAgICBfdXBkYXRlQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNjcm9sbEZ1bmNZLm9mZnNldCAmJiByZW1vdmVDb250ZW50T2Zmc2V0KCk7XG4gICAgc2tpcFRvdWNoTW92ZSA9IHRydWU7XG4gIH0sXG4gICAgICB0d2VlbixcbiAgICAgIHN0YXJ0U2Nyb2xsWCxcbiAgICAgIHN0YXJ0U2Nyb2xsWSxcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLFxuICAgICAgb25SZXNpemUgPSBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAvLyBpZiB0aGUgd2luZG93IHJlc2l6ZXMsIGxpa2Ugb24gYW4gaVBob25lIHdoaWNoIEFwcGxlIEZPUkNFUyB0aGUgYWRkcmVzcyBiYXIgdG8gc2hvdy9oaWRlIGV2ZW4gaWYgd2UgZXZlbnQucHJldmVudERlZmF1bHQoKSwgaXQgbWF5IGJlIHNjcm9sbGluZyB0b28gZmFyIG5vdyB0aGF0IHRoZSBhZGRyZXNzIGJhciBpcyBzaG93aW5nLCBzbyB3ZSBtdXN0IGR5bmFtaWNhbGx5IGFkanVzdCB0aGUgbW9tZW50dW0gdHdlZW4uXG4gICAgdXBkYXRlQ2xhbXBzKCk7XG5cbiAgICBpZiAodHdlZW4uaXNBY3RpdmUoKSAmJiB0d2Vlbi52YXJzLnNjcm9sbFkgPiBtYXhZKSB7XG4gICAgICBzY3JvbGxGdW5jWSgpID4gbWF4WSA/IHR3ZWVuLnByb2dyZXNzKDEpICYmIHNjcm9sbEZ1bmNZKG1heFkpIDogdHdlZW4ucmVzZXRUbyhcInNjcm9sbFlcIiwgbWF4WSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnRlbnQgJiYgZ3NhcC5zZXQoY29udGVudCwge1xuICAgIHk6IFwiKz0wXCJcbiAgfSk7IC8vIHRvIGVuc3VyZSB0aGVyZSdzIGEgY2FjaGUgKGVsZW1lbnQuX2dzYXApXG5cbiAgdmFycy5pZ25vcmVDaGVjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIF9maXhJT1NCdWcgJiYgZS50eXBlID09PSBcInRvdWNobW92ZVwiICYmIGlnbm9yZURyYWcoZSkgfHwgc2NhbGUgPiAxLjA1ICYmIGUudHlwZSAhPT0gXCJ0b3VjaHN0YXJ0XCIgfHwgc2VsZi5pc0dlc3R1cmluZyB8fCBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDE7XG4gIH07XG5cbiAgdmFycy5vblByZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2U2NhbGUgPSBzY2FsZTtcbiAgICBzY2FsZSA9IF9yb3VuZCgoX3dpbi52aXN1YWxWaWV3cG9ydCAmJiBfd2luLnZpc3VhbFZpZXdwb3J0LnNjYWxlIHx8IDEpIC8gaW5pdGlhbFNjYWxlKTtcbiAgICB0d2Vlbi5wYXVzZSgpO1xuICAgIHByZXZTY2FsZSAhPT0gc2NhbGUgJiYgX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIHNjYWxlID4gMS4wMSA/IHRydWUgOiBub3JtYWxpemVTY3JvbGxYID8gZmFsc2UgOiBcInhcIik7XG4gICAgc3RhcnRTY3JvbGxYID0gc2Nyb2xsRnVuY1goKTtcbiAgICBzdGFydFNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpO1xuICAgIHVwZGF0ZUNsYW1wcygpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9O1xuXG4gIHZhcnMub25SZWxlYXNlID0gdmFycy5vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIChzZWxmLCB3YXNEcmFnZ2luZykge1xuICAgIHNjcm9sbEZ1bmNZLm9mZnNldCAmJiByZW1vdmVDb250ZW50T2Zmc2V0KCk7XG5cbiAgICBpZiAoIXdhc0RyYWdnaW5nKSB7XG4gICAgICBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7IC8vIG1ha2Ugc3VyZSB3ZSdyZSBwdWxsaW5nIHRoZSBub24tY2FjaGVkIHZhbHVlXG4gICAgICAvLyBhbHRlcm5hdGUgYWxnb3JpdGhtOiBkdXJYID0gTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVggLyA4MDApKSxcdGR1ciA9IE1hdGgubWF4KGR1clgsIE1hdGgubWluKDYsIE1hdGguYWJzKHNlbGYudmVsb2NpdHlZIC8gODAwKSkpOyBkdXIgPSBkdXIgKiAoMC40ICsgKDEgLSBfcG93ZXI0SW4oZHVyIC8gNikpICogMC42KSkgKiAobW9tZW50dW1TcGVlZCB8fCAxKVxuXG4gICAgICB2YXIgZHVyID0gcmVzb2x2ZU1vbWVudHVtRHVyYXRpb24oKSxcbiAgICAgICAgICBjdXJyZW50U2Nyb2xsLFxuICAgICAgICAgIGVuZFNjcm9sbDtcblxuICAgICAgaWYgKG5vcm1hbGl6ZVNjcm9sbFgpIHtcbiAgICAgICAgY3VycmVudFNjcm9sbCA9IHNjcm9sbEZ1bmNYKCk7XG4gICAgICAgIGVuZFNjcm9sbCA9IGN1cnJlbnRTY3JvbGwgKyBkdXIgKiAwLjA1ICogLXNlbGYudmVsb2NpdHlYIC8gMC4yMjc7IC8vIHRoZSBjb25zdGFudCAuMjI3IGlzIGZyb20gcG93ZXI0KDAuMDUpLiB2ZWxvY2l0eSBpcyBpbnZlcnRlZCBiZWNhdXNlIHNjcm9sbGluZyBnb2VzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG5cbiAgICAgICAgZHVyICo9IF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllcihzY3JvbGxGdW5jWCwgY3VycmVudFNjcm9sbCwgZW5kU2Nyb2xsLCBfbWF4U2Nyb2xsKHRhcmdldCwgX2hvcml6b250YWwpKTtcbiAgICAgICAgdHdlZW4udmFycy5zY3JvbGxYID0gc2Nyb2xsQ2xhbXBYKGVuZFNjcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTY3JvbGwgPSBzY3JvbGxGdW5jWSgpO1xuICAgICAgZW5kU2Nyb2xsID0gY3VycmVudFNjcm9sbCArIGR1ciAqIDAuMDUgKiAtc2VsZi52ZWxvY2l0eVkgLyAwLjIyNzsgLy8gdGhlIGNvbnN0YW50IC4yMjcgaXMgZnJvbSBwb3dlcjQoMC4wNSlcblxuICAgICAgZHVyICo9IF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllcihzY3JvbGxGdW5jWSwgY3VycmVudFNjcm9sbCwgZW5kU2Nyb2xsLCBfbWF4U2Nyb2xsKHRhcmdldCwgX3ZlcnRpY2FsKSk7XG4gICAgICB0d2Vlbi52YXJzLnNjcm9sbFkgPSBzY3JvbGxDbGFtcFkoZW5kU2Nyb2xsKTtcbiAgICAgIHR3ZWVuLmludmFsaWRhdGUoKS5kdXJhdGlvbihkdXIpLnBsYXkoMC4wMSk7XG5cbiAgICAgIGlmIChfZml4SU9TQnVnICYmIHR3ZWVuLnZhcnMuc2Nyb2xsWSA+PSBtYXhZIHx8IGN1cnJlbnRTY3JvbGwgPj0gbWF4WSAtIDEpIHtcbiAgICAgICAgLy8gaU9TIGJ1ZzogaXQnbGwgc2hvdyB0aGUgYWRkcmVzcyBiYXIgYnV0IE5PVCBmaXJlIHRoZSB3aW5kb3cgXCJyZXNpemVcIiBldmVudCB1bnRpbCB0aGUgYW5pbWF0aW9uIGlzIGRvbmUgYnV0IHdlIG11c3QgcHJvdGVjdCBhZ2FpbnN0IG92ZXJzaG9vdCBzbyB3ZSBsZXZlcmFnZSBhbiBvblVwZGF0ZSB0byBkbyBzby5cbiAgICAgICAgZ3NhcC50byh7fSwge1xuICAgICAgICAgIG9uVXBkYXRlOiBvblJlc2l6ZSxcbiAgICAgICAgICBkdXJhdGlvbjogZHVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXJzLm9uV2hlZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHdlZW4uX3RzICYmIHR3ZWVuLnBhdXNlKCk7XG5cbiAgICBpZiAoX2dldFRpbWUoKSAtIHdoZWVsUmVmcmVzaCA+IDEwMDApIHtcbiAgICAgIC8vIGFmdGVyIDEgc2Vjb25kLCByZWZyZXNoIHRoZSBjbGFtcHMgb3RoZXJ3aXNlIHRoYXQnbGwgb25seSBoYXBwZW4gd2hlbiBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSBpcyBjYWxsZWQgb3IgZm9yIHRvdWNoLXNjcm9sbGluZy5cbiAgICAgIGxhc3RSZWZyZXNoSUQgPSAwO1xuICAgICAgd2hlZWxSZWZyZXNoID0gX2dldFRpbWUoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFycy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChzZWxmLCBkeCwgZHksIHhBcnJheSwgeUFycmF5KSB7XG4gICAgX3JlZnJlc2hJRCAhPT0gbGFzdFJlZnJlc2hJRCAmJiB1cGRhdGVDbGFtcHMoKTtcbiAgICBkeCAmJiBub3JtYWxpemVTY3JvbGxYICYmIHNjcm9sbEZ1bmNYKHNjcm9sbENsYW1wWCh4QXJyYXlbMl0gPT09IGR4ID8gc3RhcnRTY3JvbGxYICsgKHNlbGYuc3RhcnRYIC0gc2VsZi54KSA6IHNjcm9sbEZ1bmNYKCkgKyBkeCAtIHhBcnJheVsxXSkpOyAvLyBmb3IgbW9yZSBwcmVjaXNpb24sIHdlIHRyYWNrIHBvaW50ZXIvdG91Y2ggbW92ZW1lbnQgZnJvbSB0aGUgc3RhcnQsIG90aGVyd2lzZSBpdCdsbCBkcmlmdC5cblxuICAgIGlmIChkeSkge1xuICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcbiAgICAgIHZhciBpc1RvdWNoID0geUFycmF5WzJdID09PSBkeSxcbiAgICAgICAgICB5ID0gaXNUb3VjaCA/IHN0YXJ0U2Nyb2xsWSArIHNlbGYuc3RhcnRZIC0gc2VsZi55IDogc2Nyb2xsRnVuY1koKSArIGR5IC0geUFycmF5WzFdLFxuICAgICAgICAgIHlDbGFtcGVkID0gc2Nyb2xsQ2xhbXBZKHkpO1xuICAgICAgaXNUb3VjaCAmJiB5ICE9PSB5Q2xhbXBlZCAmJiAoc3RhcnRTY3JvbGxZICs9IHlDbGFtcGVkIC0geSk7XG4gICAgICBzY3JvbGxGdW5jWSh5Q2xhbXBlZCk7XG4gICAgfVxuXG4gICAgKGR5IHx8IGR4KSAmJiBfdXBkYXRlQWxsKCk7XG4gIH07XG5cbiAgdmFycy5vbkVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuXG4gICAgU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwicmVmcmVzaFwiLCBvblJlc2l6ZSk7XG5cbiAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJyZXNpemVcIiwgb25SZXNpemUpO1xuXG4gICAgaWYgKHNjcm9sbEZ1bmNZLnNtb290aCkge1xuICAgICAgc2Nyb2xsRnVuY1kudGFyZ2V0LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgICBzY3JvbGxGdW5jWS5zbW9vdGggPSBzY3JvbGxGdW5jWC5zbW9vdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpbnB1dE9ic2VydmVyLmVuYWJsZSgpO1xuICB9O1xuXG4gIHZhcnMub25EaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCB0cnVlKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG5cbiAgICBTY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWZyZXNoXCIsIG9uUmVzaXplKTtcbiAgICBpbnB1dE9ic2VydmVyLmtpbGwoKTtcbiAgfTtcblxuICB2YXJzLmxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyAhPT0gZmFsc2U7XG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XG4gIHNlbGYuaU9TID0gX2ZpeElPU0J1ZzsgLy8gdXNlZCBpbiB0aGUgT2JzZXJ2ZXIgZ2V0Q2FjaGVkU2Nyb2xsKCkgZnVuY3Rpb24gdG8gd29yayBhcm91bmQgYW4gaU9TIGJ1ZyB0aGF0IHdyZWFrcyBoYXZvYyB3aXRoIFRvdWNoRXZlbnQuY2xpZW50WSBpZiB3ZSBhbGxvdyBzY3JvbGwgdG8gZ28gYWxsIHRoZSB3YXkgYmFjayB0byAwLlxuXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxuXG4gIF9maXhJT1NCdWcgJiYgZ3NhcC50aWNrZXIuYWRkKF9wYXNzVGhyb3VnaCk7IC8vIHByZXZlbnQgdGhlIHRpY2tlciBmcm9tIHNsZWVwaW5nXG5cbiAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYztcbiAgdHdlZW4gPSBnc2FwLnRvKHNlbGYsIHtcbiAgICBlYXNlOiBcInBvd2VyNFwiLFxuICAgIHBhdXNlZDogdHJ1ZSxcbiAgICBzY3JvbGxYOiBub3JtYWxpemVTY3JvbGxYID8gXCIrPTAuMVwiIDogXCIrPTBcIixcbiAgICBzY3JvbGxZOiBcIis9MC4xXCIsXG4gICAgb25Db21wbGV0ZTogb25TdG9wRGVsYXllZENhbGwudmFycy5vbkNvbXBsZXRlXG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn07XG5cblNjcm9sbFRyaWdnZXIuc29ydCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuc29ydChmdW5jIHx8IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChhLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNiArIGEuc3RhcnQgLSAoYi5zdGFydCArIChiLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNik7XG4gIH0pO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5vYnNlcnZlID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcih2YXJzKTtcbn07XG5cblNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgaWYgKHR5cGVvZiB2YXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVyO1xuICB9XG5cbiAgaWYgKHZhcnMgPT09IHRydWUgJiYgX25vcm1hbGl6ZXIpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZXIuZW5hYmxlKCk7XG4gIH1cblxuICBpZiAodmFycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIua2lsbCgpO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZXIgPSB2YXJzIGluc3RhbmNlb2YgT2JzZXJ2ZXIgPyB2YXJzIDogX2dldFNjcm9sbE5vcm1hbGl6ZXIodmFycyk7XG4gIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLnRhcmdldCA9PT0gbm9ybWFsaXplci50YXJnZXQgJiYgX25vcm1hbGl6ZXIua2lsbCgpO1xuICBfaXNWaWV3cG9ydChub3JtYWxpemVyLnRhcmdldCkgJiYgKF9ub3JtYWxpemVyID0gbm9ybWFsaXplcik7XG4gIHJldHVybiBub3JtYWxpemVyO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jb3JlID0ge1xuICAvLyBzbWFsbGVyIGZpbGUgc2l6ZSB3YXkgdG8gbGV2ZXJhZ2UgaW4gU2Nyb2xsU21vb3RoZXIgYW5kIE9ic2VydmVyXG4gIF9nZXRWZWxvY2l0eVByb3A6IF9nZXRWZWxvY2l0eVByb3AsXG4gIF9pbnB1dE9ic2VydmVyOiBfaW5wdXRPYnNlcnZlcixcbiAgX3Njcm9sbGVyczogX3Njcm9sbGVycyxcbiAgX3Byb3hpZXM6IF9wcm94aWVzLFxuICBicmlkZ2U6IHtcbiAgICAvLyB3aGVuIG5vcm1hbGl6ZVNjcm9sbCBzZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gKHNzID0gc2V0U2Nyb2xsKVxuICAgIHNzOiBmdW5jdGlvbiBzcygpIHtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAvLyBhIHdheSB0byBnZXQgdGhlIF9yZWZyZXNoaW5nIHZhbHVlIGluIE9ic2VydmVyXG4gICAgcmVmOiBmdW5jdGlvbiByZWYoKSB7XG4gICAgICByZXR1cm4gX3JlZnJlc2hpbmc7XG4gICAgfVxuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuZXhwb3J0IHsgU2Nyb2xsVHJpZ2dlciBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/ScrollTrigger.js\n"));

/***/ }),

/***/ "./node_modules/gsap/TextPlugin.js":
/*!*****************************************!*\
  !*** ./node_modules/gsap/TextPlugin.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextPlugin\": function() { return /* binding */ TextPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ TextPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ \"./node_modules/gsap/utils/strings.js\");\n/*!\n * TextPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar gsap,\n    _tempDiv,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\n\nvar TextPlugin = {\n  version: \"3.11.2\",\n  name: \"text\",\n  init: function init(target, value, tween) {\n    typeof value !== \"object\" && (value = {\n      value: value\n    });\n\n    var i = target.nodeName.toUpperCase(),\n        data = this,\n        _value = value,\n        newClass = _value.newClass,\n        oldClass = _value.oldClass,\n        preserveSpaces = _value.preserveSpaces,\n        rtl = _value.rtl,\n        delimiter = data.delimiter = value.delimiter || \"\",\n        fillChar = data.fillChar = value.fillChar || (value.padSpace ? \"&nbsp;\" : \"\"),\n        _short,\n        text,\n        original,\n        j,\n        condensedText,\n        condensedOriginal,\n        aggregate,\n        s;\n\n    data.svg = target.getBBox && (i === \"TEXT\" || i === \"TSPAN\");\n\n    if (!(\"innerHTML\" in target) && !data.svg) {\n      return false;\n    }\n\n    data.target = target;\n\n    if (!(\"value\" in value)) {\n      data.text = data.original = [\"\"];\n      return;\n    }\n\n    original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(target, delimiter, false, preserveSpaces);\n    _tempDiv || (_tempDiv = document.createElement(\"div\"));\n    _tempDiv.innerHTML = value.value;\n    text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(_tempDiv, delimiter, false, preserveSpaces);\n    data.from = tween._from;\n\n    if ((data.from || rtl) && !(rtl && data.from)) {\n      // right-to-left or \"from()\" tweens should invert things (but if it's BOTH .from() and rtl, inverting twice equals not inverting at all :)\n      i = original;\n      original = text;\n      text = i;\n    }\n\n    data.hasClass = !!(newClass || oldClass);\n    data.newClass = rtl ? oldClass : newClass;\n    data.oldClass = rtl ? newClass : oldClass;\n    i = original.length - text.length;\n    _short = i < 0 ? original : text;\n\n    if (i < 0) {\n      i = -i;\n    }\n\n    while (--i > -1) {\n      _short.push(fillChar);\n    }\n\n    if (value.type === \"diff\") {\n      j = 0;\n      condensedText = [];\n      condensedOriginal = [];\n      aggregate = \"\";\n\n      for (i = 0; i < text.length; i++) {\n        s = text[i];\n\n        if (s === original[i]) {\n          aggregate += s;\n        } else {\n          condensedText[j] = aggregate + s;\n          condensedOriginal[j++] = aggregate + original[i];\n          aggregate = \"\";\n        }\n      }\n\n      text = condensedText;\n      original = condensedOriginal;\n\n      if (aggregate) {\n        text.push(aggregate);\n        original.push(aggregate);\n      }\n    }\n\n    value.speed && tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));\n    data.rtl = rtl;\n    data.original = original;\n    data.text = text;\n\n    data._props.push(\"text\");\n  },\n  render: function render(ratio, data) {\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n\n    if (data.from) {\n      ratio = 1 - ratio;\n    }\n\n    var text = data.text,\n        hasClass = data.hasClass,\n        newClass = data.newClass,\n        oldClass = data.oldClass,\n        delimiter = data.delimiter,\n        target = data.target,\n        fillChar = data.fillChar,\n        original = data.original,\n        rtl = data.rtl,\n        l = text.length,\n        i = (rtl ? 1 - ratio : ratio) * l + 0.5 | 0,\n        applyNew,\n        applyOld,\n        str;\n\n    if (hasClass && ratio) {\n      applyNew = newClass && i;\n      applyOld = oldClass && i !== l;\n      str = (applyNew ? \"<span class='\" + newClass + \"'>\" : \"\") + text.slice(0, i).join(delimiter) + (applyNew ? \"</span>\" : \"\") + (applyOld ? \"<span class='\" + oldClass + \"'>\" : \"\") + delimiter + original.slice(i).join(delimiter) + (applyOld ? \"</span>\" : \"\");\n    } else {\n      str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);\n    }\n\n    if (data.svg) {\n      //SVG text elements don't have an \"innerHTML\" in Microsoft browsers.\n      target.textContent = str;\n    } else {\n      target.innerHTML = fillChar === \"&nbsp;\" && ~str.indexOf(\"  \") ? str.split(\"  \").join(\"&nbsp;&nbsp;\") : str;\n    }\n  }\n};\nTextPlugin.splitInnerHTML = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML;\nTextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;\nTextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;\n_getGSAP() && gsap.registerPlugin(TextPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9UZXh0UGx1Z2luLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxpRUFBYztBQUM3QjtBQUNBO0FBQ0EsV0FBVyxpRUFBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZDQUE2QyxzREFBc0QsTUFBTTtBQUN6RztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQWM7QUFDMUMsNEJBQTRCLDZEQUFjO0FBQzFDLHFCQUFxQixzREFBTztBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9UZXh0UGx1Z2luLmpzPzJlZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUZXh0UGx1Z2luIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGVtb2ppU2FmZVNwbGl0LCBnZXRUZXh0LCBzcGxpdElubmVySFRNTCB9IGZyb20gXCIuL3V0aWxzL3N0cmluZ3MuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX3RlbXBEaXYsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59O1xuXG5leHBvcnQgdmFyIFRleHRQbHVnaW4gPSB7XG4gIHZlcnNpb246IFwiMy4xMS4yXCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG4gICAgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmICh2YWx1ZSA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuXG4gICAgdmFyIGkgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgZGF0YSA9IHRoaXMsXG4gICAgICAgIF92YWx1ZSA9IHZhbHVlLFxuICAgICAgICBuZXdDbGFzcyA9IF92YWx1ZS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBfdmFsdWUub2xkQ2xhc3MsXG4gICAgICAgIHByZXNlcnZlU3BhY2VzID0gX3ZhbHVlLnByZXNlcnZlU3BhY2VzLFxuICAgICAgICBydGwgPSBfdmFsdWUucnRsLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlciA9IHZhbHVlLmRlbGltaXRlciB8fCBcIlwiLFxuICAgICAgICBmaWxsQ2hhciA9IGRhdGEuZmlsbENoYXIgPSB2YWx1ZS5maWxsQ2hhciB8fCAodmFsdWUucGFkU3BhY2UgPyBcIiZuYnNwO1wiIDogXCJcIiksXG4gICAgICAgIF9zaG9ydCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgb3JpZ2luYWwsXG4gICAgICAgIGosXG4gICAgICAgIGNvbmRlbnNlZFRleHQsXG4gICAgICAgIGNvbmRlbnNlZE9yaWdpbmFsLFxuICAgICAgICBhZ2dyZWdhdGUsXG4gICAgICAgIHM7XG5cbiAgICBkYXRhLnN2ZyA9IHRhcmdldC5nZXRCQm94ICYmIChpID09PSBcIlRFWFRcIiB8fCBpID09PSBcIlRTUEFOXCIpO1xuXG4gICAgaWYgKCEoXCJpbm5lckhUTUxcIiBpbiB0YXJnZXQpICYmICFkYXRhLnN2Zykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgaWYgKCEoXCJ2YWx1ZVwiIGluIHZhbHVlKSkge1xuICAgICAgZGF0YS50ZXh0ID0gZGF0YS5vcmlnaW5hbCA9IFtcIlwiXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcmlnaW5hbCA9IHNwbGl0SW5uZXJIVE1MKHRhcmdldCwgZGVsaW1pdGVyLCBmYWxzZSwgcHJlc2VydmVTcGFjZXMpO1xuICAgIF90ZW1wRGl2IHx8IChfdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIF90ZW1wRGl2LmlubmVySFRNTCA9IHZhbHVlLnZhbHVlO1xuICAgIHRleHQgPSBzcGxpdElubmVySFRNTChfdGVtcERpdiwgZGVsaW1pdGVyLCBmYWxzZSwgcHJlc2VydmVTcGFjZXMpO1xuICAgIGRhdGEuZnJvbSA9IHR3ZWVuLl9mcm9tO1xuXG4gICAgaWYgKChkYXRhLmZyb20gfHwgcnRsKSAmJiAhKHJ0bCAmJiBkYXRhLmZyb20pKSB7XG4gICAgICAvLyByaWdodC10by1sZWZ0IG9yIFwiZnJvbSgpXCIgdHdlZW5zIHNob3VsZCBpbnZlcnQgdGhpbmdzIChidXQgaWYgaXQncyBCT1RIIC5mcm9tKCkgYW5kIHJ0bCwgaW52ZXJ0aW5nIHR3aWNlIGVxdWFscyBub3QgaW52ZXJ0aW5nIGF0IGFsbCA6KVxuICAgICAgaSA9IG9yaWdpbmFsO1xuICAgICAgb3JpZ2luYWwgPSB0ZXh0O1xuICAgICAgdGV4dCA9IGk7XG4gICAgfVxuXG4gICAgZGF0YS5oYXNDbGFzcyA9ICEhKG5ld0NsYXNzIHx8IG9sZENsYXNzKTtcbiAgICBkYXRhLm5ld0NsYXNzID0gcnRsID8gb2xkQ2xhc3MgOiBuZXdDbGFzcztcbiAgICBkYXRhLm9sZENsYXNzID0gcnRsID8gbmV3Q2xhc3MgOiBvbGRDbGFzcztcbiAgICBpID0gb3JpZ2luYWwubGVuZ3RoIC0gdGV4dC5sZW5ndGg7XG4gICAgX3Nob3J0ID0gaSA8IDAgPyBvcmlnaW5hbCA6IHRleHQ7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGkgPSAtaTtcbiAgICB9XG5cbiAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgIF9zaG9ydC5wdXNoKGZpbGxDaGFyKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJkaWZmXCIpIHtcbiAgICAgIGogPSAwO1xuICAgICAgY29uZGVuc2VkVGV4dCA9IFtdO1xuICAgICAgY29uZGVuc2VkT3JpZ2luYWwgPSBbXTtcbiAgICAgIGFnZ3JlZ2F0ZSA9IFwiXCI7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgPSB0ZXh0W2ldO1xuXG4gICAgICAgIGlmIChzID09PSBvcmlnaW5hbFtpXSkge1xuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmRlbnNlZFRleHRbal0gPSBhZ2dyZWdhdGUgKyBzO1xuICAgICAgICAgIGNvbmRlbnNlZE9yaWdpbmFsW2orK10gPSBhZ2dyZWdhdGUgKyBvcmlnaW5hbFtpXTtcbiAgICAgICAgICBhZ2dyZWdhdGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSBjb25kZW5zZWRUZXh0O1xuICAgICAgb3JpZ2luYWwgPSBjb25kZW5zZWRPcmlnaW5hbDtcblxuICAgICAgaWYgKGFnZ3JlZ2F0ZSkge1xuICAgICAgICB0ZXh0LnB1c2goYWdncmVnYXRlKTtcbiAgICAgICAgb3JpZ2luYWwucHVzaChhZ2dyZWdhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlLnNwZWVkICYmIHR3ZWVuLmR1cmF0aW9uKE1hdGgubWluKDAuMDUgLyB2YWx1ZS5zcGVlZCAqIF9zaG9ydC5sZW5ndGgsIHZhbHVlLm1heER1cmF0aW9uIHx8IDk5OTkpKTtcbiAgICBkYXRhLnJ0bCA9IHJ0bDtcbiAgICBkYXRhLm9yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgZGF0YS50ZXh0ID0gdGV4dDtcblxuICAgIGRhdGEuX3Byb3BzLnB1c2goXCJ0ZXh0XCIpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgIHJhdGlvID0gMTtcbiAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAwO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmZyb20pIHtcbiAgICAgIHJhdGlvID0gMSAtIHJhdGlvO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gZGF0YS50ZXh0LFxuICAgICAgICBoYXNDbGFzcyA9IGRhdGEuaGFzQ2xhc3MsXG4gICAgICAgIG5ld0NsYXNzID0gZGF0YS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBkYXRhLm9sZENsYXNzLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlcixcbiAgICAgICAgdGFyZ2V0ID0gZGF0YS50YXJnZXQsXG4gICAgICAgIGZpbGxDaGFyID0gZGF0YS5maWxsQ2hhcixcbiAgICAgICAgb3JpZ2luYWwgPSBkYXRhLm9yaWdpbmFsLFxuICAgICAgICBydGwgPSBkYXRhLnJ0bCxcbiAgICAgICAgbCA9IHRleHQubGVuZ3RoLFxuICAgICAgICBpID0gKHJ0bCA/IDEgLSByYXRpbyA6IHJhdGlvKSAqIGwgKyAwLjUgfCAwLFxuICAgICAgICBhcHBseU5ldyxcbiAgICAgICAgYXBwbHlPbGQsXG4gICAgICAgIHN0cjtcblxuICAgIGlmIChoYXNDbGFzcyAmJiByYXRpbykge1xuICAgICAgYXBwbHlOZXcgPSBuZXdDbGFzcyAmJiBpO1xuICAgICAgYXBwbHlPbGQgPSBvbGRDbGFzcyAmJiBpICE9PSBsO1xuICAgICAgc3RyID0gKGFwcGx5TmV3ID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBuZXdDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyAoYXBwbHlOZXcgPyBcIjwvc3Bhbj5cIiA6IFwiXCIpICsgKGFwcGx5T2xkID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBvbGRDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgZGVsaW1pdGVyICsgb3JpZ2luYWwuc2xpY2UoaSkuam9pbihkZWxpbWl0ZXIpICsgKGFwcGx5T2xkID8gXCI8L3NwYW4+XCIgOiBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyBkZWxpbWl0ZXIgKyBvcmlnaW5hbC5zbGljZShpKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuc3ZnKSB7XG4gICAgICAvL1NWRyB0ZXh0IGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gXCJpbm5lckhUTUxcIiBpbiBNaWNyb3NvZnQgYnJvd3NlcnMuXG4gICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5pbm5lckhUTUwgPSBmaWxsQ2hhciA9PT0gXCImbmJzcDtcIiAmJiB+c3RyLmluZGV4T2YoXCIgIFwiKSA/IHN0ci5zcGxpdChcIiAgXCIpLmpvaW4oXCImbmJzcDsmbmJzcDtcIikgOiBzdHI7XG4gICAgfVxuICB9XG59O1xuVGV4dFBsdWdpbi5zcGxpdElubmVySFRNTCA9IHNwbGl0SW5uZXJIVE1MO1xuVGV4dFBsdWdpbi5lbW9qaVNhZmVTcGxpdCA9IGVtb2ppU2FmZVNwbGl0O1xuVGV4dFBsdWdpbi5nZXRUZXh0ID0gZ2V0VGV4dDtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihUZXh0UGx1Z2luKTtcbmV4cG9ydCB7IFRleHRQbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/TextPlugin.js\n"));

/***/ }),

/***/ "./node_modules/gsap/all.js":
/*!**********************************!*\
  !*** ./node_modules/gsap/all.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Back\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },\n/* harmony export */   \"Bounce\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },\n/* harmony export */   \"CSSPlugin\": function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   \"Circ\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },\n/* harmony export */   \"Cubic\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },\n/* harmony export */   \"Elastic\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },\n/* harmony export */   \"Expo\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },\n/* harmony export */   \"Linear\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },\n/* harmony export */   \"Power0\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },\n/* harmony export */   \"Power1\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },\n/* harmony export */   \"Power2\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },\n/* harmony export */   \"Power3\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },\n/* harmony export */   \"Power4\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },\n/* harmony export */   \"Quad\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },\n/* harmony export */   \"Quart\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },\n/* harmony export */   \"Quint\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },\n/* harmony export */   \"Sine\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },\n/* harmony export */   \"SteppedEase\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },\n/* harmony export */   \"Strong\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },\n/* harmony export */   \"TimelineLite\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },\n/* harmony export */   \"TimelineMax\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },\n/* harmony export */   \"TweenLite\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },\n/* harmony export */   \"TweenMax\": function() { return /* binding */ TweenMaxWithCSS; },\n/* harmony export */   \"clamp\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.clamp; },\n/* harmony export */   \"default\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   \"distribute\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.distribute; },\n/* harmony export */   \"getUnit\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit; },\n/* harmony export */   \"gsap\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   \"interpolate\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.interpolate; },\n/* harmony export */   \"mapRange\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.mapRange; },\n/* harmony export */   \"normalize\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.normalize; },\n/* harmony export */   \"pipe\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.pipe; },\n/* harmony export */   \"random\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.random; },\n/* harmony export */   \"selector\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.selector; },\n/* harmony export */   \"shuffle\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.shuffle; },\n/* harmony export */   \"snap\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.snap; },\n/* harmony export */   \"splitColor\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.splitColor; },\n/* harmony export */   \"toArray\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.toArray; },\n/* harmony export */   \"unitize\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.unitize; },\n/* harmony export */   \"wrap\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrap; },\n/* harmony export */   \"wrapYoyo\": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrapYoyo; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"./node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"./node_modules/gsap/CSSPlugin.js\");\n/* harmony import */ var _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomEase.js */ \"./node_modules/gsap/CustomEase.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Draggable.js */ \"./node_modules/gsap/Draggable.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Draggable_js__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _Draggable_js__WEBPACK_IMPORTED_MODULE_3__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CSSRulePlugin.js */ \"./node_modules/gsap/CSSRulePlugin.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EaselPlugin.js */ \"./node_modules/gsap/EaselPlugin.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EasePack.js */ \"./node_modules/gsap/EasePack.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _EasePack_js__WEBPACK_IMPORTED_MODULE_6__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _EasePack_js__WEBPACK_IMPORTED_MODULE_6__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _Flip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Flip.js */ \"./node_modules/gsap/Flip.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Flip_js__WEBPACK_IMPORTED_MODULE_7__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _Flip_js__WEBPACK_IMPORTED_MODULE_7__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MotionPathPlugin.js */ \"./node_modules/gsap/MotionPathPlugin.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Observer.js */ \"./node_modules/gsap/Observer.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Observer_js__WEBPACK_IMPORTED_MODULE_9__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _Observer_js__WEBPACK_IMPORTED_MODULE_9__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PixiPlugin.js */ \"./node_modules/gsap/PixiPlugin.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ScrollToPlugin.js */ \"./node_modules/gsap/ScrollToPlugin.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ScrollTrigger.js */ \"./node_modules/gsap/ScrollTrigger.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./TextPlugin.js */ \"./node_modules/gsap/TextPlugin.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__) if([\"default\",\"gsap\",\"TweenMax\",\"CSSPlugin\",\"TweenLite\",\"TimelineMax\",\"TimelineLite\",\"Power0\",\"Power1\",\"Power2\",\"Power3\",\"Power4\",\"Linear\",\"Quad\",\"Cubic\",\"Quart\",\"Quint\",\"Strong\",\"Elastic\",\"Back\",\"SteppedEase\",\"Bounce\",\"Sine\",\"Expo\",\"Circ\",\"wrap\",\"wrapYoyo\",\"distribute\",\"random\",\"snap\",\"normalize\",\"getUnit\",\"clamp\",\"splitColor\",\"toArray\",\"mapRange\",\"pipe\",\"unitize\",\"interpolate\",\"shuffle\",\"selector\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n\n\n\n\n\n\n\n\n\n\n\n\n //BONUS EXPORTS\n// export * from \"./DrawSVGPlugin.js\";\n// export * from \"./Physics2DPlugin.js\";\n// export * from \"./PhysicsPropsPlugin.js\";\n// export * from \"./ScrambleTextPlugin.js\";\n// export * from \"./CustomBounce.js\";\n// export * from \"./CustomWiggle.js\";\n// export * from \"./GSDevTools.js\";\n// export * from \"./InertiaPlugin.js\";\n// export * from \"./MorphSVGPlugin.js\";\n// export * from \"./MotionPathHelper.js\";\n// export * from \"./ScrollSmoother.js\";\n// export * from \"./SplitText.js\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9hbGwuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNLO0FBQ3ZDLGtCQUFrQixvRUFBbUIsQ0FBQyxxREFBUyxLQUFLLHFEQUFJO0FBQ3hEO0FBQ0E7QUFDK0Y7QUFDbVE7QUFDbFU7QUFDRDtBQUNJO0FBQ0Y7QUFDSDtBQUNKO0FBQ1k7QUFDUjtBQUNFO0FBQ0k7QUFDRDtBQUNILENBQUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL2FsbC5qcz85MDI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnc2FwIGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuaW1wb3J0IENTU1BsdWdpbiBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLFxuICAgIC8vIHRvIHByb3RlY3QgZnJvbSB0cmVlIHNoYWtpbmdcblR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5leHBvcnQgeyBnc2FwV2l0aENTUyBhcyBnc2FwLCBnc2FwV2l0aENTUyBhcyBkZWZhdWx0LCBUd2Vlbk1heFdpdGhDU1MgYXMgVHdlZW5NYXgsIENTU1BsdWdpbiB9O1xuZXhwb3J0IHsgVHdlZW5MaXRlLCBUaW1lbGluZU1heCwgVGltZWxpbmVMaXRlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIG1hcFJhbmdlLCBwaXBlLCB1bml0aXplLCBpbnRlcnBvbGF0ZSwgc2h1ZmZsZSwgc2VsZWN0b3IgfSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0N1c3RvbUVhc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0RyYWdnYWJsZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ1NTUnVsZVBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRWFzZWxQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0Vhc2VQYWNrLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9GbGlwLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Nb3Rpb25QYXRoUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9PYnNlcnZlci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vUGl4aVBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vU2Nyb2xsVG9QbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1Njcm9sbFRyaWdnZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1RleHRQbHVnaW4uanNcIjsgLy9CT05VUyBFWFBPUlRTXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9EcmF3U1ZHUGx1Z2luLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9QaHlzaWNzMkRQbHVnaW4uanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL1BoeXNpY3NQcm9wc1BsdWdpbi5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vU2NyYW1ibGVUZXh0UGx1Z2luLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9DdXN0b21Cb3VuY2UuanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL0N1c3RvbVdpZ2dsZS5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vR1NEZXZUb29scy5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vSW5lcnRpYVBsdWdpbi5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vTW9ycGhTVkdQbHVnaW4uanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL01vdGlvblBhdGhIZWxwZXIuanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL1Njcm9sbFNtb290aGVyLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9TcGxpdFRleHQuanNcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/all.js\n"));

/***/ }),

/***/ "./node_modules/gsap/utils/matrix.js":
/*!*******************************************!*\
  !*** ./node_modules/gsap/utils/matrix.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Matrix2D\": function() { return /* binding */ Matrix2D; },\n/* harmony export */   \"_getCTM\": function() { return /* binding */ _getCTM; },\n/* harmony export */   \"_getDocScrollLeft\": function() { return /* binding */ _getDocScrollLeft; },\n/* harmony export */   \"_getDocScrollTop\": function() { return /* binding */ _getDocScrollTop; },\n/* harmony export */   \"_isFixed\": function() { return /* binding */ _isFixed; },\n/* harmony export */   \"_setDoc\": function() { return /* binding */ _setDoc; },\n/* harmony export */   \"getGlobalMatrix\": function() { return /* binding */ getGlobalMatrix; }\n/* harmony export */ });\n/*!\n * matrix 3.11.2\n * https://greensock.com\n *\n * Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _doc,\n    _win,\n    _docElement,\n    _body,\n    _divContainer,\n    _svgContainer,\n    _identityMatrix,\n    _gEl,\n    _transformProp = \"transform\",\n    _transformOriginProp = _transformProp + \"Origin\",\n    _hasOffsetBug,\n    _setDoc = function _setDoc(element) {\n  var doc = element.ownerDocument || element;\n\n  if (!(_transformProp in element.style) && \"msTransform\" in element.style) {\n    //to improve compatibility with old Microsoft browsers\n    _transformProp = \"msTransform\";\n    _transformOriginProp = _transformProp + \"Origin\";\n  }\n\n  while (doc.parentNode && (doc = doc.parentNode)) {}\n\n  _win = window;\n  _identityMatrix = new Matrix2D();\n\n  if (doc) {\n    _doc = doc;\n    _docElement = doc.documentElement;\n    _body = doc.body;\n    _gEl = _doc.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); // prevent any existing CSS from transforming it\n\n    _gEl.style.transform = \"none\"; // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it's 2020 and it's still not fixed.\n\n    var d1 = doc.createElement(\"div\"),\n        d2 = doc.createElement(\"div\");\n\n    _body.appendChild(d1);\n\n    d1.appendChild(d2);\n    d1.style.position = \"static\";\n    d1.style[_transformProp] = \"translate3d(0,0,1px)\";\n    _hasOffsetBug = d2.offsetParent !== d1;\n\n    _body.removeChild(d1);\n  }\n\n  return doc;\n},\n    _forceNonZeroScale = function _forceNonZeroScale(e) {\n  // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.\n  var a, cache;\n\n  while (e && e !== _body) {\n    cache = e._gsap;\n    cache && cache.uncache && cache.get(e, \"x\"); // force re-parsing of transforms if necessary\n\n    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n      cache.scaleX = cache.scaleY = 1e-4;\n      cache.renderTransform(1, cache);\n      a ? a.push(cache) : a = [cache];\n    }\n\n    e = e.parentNode;\n  }\n\n  return a;\n},\n    // possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.\n// _forceDisplay = e => {\n// \tlet a = [],\n// \t\tparent;\n// \twhile (e && e !== _body) {\n// \t\tparent = e.parentNode;\n// \t\t(_win.getComputedStyle(e).display === \"none\" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = \"block\");\n// \t\tparent || _body.appendChild(e);\n// \t\te = parent;\n// \t}\n// \treturn a;\n// },\n// _revertDisplay = a => {\n// \tfor (let i = 0; i < a.length; i+=3) {\n// \t\ta[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty(\"display\");\n// \t\ta[i+2] || a[i].parentNode.removeChild(a[i]);\n// \t}\n// },\n_svgTemps = [],\n    //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.\n_divTemps = [],\n    _getDocScrollTop = function _getDocScrollTop() {\n  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;\n},\n    _getDocScrollLeft = function _getDocScrollLeft() {\n  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;\n},\n    _svgOwner = function _svgOwner(element) {\n  return element.ownerSVGElement || ((element.tagName + \"\").toLowerCase() === \"svg\" ? element : null);\n},\n    _isFixed = function _isFixed(element) {\n  if (_win.getComputedStyle(element).position === \"fixed\") {\n    return true;\n  }\n\n  element = element.parentNode;\n\n  if (element && element.nodeType === 1) {\n    // avoid document fragments which will throw an error.\n    return _isFixed(element);\n  }\n},\n    _createSibling = function _createSibling(element, i) {\n  if (element.parentNode && (_doc || _setDoc(element))) {\n    var svg = _svgOwner(element),\n        ns = svg ? svg.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\",\n        type = svg ? i ? \"rect\" : \"g\" : \"div\",\n        x = i !== 2 ? 0 : 100,\n        y = i === 3 ? 100 : 0,\n        css = \"position:absolute;display:block;pointer-events:none;margin:0;padding:0;\",\n        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, \"http\"), type) : _doc.createElement(type);\n\n    if (i) {\n      if (!svg) {\n        if (!_divContainer) {\n          _divContainer = _createSibling(element);\n          _divContainer.style.cssText = css;\n        }\n\n        e.style.cssText = css + \"width:0.1px;height:0.1px;top:\" + y + \"px;left:\" + x + \"px\";\n\n        _divContainer.appendChild(e);\n      } else {\n        _svgContainer || (_svgContainer = _createSibling(element));\n        e.setAttribute(\"width\", 0.01);\n        e.setAttribute(\"height\", 0.01);\n        e.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n\n        _svgContainer.appendChild(e);\n      }\n    }\n\n    return e;\n  }\n\n  throw \"Need document and parent.\";\n},\n    _consolidate = function _consolidate(m) {\n  // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n  var c = new Matrix2D(),\n      i = 0;\n\n  for (; i < m.numberOfItems; i++) {\n    c.multiply(m.getItem(i).matrix);\n  }\n\n  return c;\n},\n    _getCTM = function _getCTM(svg) {\n  var m = svg.getCTM(),\n      transform;\n\n  if (!m) {\n    // Firefox returns null for getCTM() on root <svg> elements, so this is a workaround using a <g> that we temporarily append.\n    transform = svg.style[_transformProp];\n    svg.style[_transformProp] = \"none\"; // a bug in Firefox causes css transforms to contaminate the getCTM()\n\n    svg.appendChild(_gEl);\n    m = _gEl.getCTM();\n    svg.removeChild(_gEl);\n    transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n  }\n\n  return m || _identityMatrix.clone(); // Firefox will still return null if the <svg> has a width/height of 0 in the browser.\n},\n    _placeSiblings = function _placeSiblings(element, adjustGOffset) {\n  var svg = _svgOwner(element),\n      isRootSVG = element === svg,\n      siblings = svg ? _svgTemps : _divTemps,\n      parent = element.parentNode,\n      container,\n      m,\n      b,\n      x,\n      y,\n      cs;\n\n  if (element === _win) {\n    return element;\n  }\n\n  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n  container = svg ? _svgContainer : _divContainer;\n\n  if (svg) {\n    if (isRootSVG) {\n      b = _getCTM(element);\n      x = -b.e / b.a;\n      y = -b.f / b.d;\n      m = _identityMatrix;\n    } else if (element.getBBox) {\n      b = element.getBBox();\n      m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.\n\n      m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n\n      x = m.a * b.x + m.c * b.y;\n      y = m.b * b.x + m.d * b.y;\n    } else {\n      // may be a <mask> which has no getBBox() so just use defaults instead of throwing errors.\n      m = new Matrix2D();\n      x = y = 0;\n    }\n\n    if (adjustGOffset && element.tagName.toLowerCase() === \"g\") {\n      x = y = 0;\n    }\n\n    (isRootSVG ? svg : parent).appendChild(container);\n    container.setAttribute(\"transform\", \"matrix(\" + m.a + \",\" + m.b + \",\" + m.c + \",\" + m.d + \",\" + (m.e + x) + \",\" + (m.f + y) + \")\");\n  } else {\n    x = y = 0;\n\n    if (_hasOffsetBug) {\n      // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.\n      m = element.offsetParent;\n      b = element;\n\n      while (b && (b = b.parentNode) && b !== m && b.parentNode) {\n        if ((_win.getComputedStyle(b)[_transformProp] + \"\").length > 4) {\n          x = b.offsetLeft;\n          y = b.offsetTop;\n          b = 0;\n        }\n      }\n    }\n\n    cs = _win.getComputedStyle(element);\n\n    if (cs.position !== \"absolute\" && cs.position !== \"fixed\") {\n      m = element.offsetParent;\n\n      while (parent && parent !== m) {\n        // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.\n        x += parent.scrollLeft || 0;\n        y += parent.scrollTop || 0;\n        parent = parent.parentNode;\n      }\n    }\n\n    b = container.style;\n    b.top = element.offsetTop - y + \"px\";\n    b.left = element.offsetLeft - x + \"px\";\n    b[_transformProp] = cs[_transformProp];\n    b[_transformOriginProp] = cs[_transformOriginProp]; // b.border = m.border;\n    // b.borderLeftStyle = m.borderLeftStyle;\n    // b.borderTopStyle = m.borderTopStyle;\n    // b.borderLeftWidth = m.borderLeftWidth;\n    // b.borderTopWidth = m.borderTopWidth;\n\n    b.position = cs.position === \"fixed\" ? \"fixed\" : \"absolute\";\n    element.parentNode.appendChild(container);\n  }\n\n  return container;\n},\n    _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {\n  m.a = a;\n  m.b = b;\n  m.c = c;\n  m.d = d;\n  m.e = e;\n  m.f = f;\n  return m;\n};\n\nvar Matrix2D = /*#__PURE__*/function () {\n  function Matrix2D(a, b, c, d, e, f) {\n    if (a === void 0) {\n      a = 1;\n    }\n\n    if (b === void 0) {\n      b = 0;\n    }\n\n    if (c === void 0) {\n      c = 0;\n    }\n\n    if (d === void 0) {\n      d = 1;\n    }\n\n    if (e === void 0) {\n      e = 0;\n    }\n\n    if (f === void 0) {\n      f = 0;\n    }\n\n    _setMatrix(this, a, b, c, d, e, f);\n  }\n\n  var _proto = Matrix2D.prototype;\n\n  _proto.inverse = function inverse() {\n    var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f,\n        determinant = a * d - b * c || 1e-10;\n    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n  };\n\n  _proto.multiply = function multiply(matrix) {\n    var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f,\n        a2 = matrix.a,\n        b2 = matrix.c,\n        c2 = matrix.b,\n        d2 = matrix.d,\n        e2 = matrix.e,\n        f2 = matrix.f;\n    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);\n  };\n\n  _proto.clone = function clone() {\n    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n  };\n\n  _proto.equals = function equals(matrix) {\n    var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n  };\n\n  _proto.apply = function apply(point, decoratee) {\n    if (decoratee === void 0) {\n      decoratee = {};\n    }\n\n    var x = point.x,\n        y = point.y,\n        a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n    decoratee.x = x * a + y * c + e || 0;\n    decoratee.y = x * b + y * d + f || 0;\n    return decoratee;\n  };\n\n  return Matrix2D;\n}(); // Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.\n// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.\n// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there\n// are transforms applied to ancestor elements.\n// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:\n//     tx = m.a * x + m.c * y + m.e\n//     ty = m.b * x + m.d * y + m.f\n\nfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n  // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.\n  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n    return new Matrix2D();\n  }\n\n  var zeroScales = _forceNonZeroScale(element),\n      svg = _svgOwner(element),\n      temps = svg ? _svgTemps : _divTemps,\n      container = _placeSiblings(element, adjustGOffset),\n      b1 = temps[0].getBoundingClientRect(),\n      b2 = temps[1].getBoundingClientRect(),\n      b3 = temps[2].getBoundingClientRect(),\n      parent = container.parentNode,\n      isFixed = !includeScrollInFixed && _isFixed(element),\n      m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));\n\n  parent.removeChild(container);\n\n  if (zeroScales) {\n    b1 = zeroScales.length;\n\n    while (b1--) {\n      b2 = zeroScales[b1];\n      b2.scaleX = b2.scaleY = 0;\n      b2.renderTransform(1, b2);\n    }\n  }\n\n  return inverse ? m.inverse() : m;\n}\n // export function getMatrix(element) {\n// \t_doc || _setDoc(element);\n// \tlet m = (_win.getComputedStyle(element)[_transformProp] + \"\").substr(7).match(/[-.]*\\d+[.e\\-+]*\\d*[e\\-\\+]*\\d*/g),\n// \t\tis2D = m && m.length === 6;\n// \treturn !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9tYXRyaXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEUsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWMsb0JBQW9CLFNBQVMsVUFBVTtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGFBQWEsZ0JBQWdCOztBQUUxRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhEQUE4RDs7QUFFOUQsNEdBQTRHOztBQUU1RztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMkUsQ0FBQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3V0aWxzL21hdHJpeC5qcz85OGZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogbWF0cml4IDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfZG9jLFxuICAgIF93aW4sXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX2JvZHksXG4gICAgX2RpdkNvbnRhaW5lcixcbiAgICBfc3ZnQ29udGFpbmVyLFxuICAgIF9pZGVudGl0eU1hdHJpeCxcbiAgICBfZ0VsLFxuICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIixcbiAgICBfaGFzT2Zmc2V0QnVnLFxuICAgIF9zZXREb2MgPSBmdW5jdGlvbiBfc2V0RG9jKGVsZW1lbnQpIHtcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuXG4gIGlmICghKF90cmFuc2Zvcm1Qcm9wIGluIGVsZW1lbnQuc3R5bGUpICYmIFwibXNUcmFuc2Zvcm1cIiBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgLy90byBpbXByb3ZlIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgTWljcm9zb2Z0IGJyb3dzZXJzXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcIm1zVHJhbnNmb3JtXCI7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gIH1cblxuICB3aGlsZSAoZG9jLnBhcmVudE5vZGUgJiYgKGRvYyA9IGRvYy5wYXJlbnROb2RlKSkge31cblxuICBfd2luID0gd2luZG93O1xuICBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4MkQoKTtcblxuICBpZiAoZG9jKSB7XG4gICAgX2RvYyA9IGRvYztcbiAgICBfZG9jRWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBkb2MuYm9keTtcbiAgICBfZ0VsID0gX2RvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7IC8vIHByZXZlbnQgYW55IGV4aXN0aW5nIENTUyBmcm9tIHRyYW5zZm9ybWluZyBpdFxuXG4gICAgX2dFbC5zdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjsgLy8gbm93IHRlc3QgZm9yIHRoZSBvZmZzZXQgcmVwb3J0aW5nIGJ1Zy4gVXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGluc3RlYWQgb2YgYnJvd3NlciBzbmlmZmluZyB0byBtYWtlIHRoaW5ncyBtb3JlIGJ1bGxldHByb29mIGFuZCBmdXR1cmUtcHJvb2YuIEhvcGVmdWxseSBTYWZhcmkgd2lsbCBmaXggdGhlaXIgYnVnIHNvb24gYnV0IGl0J3MgMjAyMCBhbmQgaXQncyBzdGlsbCBub3QgZml4ZWQuXG5cbiAgICB2YXIgZDEgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgZDIgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIF9ib2R5LmFwcGVuZENoaWxkKGQxKTtcblxuICAgIGQxLmFwcGVuZENoaWxkKGQyKTtcbiAgICBkMS5zdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCI7XG4gICAgZDEuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJ0cmFuc2xhdGUzZCgwLDAsMXB4KVwiO1xuICAgIF9oYXNPZmZzZXRCdWcgPSBkMi5vZmZzZXRQYXJlbnQgIT09IGQxO1xuXG4gICAgX2JvZHkucmVtb3ZlQ2hpbGQoZDEpO1xuICB9XG5cbiAgcmV0dXJuIGRvYztcbn0sXG4gICAgX2ZvcmNlTm9uWmVyb1NjYWxlID0gZnVuY3Rpb24gX2ZvcmNlTm9uWmVyb1NjYWxlKGUpIHtcbiAgLy8gd2Fsa3MgdXAgdGhlIGVsZW1lbnQncyBhbmNlc3RvcnMgYW5kIGZpbmRzIGFueSB0aGF0IGhhZCB0aGVpciBzY2FsZSBzZXQgdG8gMCB2aWEgR1NBUCwgYW5kIGNoYW5nZXMgdGhlbSB0byAwLjAwMDEgdG8gZW5zdXJlIHRoYXQgbWVhc3VyZW1lbnRzIHdvcmsuIEZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGl0IHRvIGluY29ycmVjdGx5IHJlcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB3aGVuIHNjYWxlIGlzIDAuXG4gIHZhciBhLCBjYWNoZTtcblxuICB3aGlsZSAoZSAmJiBlICE9PSBfYm9keSkge1xuICAgIGNhY2hlID0gZS5fZ3NhcDtcbiAgICBjYWNoZSAmJiBjYWNoZS51bmNhY2hlICYmIGNhY2hlLmdldChlLCBcInhcIik7IC8vIGZvcmNlIHJlLXBhcnNpbmcgb2YgdHJhbnNmb3JtcyBpZiBuZWNlc3NhcnlcblxuICAgIGlmIChjYWNoZSAmJiAhY2FjaGUuc2NhbGVYICYmICFjYWNoZS5zY2FsZVkgJiYgY2FjaGUucmVuZGVyVHJhbnNmb3JtKSB7XG4gICAgICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSAxZS00O1xuICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGNhY2hlKTtcbiAgICAgIGEgPyBhLnB1c2goY2FjaGUpIDogYSA9IFtjYWNoZV07XG4gICAgfVxuXG4gICAgZSA9IGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBhO1xufSxcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgYWRkaXRpb246IHBhc3MgYW4gZWxlbWVudCB0byBfZm9yY2VEaXNwbGF5KCkgYW5kIGl0J2xsIHdhbGsgdXAgYWxsIGl0cyBhbmNlc3RvcnMgYW5kIG1ha2Ugc3VyZSBhbnl0aGluZyB3aXRoIGRpc3BsYXk6IG5vbmUgaXMgc2V0IHRvIGRpc3BsYXk6IGJsb2NrLCBhbmQgaWYgdGhlcmUncyBubyBwYXJlbnROb2RlLCBpdCdsbCBhZGQgaXQgdG8gdGhlIGJvZHkuIEl0IHJldHVybnMgYW4gQXJyYXkgdGhhdCB5b3UgY2FuIHRoZW4gZmVlZCB0byBfcmV2ZXJ0RGlzcGxheSgpIHRvIGhhdmUgaXQgcmV2ZXJ0IGFsbCB0aGUgY2hhbmdlcyBpdCBtYWRlLlxuLy8gX2ZvcmNlRGlzcGxheSA9IGUgPT4ge1xuLy8gXHRsZXQgYSA9IFtdLFxuLy8gXHRcdHBhcmVudDtcbi8vIFx0d2hpbGUgKGUgJiYgZSAhPT0gX2JvZHkpIHtcbi8vIFx0XHRwYXJlbnQgPSBlLnBhcmVudE5vZGU7XG4vLyBcdFx0KF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlKS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhcGFyZW50KSAmJiBhLnB1c2goZSwgZS5zdHlsZS5kaXNwbGF5LCBwYXJlbnQpICYmIChlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIpO1xuLy8gXHRcdHBhcmVudCB8fCBfYm9keS5hcHBlbmRDaGlsZChlKTtcbi8vIFx0XHRlID0gcGFyZW50O1xuLy8gXHR9XG4vLyBcdHJldHVybiBhO1xuLy8gfSxcbi8vIF9yZXZlcnREaXNwbGF5ID0gYSA9PiB7XG4vLyBcdGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrPTMpIHtcbi8vIFx0XHRhW2krMV0gPyAoYVtpXS5zdHlsZS5kaXNwbGF5ID0gYVtpKzFdKSA6IGFbaV0uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuLy8gXHRcdGFbaSsyXSB8fCBhW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYVtpXSk7XG4vLyBcdH1cbi8vIH0sXG5fc3ZnVGVtcHMgPSBbXSxcbiAgICAvL3dlIGNyZWF0ZSAzIGVsZW1lbnRzIGZvciBTVkcsIGFuZCAzIGZvciBvdGhlciBET00gZWxlbWVudHMgYW5kIGNhY2hlIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIFRoZXkgZ2V0IG5lc3RlZCBpbiBfZGl2Q29udGFpbmVyIGFuZCBfc3ZnQ29udGFpbmVyIHNvIHRoYXQganVzdCBvbmUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgRE9NIG9uIGVhY2ggc3VjY2Vzc2l2ZSBhdHRlbXB0LiBBZ2FpbiwgcGVyZm9ybWFuY2UgaXMga2V5LlxuX2RpdlRlbXBzID0gW10sXG4gICAgX2dldERvY1Njcm9sbFRvcCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxUb3AoKSB7XG4gIHJldHVybiBfd2luLnBhZ2VZT2Zmc2V0IHx8IF9kb2Muc2Nyb2xsVG9wIHx8IF9kb2NFbGVtZW50LnNjcm9sbFRvcCB8fCBfYm9keS5zY3JvbGxUb3AgfHwgMDtcbn0sXG4gICAgX2dldERvY1Njcm9sbExlZnQgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsTGVmdCgpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvYy5zY3JvbGxMZWZ0IHx8IF9kb2NFbGVtZW50LnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwO1xufSxcbiAgICBfc3ZnT3duZXIgPSBmdW5jdGlvbiBfc3ZnT3duZXIoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgKChlbGVtZW50LnRhZ05hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiID8gZWxlbWVudCA6IG51bGwpO1xufSxcbiAgICBfaXNGaXhlZCA9IGZ1bmN0aW9uIF9pc0ZpeGVkKGVsZW1lbnQpIHtcbiAgaWYgKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAvLyBhdm9pZCBkb2N1bWVudCBmcmFnbWVudHMgd2hpY2ggd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXR1cm4gX2lzRml4ZWQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgX2NyZWF0ZVNpYmxpbmcgPSBmdW5jdGlvbiBfY3JlYXRlU2libGluZyhlbGVtZW50LCBpKSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgKF9kb2MgfHwgX3NldERvYyhlbGVtZW50KSkpIHtcbiAgICB2YXIgc3ZnID0gX3N2Z093bmVyKGVsZW1lbnQpLFxuICAgICAgICBucyA9IHN2ZyA/IHN2Zy5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSB8fCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcbiAgICAgICAgdHlwZSA9IHN2ZyA/IGkgPyBcInJlY3RcIiA6IFwiZ1wiIDogXCJkaXZcIixcbiAgICAgICAgeCA9IGkgIT09IDIgPyAwIDogMTAwLFxuICAgICAgICB5ID0gaSA9PT0gMyA/IDEwMCA6IDAsXG4gICAgICAgIGNzcyA9IFwicG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lO21hcmdpbjowO3BhZGRpbmc6MDtcIixcbiAgICAgICAgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMobnMucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcblxuICAgIGlmIChpKSB7XG4gICAgICBpZiAoIXN2Zykge1xuICAgICAgICBpZiAoIV9kaXZDb250YWluZXIpIHtcbiAgICAgICAgICBfZGl2Q29udGFpbmVyID0gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCk7XG4gICAgICAgICAgX2RpdkNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5zdHlsZS5jc3NUZXh0ID0gY3NzICsgXCJ3aWR0aDowLjFweDtoZWlnaHQ6MC4xcHg7dG9wOlwiICsgeSArIFwicHg7bGVmdDpcIiArIHggKyBcInB4XCI7XG5cbiAgICAgICAgX2RpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdmdDb250YWluZXIgfHwgKF9zdmdDb250YWluZXIgPSBfY3JlYXRlU2libGluZyhlbGVtZW50KSk7XG4gICAgICAgIGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMC4wMSk7XG4gICAgICAgIGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDAuMDEpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHggKyBcIixcIiArIHkgKyBcIilcIik7XG5cbiAgICAgICAgX3N2Z0NvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHRocm93IFwiTmVlZCBkb2N1bWVudCBhbmQgcGFyZW50LlwiO1xufSxcbiAgICBfY29uc29saWRhdGUgPSBmdW5jdGlvbiBfY29uc29saWRhdGUobSkge1xuICAvLyByZXBsYWNlcyBTVkdUcmFuc2Zvcm1MaXN0LmNvbnNvbGlkYXRlKCkgYmVjYXVzZSBhIGJ1ZyBpbiBGaXJlZm94IGNhdXNlcyBpdCB0byBicmVhayBwb2ludGVyIGV2ZW50cy4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjMyNDgtdG91Y2gtaXMtbm90LXdvcmtpbmctb24tZHJhZ2dhYmxlLWluLWZpcmVmb3gtd2luZG93cy12MzI0Lz90YWI9Y29tbWVudHMjY29tbWVudC0xMDk4MDBcbiAgdmFyIGMgPSBuZXcgTWF0cml4MkQoKSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbS5udW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICBjLm11bHRpcGx5KG0uZ2V0SXRlbShpKS5tYXRyaXgpO1xuICB9XG5cbiAgcmV0dXJuIGM7XG59LFxuICAgIF9nZXRDVE0gPSBmdW5jdGlvbiBfZ2V0Q1RNKHN2Zykge1xuICB2YXIgbSA9IHN2Zy5nZXRDVE0oKSxcbiAgICAgIHRyYW5zZm9ybTtcblxuICBpZiAoIW0pIHtcbiAgICAvLyBGaXJlZm94IHJldHVybnMgbnVsbCBmb3IgZ2V0Q1RNKCkgb24gcm9vdCA8c3ZnPiBlbGVtZW50cywgc28gdGhpcyBpcyBhIHdvcmthcm91bmQgdXNpbmcgYSA8Zz4gdGhhdCB3ZSB0ZW1wb3JhcmlseSBhcHBlbmQuXG4gICAgdHJhbnNmb3JtID0gc3ZnLnN0eWxlW190cmFuc2Zvcm1Qcm9wXTtcbiAgICBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJub25lXCI7IC8vIGEgYnVnIGluIEZpcmVmb3ggY2F1c2VzIGNzcyB0cmFuc2Zvcm1zIHRvIGNvbnRhbWluYXRlIHRoZSBnZXRDVE0oKVxuXG4gICAgc3ZnLmFwcGVuZENoaWxkKF9nRWwpO1xuICAgIG0gPSBfZ0VsLmdldENUTSgpO1xuICAgIHN2Zy5yZW1vdmVDaGlsZChfZ0VsKTtcbiAgICB0cmFuc2Zvcm0gPyBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtIDogc3ZnLnN0eWxlLnJlbW92ZVByb3BlcnR5KF90cmFuc2Zvcm1Qcm9wLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICByZXR1cm4gbSB8fCBfaWRlbnRpdHlNYXRyaXguY2xvbmUoKTsgLy8gRmlyZWZveCB3aWxsIHN0aWxsIHJldHVybiBudWxsIGlmIHRoZSA8c3ZnPiBoYXMgYSB3aWR0aC9oZWlnaHQgb2YgMCBpbiB0aGUgYnJvd3Nlci5cbn0sXG4gICAgX3BsYWNlU2libGluZ3MgPSBmdW5jdGlvbiBfcGxhY2VTaWJsaW5ncyhlbGVtZW50LCBhZGp1c3RHT2Zmc2V0KSB7XG4gIHZhciBzdmcgPSBfc3ZnT3duZXIoZWxlbWVudCksXG4gICAgICBpc1Jvb3RTVkcgPSBlbGVtZW50ID09PSBzdmcsXG4gICAgICBzaWJsaW5ncyA9IHN2ZyA/IF9zdmdUZW1wcyA6IF9kaXZUZW1wcyxcbiAgICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG0sXG4gICAgICBiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjcztcblxuICBpZiAoZWxlbWVudCA9PT0gX3dpbikge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgc2libGluZ3MubGVuZ3RoIHx8IHNpYmxpbmdzLnB1c2goX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMSksIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDIpLCBfY3JlYXRlU2libGluZyhlbGVtZW50LCAzKSk7XG4gIGNvbnRhaW5lciA9IHN2ZyA/IF9zdmdDb250YWluZXIgOiBfZGl2Q29udGFpbmVyO1xuXG4gIGlmIChzdmcpIHtcbiAgICBpZiAoaXNSb290U1ZHKSB7XG4gICAgICBiID0gX2dldENUTShlbGVtZW50KTtcbiAgICAgIHggPSAtYi5lIC8gYi5hO1xuICAgICAgeSA9IC1iLmYgLyBiLmQ7XG4gICAgICBtID0gX2lkZW50aXR5TWF0cml4O1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5nZXRCQm94KSB7XG4gICAgICBiID0gZWxlbWVudC5nZXRCQm94KCk7XG4gICAgICBtID0gZWxlbWVudC50cmFuc2Zvcm0gPyBlbGVtZW50LnRyYW5zZm9ybS5iYXNlVmFsIDoge307IC8vIElFMTEgZG9lc24ndCBmb2xsb3cgdGhlIHNwZWMuXG5cbiAgICAgIG0gPSAhbS5udW1iZXJPZkl0ZW1zID8gX2lkZW50aXR5TWF0cml4IDogbS5udW1iZXJPZkl0ZW1zID4gMSA/IF9jb25zb2xpZGF0ZShtKSA6IG0uZ2V0SXRlbSgwKS5tYXRyaXg7IC8vIGRvbid0IGNhbGwgbS5jb25zb2xpZGF0ZSgpLm1hdHJpeCBiZWNhdXNlIGEgYnVnIGluIEZpcmVmb3ggbWFrZXMgcG9pbnRlciBldmVudHMgbm90IHdvcmsgd2hlbiBjb25zb2xpZGF0ZSgpIGlzIGNhbGxlZCBvbiB0aGUgc2FtZSB0aWNrIGFzIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpISBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuXG4gICAgICB4ID0gbS5hICogYi54ICsgbS5jICogYi55O1xuICAgICAgeSA9IG0uYiAqIGIueCArIG0uZCAqIGIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWF5IGJlIGEgPG1hc2s+IHdoaWNoIGhhcyBubyBnZXRCQm94KCkgc28ganVzdCB1c2UgZGVmYXVsdHMgaW5zdGVhZCBvZiB0aHJvd2luZyBlcnJvcnMuXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKCk7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdEdPZmZzZXQgJiYgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgKGlzUm9vdFNWRyA/IHN2ZyA6IHBhcmVudCkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbS5hICsgXCIsXCIgKyBtLmIgKyBcIixcIiArIG0uYyArIFwiLFwiICsgbS5kICsgXCIsXCIgKyAobS5lICsgeCkgKyBcIixcIiArIChtLmYgKyB5KSArIFwiKVwiKTtcbiAgfSBlbHNlIHtcbiAgICB4ID0geSA9IDA7XG5cbiAgICBpZiAoX2hhc09mZnNldEJ1Zykge1xuICAgICAgLy8gc29tZSBicm93c2VycyAobGlrZSBTYWZhcmkpIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBtaXNyZXBvcnQgb2Zmc2V0IHZhbHVlcy4gV2hlbiBhbiBhbmNlc3RvciBlbGVtZW50IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkLCBpdCdzIHN1cHBvc2VkIHRvIHRyZWF0IGl0IGFzIGlmIGl0J3MgcG9zaXRpb246IHJlbGF0aXZlIChuZXcgY29udGV4dCkuIFNhZmFyaSBib3RjaGVzIHRoaXMsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBhbmNlc3RvciAoYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCkgdGhhdCBoYXMgYSB0cmFuc2Zvcm0gYXBwbGllZCBhbmQgaWYgb25lIGlzIGZvdW5kLCBncmFiIGl0cyBvZmZzZXRUb3AvTGVmdCBhbmQgc3VidHJhY3QgdGhlbSB0byBjb21wZW5zYXRlLlxuICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgYiA9IGVsZW1lbnQ7XG5cbiAgICAgIHdoaWxlIChiICYmIChiID0gYi5wYXJlbnROb2RlKSAmJiBiICE9PSBtICYmIGIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShiKVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgeCA9IGIub2Zmc2V0TGVmdDtcbiAgICAgICAgICB5ID0gYi5vZmZzZXRUb3A7XG4gICAgICAgICAgYiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjcyA9IF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiICYmIGNzLnBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcbiAgICAgIG0gPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IG0pIHtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbiBhbmNlc3RvciBlbGVtZW50IGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kIGl0cyBvZmZzZXRQYXJlbnQgdGhhdCdzIHNjcm9sbGVkLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluLlxuICAgICAgICB4ICs9IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHkgKz0gcGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGIudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgLSB5ICsgXCJweFwiO1xuICAgIGIubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCAtIHggKyBcInB4XCI7XG4gICAgYltfdHJhbnNmb3JtUHJvcF0gPSBjc1tfdHJhbnNmb3JtUHJvcF07XG4gICAgYltfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBjc1tfdHJhbnNmb3JtT3JpZ2luUHJvcF07IC8vIGIuYm9yZGVyID0gbS5ib3JkZXI7XG4gICAgLy8gYi5ib3JkZXJMZWZ0U3R5bGUgPSBtLmJvcmRlckxlZnRTdHlsZTtcbiAgICAvLyBiLmJvcmRlclRvcFN0eWxlID0gbS5ib3JkZXJUb3BTdHlsZTtcbiAgICAvLyBiLmJvcmRlckxlZnRXaWR0aCA9IG0uYm9yZGVyTGVmdFdpZHRoO1xuICAgIC8vIGIuYm9yZGVyVG9wV2lkdGggPSBtLmJvcmRlclRvcFdpZHRoO1xuXG4gICAgYi5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyO1xufSxcbiAgICBfc2V0TWF0cml4ID0gZnVuY3Rpb24gX3NldE1hdHJpeChtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIG0uYSA9IGE7XG4gIG0uYiA9IGI7XG4gIG0uYyA9IGM7XG4gIG0uZCA9IGQ7XG4gIG0uZSA9IGU7XG4gIG0uZiA9IGY7XG4gIHJldHVybiBtO1xufTtcblxuZXhwb3J0IHZhciBNYXRyaXgyRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gdm9pZCAwKSB7XG4gICAgICBjID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gdm9pZCAwKSB7XG4gICAgICBkID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZiA9PT0gdm9pZCAwKSB7XG4gICAgICBmID0gMDtcbiAgICB9XG5cbiAgICBfc2V0TWF0cml4KHRoaXMsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGRldGVybWluYW50ID0gYSAqIGQgLSBiICogYyB8fCAxZS0xMDtcbiAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBkIC8gZGV0ZXJtaW5hbnQsIC1iIC8gZGV0ZXJtaW5hbnQsIC1jIC8gZGV0ZXJtaW5hbnQsIGEgLyBkZXRlcm1pbmFudCwgKGMgKiBmIC0gZCAqIGUpIC8gZGV0ZXJtaW5hbnQsIC0oYSAqIGYgLSBiICogZSkgLyBkZXRlcm1pbmFudCk7XG4gIH07XG5cbiAgX3Byb3RvLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGEyID0gbWF0cml4LmEsXG4gICAgICAgIGIyID0gbWF0cml4LmMsXG4gICAgICAgIGMyID0gbWF0cml4LmIsXG4gICAgICAgIGQyID0gbWF0cml4LmQsXG4gICAgICAgIGUyID0gbWF0cml4LmUsXG4gICAgICAgIGYyID0gbWF0cml4LmY7XG4gICAgcmV0dXJuIF9zZXRNYXRyaXgodGhpcywgYTIgKiBhICsgYzIgKiBjLCBhMiAqIGIgKyBjMiAqIGQsIGIyICogYSArIGQyICogYywgYjIgKiBiICsgZDIgKiBkLCBlICsgZTIgKiBhICsgZjIgKiBjLCBmICsgZTIgKiBiICsgZjIgKiBkKTtcbiAgfTtcblxuICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgcmV0dXJuIGEgPT09IG1hdHJpeC5hICYmIGIgPT09IG1hdHJpeC5iICYmIGMgPT09IG1hdHJpeC5jICYmIGQgPT09IG1hdHJpeC5kICYmIGUgPT09IG1hdHJpeC5lICYmIGYgPT09IG1hdHJpeC5mO1xuICB9O1xuXG4gIF9wcm90by5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KHBvaW50LCBkZWNvcmF0ZWUpIHtcbiAgICBpZiAoZGVjb3JhdGVlID09PSB2b2lkIDApIHtcbiAgICAgIGRlY29yYXRlZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgZGVjb3JhdGVlLnggPSB4ICogYSArIHkgKiBjICsgZSB8fCAwO1xuICAgIGRlY29yYXRlZS55ID0geCAqIGIgKyB5ICogZCArIGYgfHwgMDtcbiAgICByZXR1cm4gZGVjb3JhdGVlO1xuICB9O1xuXG4gIHJldHVybiBNYXRyaXgyRDtcbn0oKTsgLy8gRmVlZCBpbiBhbiBlbGVtZW50IGFuZCBpdCdsbCByZXR1cm4gYSAyRCBtYXRyaXggKG9wdGlvbmFsbHkgaW52ZXJ0ZWQpIHNvIHRoYXQgeW91IGNhbiB0cmFuc2xhdGUgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcy5cbi8vIEludmVydGluZyBsZXRzIHlvdSB0cmFuc2xhdGUgYSBnbG9iYWwgcG9pbnQgaW50byBhIGxvY2FsIGNvb3JkaW5hdGUgc3BhY2UuIE5vIGludmVydGluZyBsZXRzIHlvdSBnbyB0aGUgb3RoZXIgd2F5LlxuLy8gV2UgbmVlZGVkIHRoaXMgdG8gd29yayBhcm91bmQgdmFyaW91cyBicm93c2VyIGJ1Z3MsIGxpa2UgRmlyZWZveCBkb2Vzbid0IGFjY3VyYXRlbHkgcmVwb3J0IGdldFNjcmVlbkNUTSgpIHdoZW4gdGhlcmVcbi8vIGFyZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gYW5jZXN0b3IgZWxlbWVudHMuXG4vLyBUaGUgbWF0cml4IG1hdGggdG8gY29udmVydCBhbnkgeC95IGNvb3JkaW5hdGUgaXMgYXMgZm9sbG93cywgd2hpY2ggaXMgd3JhcHBlZCBpbiBhIGNvbnZlbmllbnQgYXBwbHkoKSBtZXRob2Qgb2YgTWF0cml4MkQgYWJvdmU6XG4vLyAgICAgdHggPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxuLy8gICAgIHR5ID0gbS5iICogeCArIG0uZCAqIHkgKyBtLmZcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbE1hdHJpeChlbGVtZW50LCBpbnZlcnNlLCBhZGp1c3RHT2Zmc2V0LCBpbmNsdWRlU2Nyb2xsSW5GaXhlZCkge1xuICAvLyBhZGp1c3RHT2Zmc2V0IGlzIHR5cGljYWxseSB1c2VkIG9ubHkgd2hlbiBncmFiYmluZyBhbiBlbGVtZW50J3MgUEFSRU5UJ3MgZ2xvYmFsIG1hdHJpeCwgYW5kIGl0IGlnbm9yZXMgdGhlIHgveSBvZmZzZXQgb2YgYW55IFNWRyA8Zz4gZWxlbWVudHMgYmVjYXVzZSB0aGV5IGJlaGF2ZSBpbiBhIHNwZWNpYWwgd2F5LlxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSB8fCAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKS5kb2N1bWVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKCk7XG4gIH1cblxuICB2YXIgemVyb1NjYWxlcyA9IF9mb3JjZU5vblplcm9TY2FsZShlbGVtZW50KSxcbiAgICAgIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIHRlbXBzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgY29udGFpbmVyID0gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCksXG4gICAgICBiMSA9IHRlbXBzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgYjIgPSB0ZW1wc1sxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGIzID0gdGVtcHNbMl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZSxcbiAgICAgIGlzRml4ZWQgPSAhaW5jbHVkZVNjcm9sbEluRml4ZWQgJiYgX2lzRml4ZWQoZWxlbWVudCksXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKChiMi5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMi50b3AgLSBiMS50b3ApIC8gMTAwLCAoYjMubGVmdCAtIGIxLmxlZnQpIC8gMTAwLCAoYjMudG9wIC0gYjEudG9wKSAvIDEwMCwgYjEubGVmdCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxMZWZ0KCkpLCBiMS50b3AgKyAoaXNGaXhlZCA/IDAgOiBfZ2V0RG9jU2Nyb2xsVG9wKCkpKTtcblxuICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICBpZiAoemVyb1NjYWxlcykge1xuICAgIGIxID0gemVyb1NjYWxlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYjEtLSkge1xuICAgICAgYjIgPSB6ZXJvU2NhbGVzW2IxXTtcbiAgICAgIGIyLnNjYWxlWCA9IGIyLnNjYWxlWSA9IDA7XG4gICAgICBiMi5yZW5kZXJUcmFuc2Zvcm0oMSwgYjIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnZlcnNlID8gbS5pbnZlcnNlKCkgOiBtO1xufVxuZXhwb3J0IHsgX2dldERvY1Njcm9sbFRvcCwgX2dldERvY1Njcm9sbExlZnQsIF9zZXREb2MsIF9pc0ZpeGVkLCBfZ2V0Q1RNIH07IC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRNYXRyaXgoZWxlbWVudCkge1xuLy8gXHRfZG9jIHx8IF9zZXREb2MoZWxlbWVudCk7XG4vLyBcdGxldCBtID0gKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5zdWJzdHIoNykubWF0Y2goL1stLl0qXFxkK1suZVxcLStdKlxcZCpbZVxcLVxcK10qXFxkKi9nKSxcbi8vIFx0XHRpczJEID0gbSAmJiBtLmxlbmd0aCA9PT0gNjtcbi8vIFx0cmV0dXJuICFtIHx8IG0ubGVuZ3RoIDwgNiA/IG5ldyBNYXRyaXgyRCgpIDogbmV3IE1hdHJpeDJEKCttWzBdLCArbVsxXSwgK21baXMyRCA/IDIgOiA0XSwgK21baXMyRCA/IDMgOiA1XSwgK21baXMyRCA/IDQgOiAxMl0sICttW2lzMkQgPyA1IDogMTNdKTtcbi8vIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/utils/matrix.js\n"));

/***/ }),

/***/ "./node_modules/gsap/utils/paths.js":
/*!******************************************!*\
  !*** ./node_modules/gsap/utils/paths.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bezierToPoints\": function() { return /* binding */ bezierToPoints; },\n/* harmony export */   \"cacheRawPathMeasurements\": function() { return /* binding */ cacheRawPathMeasurements; },\n/* harmony export */   \"convertToPath\": function() { return /* binding */ convertToPath; },\n/* harmony export */   \"copyRawPath\": function() { return /* binding */ copyRawPath; },\n/* harmony export */   \"flatPointsToSegment\": function() { return /* binding */ flatPointsToSegment; },\n/* harmony export */   \"getClosestData\": function() { return /* binding */ getClosestData; },\n/* harmony export */   \"getPositionOnPath\": function() { return /* binding */ getPositionOnPath; },\n/* harmony export */   \"getRawPath\": function() { return /* binding */ getRawPath; },\n/* harmony export */   \"getRotationAtProgress\": function() { return /* binding */ getRotationAtProgress; },\n/* harmony export */   \"pointsToSegment\": function() { return /* binding */ pointsToSegment; },\n/* harmony export */   \"rawPathToString\": function() { return /* binding */ rawPathToString; },\n/* harmony export */   \"reverseSegment\": function() { return /* binding */ reverseSegment; },\n/* harmony export */   \"simplifyPoints\": function() { return /* binding */ simplifyPoints; },\n/* harmony export */   \"sliceRawPath\": function() { return /* binding */ sliceRawPath; },\n/* harmony export */   \"stringToRawPath\": function() { return /* binding */ stringToRawPath; },\n/* harmony export */   \"subdivideSegment\": function() { return /* binding */ subdivideSegment; },\n/* harmony export */   \"subdivideSegmentNear\": function() { return /* binding */ subdivideSegmentNear; },\n/* harmony export */   \"transformRawPath\": function() { return /* binding */ transformRawPath; }\n/* harmony export */ });\n/*!\n * paths 3.11.2\n * https://greensock.com\n *\n * Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n    _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n    _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n    _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n    _DEG2RAD = Math.PI / 180,\n    _RAD2DEG = 180 / Math.PI,\n    _sin = Math.sin,\n    _cos = Math.cos,\n    _abs = Math.abs,\n    _sqrt = Math.sqrt,\n    _atan2 = Math.atan2,\n    _largeNum = 1e8,\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === \"undefined\";\n},\n    _temp = {},\n    _temp2 = {},\n    _roundingNum = 1e5,\n    _wrapProgress = function _wrapProgress(progress) {\n  return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);\n},\n    //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.\n_round = function _round(value) {\n  return Math.round(value * _roundingNum) / _roundingNum || 0;\n},\n    _roundPrecise = function _roundPrecise(value) {\n  return Math.round(value * 1e10) / 1e10 || 0;\n},\n    _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {\n  var segment = rawPath[segIndex],\n      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);\n\n  if (shift && shift + i + 2 < segment.length) {\n    rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));\n    segment.splice(0, i + shift);\n    return 1;\n  }\n},\n    _getSampleIndex = function _getSampleIndex(samples, length, progress) {\n  // slightly slower way than doing this (when there's no lookup): segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;\n  var l = samples.length,\n      i = ~~(progress * l);\n\n  if (samples[i] > length) {\n    while (--i && samples[i] > length) {}\n\n    i < 0 && (i = 0);\n  } else {\n    while (samples[++i] < length && i < l) {}\n  }\n\n  return i < l ? i : l - 1;\n},\n    _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {\n  var i = rawPath.length;\n  skipOuter || rawPath.reverse();\n\n  while (i--) {\n    rawPath[i].reversed || reverseSegment(rawPath[i]);\n  }\n},\n    _copyMetaData = function _copyMetaData(source, copy) {\n  copy.totalLength = source.totalLength;\n\n  if (source.samples) {\n    //segment\n    copy.samples = source.samples.slice(0);\n    copy.lookup = source.lookup.slice(0);\n    copy.minLength = source.minLength;\n    copy.resolution = source.resolution;\n  } else if (source.totalPoints) {\n    //rawPath\n    copy.totalPoints = source.totalPoints;\n  }\n\n  return copy;\n},\n    //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)\n_appendOrMerge = function _appendOrMerge(rawPath, segment) {\n  var index = rawPath.length,\n      prevSeg = rawPath[index - 1] || [],\n      l = prevSeg.length;\n\n  if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {\n    segment = prevSeg.concat(segment.slice(2));\n    index--;\n  }\n\n  rawPath[index] = segment;\n},\n    _bestDistance;\n/* TERMINOLOGY\n - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple \"M\" commands, defining Segments (paths aren't always connected).\n - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.\n - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.\n - the variable \"t\" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the \"p\" or \"progress\" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. \"t\" is ONLY in an individual Bezier piece.\n */\n//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).\n\n\nfunction getRawPath(value) {\n  value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;\n  var e = value.getAttribute ? value : 0,\n      rawPath;\n\n  if (e && (value = value.getAttribute(\"d\"))) {\n    //implements caching\n    if (!e._gsPath) {\n      e._gsPath = {};\n    }\n\n    rawPath = e._gsPath[value];\n    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);\n  }\n\n  return !value ? console.warn(\"Expecting a <path> element or an SVG path data string\") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;\n} //copies a RawPath WITHOUT the length meta data (for speed)\n\nfunction copyRawPath(rawPath) {\n  var a = [],\n      i = 0;\n\n  for (; i < rawPath.length; i++) {\n    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));\n  }\n\n  return _copyMetaData(rawPath, a);\n}\nfunction reverseSegment(segment) {\n  var i = 0,\n      y;\n  segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.\n\n  for (; i < segment.length; i += 2) {\n    y = segment[i];\n    segment[i] = segment[i + 1];\n    segment[i + 1] = y;\n  }\n\n  segment.reversed = !segment.reversed;\n}\n\nvar _createPath = function _createPath(e, ignore) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"),\n      attr = [].slice.call(e.attributes),\n      i = attr.length,\n      name;\n  ignore = \",\" + ignore + \",\";\n\n  while (--i > -1) {\n    name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.\n\n    if (ignore.indexOf(\",\" + name + \",\") < 0) {\n      path.setAttributeNS(null, name, attr[i].nodeValue);\n    }\n  }\n\n  return path;\n},\n    _typeAttrs = {\n  rect: \"rx,ry,x,y,width,height\",\n  circle: \"r,cx,cy\",\n  ellipse: \"rx,ry,cx,cy\",\n  line: \"x1,x2,y1,y2\"\n},\n    _attrToObj = function _attrToObj(e, attrs) {\n  var props = attrs ? attrs.split(\",\") : [],\n      obj = {},\n      i = props.length;\n\n  while (--i > -1) {\n    obj[props[i]] = +e.getAttribute(props[i]) || 0;\n  }\n\n  return obj;\n}; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.\n\n\nfunction convertToPath(element, swap) {\n  var type = element.tagName.toLowerCase(),\n      circ = 0.552284749831,\n      data,\n      x,\n      y,\n      r,\n      ry,\n      path,\n      rcirc,\n      rycirc,\n      points,\n      w,\n      h,\n      x2,\n      x3,\n      x4,\n      x5,\n      x6,\n      y2,\n      y3,\n      y4,\n      y5,\n      y6,\n      attr;\n\n  if (type === \"path\" || !element.getBBox) {\n    return element;\n  }\n\n  path = _createPath(element, \"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points\");\n  attr = _attrToObj(element, _typeAttrs[type]);\n\n  if (type === \"rect\") {\n    r = attr.rx;\n    ry = attr.ry || r;\n    x = attr.x;\n    y = attr.y;\n    w = attr.width - r * 2;\n    h = attr.height - ry * 2;\n\n    if (r || ry) {\n      //if there are rounded corners, render cubic beziers\n      x2 = x + r * (1 - circ);\n      x3 = x + r;\n      x4 = x3 + w;\n      x5 = x4 + r * circ;\n      x6 = x4 + r;\n      y2 = y + ry * (1 - circ);\n      y3 = y + ry;\n      y4 = y3 + h;\n      y5 = y4 + ry * circ;\n      y6 = y4 + ry;\n      data = \"M\" + x6 + \",\" + y3 + \" V\" + y4 + \" C\" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(\",\") + \"z\";\n    } else {\n      data = \"M\" + (x + w) + \",\" + y + \" v\" + h + \" h\" + -w + \" v\" + -h + \" h\" + w + \"z\";\n    }\n  } else if (type === \"circle\" || type === \"ellipse\") {\n    if (type === \"circle\") {\n      r = ry = attr.r;\n      rycirc = r * circ;\n    } else {\n      r = attr.rx;\n      ry = attr.ry;\n      rycirc = ry * circ;\n    }\n\n    x = attr.cx;\n    y = attr.cy;\n    rcirc = r * circ;\n    data = \"M\" + (x + r) + \",\" + y + \" C\" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(\",\") + \"z\";\n  } else if (type === \"line\") {\n    data = \"M\" + attr.x1 + \",\" + attr.y1 + \" L\" + attr.x2 + \",\" + attr.y2; //previously, we just converted to \"Mx,y Lx,y\" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.\n  } else if (type === \"polyline\" || type === \"polygon\") {\n    points = (element.getAttribute(\"points\") + \"\").match(_numbersExp) || [];\n    x = points.shift();\n    y = points.shift();\n    data = \"M\" + x + \",\" + y + \" L\" + points.join(\",\");\n\n    if (type === \"polygon\") {\n      data += \",\" + x + \",\" + y + \"z\";\n    }\n  }\n\n  path.setAttribute(\"d\", rawPathToString(path._gsRawPath = stringToRawPath(data)));\n\n  if (swap && element.parentNode) {\n    element.parentNode.insertBefore(path, element);\n    element.parentNode.removeChild(element);\n  }\n\n  return path;\n} //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)\n\nfunction getRotationAtProgress(rawPath, progress) {\n  var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);\n  return getRotationAtBezierT(d.segment, d.i, d.t);\n}\n\nfunction getRotationAtBezierT(segment, i, t) {\n  var a = segment[i],\n      b = segment[i + 2],\n      c = segment[i + 4],\n      x;\n  a += (b - a) * t;\n  b += (c - b) * t;\n  a += (b - a) * t;\n  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;\n  a = segment[i + 1];\n  b = segment[i + 3];\n  c = segment[i + 5];\n  a += (b - a) * t;\n  b += (c - b) * t;\n  a += (b - a) * t;\n  return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);\n}\n\nfunction sliceRawPath(rawPath, start, end) {\n  end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.\n\n  start = _roundPrecise(start) || 0;\n  var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),\n      path = copyRawPath(rawPath);\n\n  if (start > end) {\n    start = 1 - start;\n    end = 1 - end;\n\n    _reverseRawPath(path);\n\n    path.totalLength = 0;\n  }\n\n  if (start < 0 || end < 0) {\n    var offset = Math.abs(~~Math.min(start, end)) + 1;\n    start += offset;\n    end += offset;\n  }\n\n  path.totalLength || cacheRawPathMeasurements(path);\n  var wrap = end > 1,\n      s = getProgressData(path, start, _temp, true),\n      e = getProgressData(path, end, _temp2),\n      eSeg = e.segment,\n      sSeg = s.segment,\n      eSegIndex = e.segIndex,\n      sSegIndex = s.segIndex,\n      ei = e.i,\n      si = s.i,\n      sameSegment = sSegIndex === eSegIndex,\n      sameBezier = ei === si && sameSegment,\n      wrapsBehind,\n      sShift,\n      eShift,\n      i,\n      copy,\n      totalSegments,\n      l,\n      j;\n\n  if (wrap || loops) {\n    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;\n\n    if (_splitSegment(path, sSegIndex, si, s.t)) {\n      sSegIndex++;\n\n      if (!wrapsBehind) {\n        eSegIndex++;\n\n        if (sameBezier) {\n          e.t = (e.t - s.t) / (1 - s.t);\n          ei = 0;\n        } else if (sameSegment) {\n          ei -= si;\n        }\n      }\n    }\n\n    if (Math.abs(1 - (end - start)) < 1e-5) {\n      eSegIndex = sSegIndex - 1;\n    } else if (!e.t && eSegIndex) {\n      eSegIndex--;\n    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {\n      sSegIndex++;\n    }\n\n    if (s.t === 1) {\n      sSegIndex = (sSegIndex + 1) % path.length;\n    }\n\n    copy = [];\n    totalSegments = path.length;\n    l = 1 + totalSegments * loops;\n    j = sSegIndex;\n    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;\n\n    for (i = 0; i < l; i++) {\n      _appendOrMerge(copy, path[j++ % totalSegments]);\n    }\n\n    path = copy;\n  } else {\n    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);\n\n    if (start !== end) {\n      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);\n      sameSegment && (eShift += sShift);\n      eSeg.splice(ei + eShift + 2);\n      (sShift || si) && sSeg.splice(0, si + sShift);\n      i = path.length;\n\n      while (i--) {\n        //chop off any extra segments\n        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);\n      }\n    } else {\n      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!\n\n      ei += eShift;\n      s = eSeg[ei];\n      e = eSeg[ei + 1];\n      eSeg.length = eSeg.totalLength = 0;\n      eSeg.totalPoints = path.totalPoints = 8;\n      eSeg.push(s, e, s, e, s, e, s, e);\n    }\n  }\n\n  path.totalLength = 0;\n  return path;\n} //measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a \"samples\" Array that has the length up to each of those sample points (always increasing from the start) as well as a \"lookup\" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a \"totalLength\" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.\n\nfunction measureSegment(segment, startIndex, bezierQty) {\n  startIndex = startIndex || 0;\n\n  if (!segment.samples) {\n    segment.samples = [];\n    segment.lookup = [];\n  }\n\n  var resolution = ~~segment.resolution || 12,\n      inc = 1 / resolution,\n      endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,\n      x1 = segment[startIndex],\n      y1 = segment[startIndex + 1],\n      samplesIndex = startIndex ? startIndex / 6 * resolution : 0,\n      samples = segment.samples,\n      lookup = segment.lookup,\n      min = (startIndex ? segment.minLength : _largeNum) || _largeNum,\n      prevLength = samples[samplesIndex + bezierQty * resolution - 1],\n      length = startIndex ? samples[samplesIndex - 1] : 0,\n      i,\n      j,\n      x4,\n      x3,\n      x2,\n      xd,\n      xd1,\n      y4,\n      y3,\n      y2,\n      yd,\n      yd1,\n      inv,\n      t,\n      lengthIndex,\n      l,\n      segLength;\n  samples.length = lookup.length = 0;\n\n  for (j = startIndex + 2; j < endIndex; j += 6) {\n    x4 = segment[j + 4] - x1;\n    x3 = segment[j + 2] - x1;\n    x2 = segment[j] - x1;\n    y4 = segment[j + 5] - y1;\n    y3 = segment[j + 3] - y1;\n    y2 = segment[j + 1] - y1;\n    xd = xd1 = yd = yd1 = 0;\n\n    if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {\n      //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)\n      if (segment.length > 8) {\n        segment.splice(j, 6);\n        j -= 6;\n        endIndex -= 6;\n      }\n    } else {\n      for (i = 1; i <= resolution; i++) {\n        t = inc * i;\n        inv = 1 - t;\n        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);\n        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);\n        l = _sqrt(yd * yd + xd * xd);\n\n        if (l < min) {\n          min = l;\n        }\n\n        length += l;\n        samples[samplesIndex++] = length;\n      }\n    }\n\n    x1 += x4;\n    y1 += y4;\n  }\n\n  if (prevLength) {\n    prevLength -= length;\n\n    for (; samplesIndex < samples.length; samplesIndex++) {\n      samples[samplesIndex] += prevLength;\n    }\n  }\n\n  if (samples.length && min) {\n    segment.totalLength = segLength = samples[samples.length - 1] || 0;\n    segment.minLength = min;\n\n    if (segLength / min < 9999) {\n      // if the lookup would require too many values (memory problem), we skip this and instead we use a loop to lookup values directly in the samples Array\n      l = lengthIndex = 0;\n\n      for (i = 0; i < segLength; i += min) {\n        lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;\n      }\n    }\n  } else {\n    segment.totalLength = samples[0] = 0;\n  }\n\n  return startIndex ? length - samples[startIndex / 2 - 1] : length;\n}\n\nfunction cacheRawPathMeasurements(rawPath, resolution) {\n  var pathLength, points, i;\n\n  for (i = pathLength = points = 0; i < rawPath.length; i++) {\n    rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)\n\n    points += rawPath[i].length;\n    pathLength += measureSegment(rawPath[i]);\n  }\n\n  rawPath.totalPoints = points;\n  rawPath.totalLength = pathLength;\n  return rawPath;\n} //divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)\n\nfunction subdivideSegment(segment, i, t) {\n  if (t <= 0 || t >= 1) {\n    return 0;\n  }\n\n  var ax = segment[i],\n      ay = segment[i + 1],\n      cp1x = segment[i + 2],\n      cp1y = segment[i + 3],\n      cp2x = segment[i + 4],\n      cp2y = segment[i + 5],\n      bx = segment[i + 6],\n      by = segment[i + 7],\n      x1a = ax + (cp1x - ax) * t,\n      x2 = cp1x + (cp2x - cp1x) * t,\n      y1a = ay + (cp1y - ay) * t,\n      y2 = cp1y + (cp2y - cp1y) * t,\n      x1 = x1a + (x2 - x1a) * t,\n      y1 = y1a + (y2 - y1a) * t,\n      x2a = cp2x + (bx - cp2x) * t,\n      y2a = cp2y + (by - cp2y) * t;\n  x2 += (x2a - x2) * t;\n  y2 += (y2a - y2) * t;\n  segment.splice(i + 2, 4, _round(x1a), //first control point\n  _round(y1a), _round(x1), //second control point\n  _round(y1), _round(x1 + (x2 - x1) * t), //new fabricated anchor on line\n  _round(y1 + (y2 - y1) * t), _round(x2), //third control point\n  _round(y2), _round(x2a), //fourth control point\n  _round(y2a));\n  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);\n  return 6;\n} // returns an object {path, segment, segIndex, i, t}\n\nfunction getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {\n  decoratee = decoratee || {};\n  rawPath.totalLength || cacheRawPathMeasurements(rawPath);\n\n  if (progress < 0 || progress > 1) {\n    progress = _wrapProgress(progress);\n  }\n\n  var segIndex = 0,\n      segment = rawPath[0],\n      samples,\n      resolution,\n      length,\n      min,\n      max,\n      i,\n      t;\n\n  if (!progress) {\n    t = i = segIndex = 0;\n    segment = rawPath[0];\n  } else if (progress === 1) {\n    t = 1;\n    segIndex = rawPath.length - 1;\n    segment = rawPath[segIndex];\n    i = segment.length - 8;\n  } else {\n    if (rawPath.length > 1) {\n      //speed optimization: most of the time, there's only one segment so skip the recursion.\n      length = rawPath.totalLength * progress;\n      max = i = 0;\n\n      while ((max += rawPath[i++].totalLength) < length) {\n        segIndex = i;\n      }\n\n      segment = rawPath[segIndex];\n      min = max - segment.totalLength;\n      progress = (length - min) / (max - min) || 0;\n    }\n\n    samples = segment.samples;\n    resolution = segment.resolution; //how many samples per cubic bezier chunk\n\n    length = segment.totalLength * progress;\n    i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);\n    min = i ? samples[i - 1] : 0;\n    max = samples[i];\n\n    if (max < length) {\n      min = max;\n      max = samples[++i];\n    }\n\n    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);\n    i = ~~(i / resolution) * 6;\n\n    if (pushToNextIfAtEnd && t === 1) {\n      if (i + 6 < segment.length) {\n        i += 6;\n        t = 0;\n      } else if (segIndex + 1 < rawPath.length) {\n        i = t = 0;\n        segment = rawPath[++segIndex];\n      }\n    }\n  }\n\n  decoratee.t = t;\n  decoratee.i = i;\n  decoratee.path = rawPath;\n  decoratee.segment = segment;\n  decoratee.segIndex = segIndex;\n  return decoratee;\n}\n\nfunction getPositionOnPath(rawPath, progress, includeAngle, point) {\n  var segment = rawPath[0],\n      result = point || {},\n      samples,\n      resolution,\n      length,\n      min,\n      max,\n      i,\n      t,\n      a,\n      inv;\n\n  if (progress < 0 || progress > 1) {\n    progress = _wrapProgress(progress);\n  }\n\n  if (rawPath.length > 1) {\n    //speed optimization: most of the time, there's only one segment so skip the recursion.\n    length = rawPath.totalLength * progress;\n    max = i = 0;\n\n    while ((max += rawPath[i++].totalLength) < length) {\n      segment = rawPath[i];\n    }\n\n    min = max - segment.totalLength;\n    progress = (length - min) / (max - min) || 0;\n  }\n\n  samples = segment.samples;\n  resolution = segment.resolution;\n  length = segment.totalLength * progress;\n  i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);\n  min = i ? samples[i - 1] : 0;\n  max = samples[i];\n\n  if (max < length) {\n    min = max;\n    max = samples[++i];\n  }\n\n  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;\n  inv = 1 - t;\n  i = ~~(i / resolution) * 6;\n  a = segment[i];\n  result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);\n  result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);\n\n  if (includeAngle) {\n    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;\n  }\n\n  return result;\n} //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).\n\nfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\n  var j = rawPath.length,\n      segment,\n      l,\n      i,\n      x,\n      y;\n\n  while (--j > -1) {\n    segment = rawPath[j];\n    l = segment.length;\n\n    for (i = 0; i < l; i += 2) {\n      x = segment[i];\n      y = segment[i + 1];\n      segment[i] = x * a + y * c + tx;\n      segment[i + 1] = x * b + y * d + ty;\n    }\n  }\n\n  rawPath._dirty = 1;\n  return rawPath;\n} // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.\n\nfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n  if (lastX === x && lastY === y) {\n    return;\n  }\n\n  rx = _abs(rx);\n  ry = _abs(ry);\n\n  var angleRad = angle % 360 * _DEG2RAD,\n      cosAngle = _cos(angleRad),\n      sinAngle = _sin(angleRad),\n      PI = Math.PI,\n      TWOPI = PI * 2,\n      dx2 = (lastX - x) / 2,\n      dy2 = (lastY - y) / 2,\n      x1 = cosAngle * dx2 + sinAngle * dy2,\n      y1 = -sinAngle * dx2 + cosAngle * dy2,\n      x1_sq = x1 * x1,\n      y1_sq = y1 * y1,\n      radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n\n  if (radiiCheck > 1) {\n    rx = _sqrt(radiiCheck) * rx;\n    ry = _sqrt(radiiCheck) * ry;\n  }\n\n  var rx_sq = rx * rx,\n      ry_sq = ry * ry,\n      sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\n\n  if (sq < 0) {\n    sq = 0;\n  }\n\n  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),\n      cx1 = coef * (rx * y1 / ry),\n      cy1 = coef * -(ry * x1 / rx),\n      sx2 = (lastX + x) / 2,\n      sy2 = (lastY + y) / 2,\n      cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\n      cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\n      ux = (x1 - cx1) / rx,\n      uy = (y1 - cy1) / ry,\n      vx = (-x1 - cx1) / rx,\n      vy = (-y1 - cy1) / ry,\n      temp = ux * ux + uy * uy,\n      angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\n      angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n\n  isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.\n\n  if (!sweepFlag && angleExtent > 0) {\n    angleExtent -= TWOPI;\n  } else if (sweepFlag && angleExtent < 0) {\n    angleExtent += TWOPI;\n  }\n\n  angleStart %= TWOPI;\n  angleExtent %= TWOPI;\n\n  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),\n      rawPath = [],\n      angleIncrement = angleExtent / segments,\n      controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\n      ma = cosAngle * rx,\n      mb = sinAngle * rx,\n      mc = sinAngle * -ry,\n      md = cosAngle * ry,\n      i;\n\n  for (i = 0; i < segments; i++) {\n    angle = angleStart + i * angleIncrement;\n    x1 = _cos(angle);\n    y1 = _sin(angle);\n    ux = _cos(angle += angleIncrement);\n    uy = _sin(angle);\n    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n  } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n\n\n  for (i = 0; i < rawPath.length; i += 2) {\n    x1 = rawPath[i];\n    y1 = rawPath[i + 1];\n    rawPath[i] = x1 * ma + y1 * mc + cx;\n    rawPath[i + 1] = x1 * mb + y1 * md + cy;\n  }\n\n  rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be\n\n  rawPath[i - 1] = y;\n  return rawPath;\n} //Spits back a RawPath with absolute coordinates. Each segment starts with a \"moveTo\" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\n\n\nfunction stringToRawPath(d) {\n  var a = (d + \"\").replace(_scientific, function (m) {\n    var n = +m;\n    return n < 0.0001 && n > -0.0001 ? 0 : n;\n  }).match(_svgPathExp) || [],\n      //some authoring programs spit out very small numbers in scientific notation like \"1e-5\", so make sure we round that down to 0 first.\n  path = [],\n      relativeX = 0,\n      relativeY = 0,\n      twoThirds = 2 / 3,\n      elements = a.length,\n      points = 0,\n      errorMessage = \"ERROR: malformed path: \" + d,\n      i,\n      j,\n      x,\n      y,\n      command,\n      isRelative,\n      segment,\n      startX,\n      startY,\n      difX,\n      difY,\n      beziers,\n      prevCommand,\n      flag1,\n      flag2,\n      line = function line(sx, sy, ex, ey) {\n    difX = (ex - sx) / 3;\n    difY = (ey - sy) / 3;\n    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n  };\n\n  if (!d || !isNaN(a[0]) || isNaN(a[1])) {\n    console.log(errorMessage);\n    return path;\n  }\n\n  for (i = 0; i < elements; i++) {\n    prevCommand = command;\n\n    if (isNaN(a[i])) {\n      command = a[i].toUpperCase();\n      isRelative = command !== a[i]; //lower case means relative\n    } else {\n      //commands like \"C\" can be strung together without any new command characters between.\n      i--;\n    }\n\n    x = +a[i + 1];\n    y = +a[i + 2];\n\n    if (isRelative) {\n      x += relativeX;\n      y += relativeY;\n    }\n\n    if (!i) {\n      startX = x;\n      startY = y;\n    } // \"M\" (move)\n\n\n    if (command === \"M\") {\n      if (segment) {\n        if (segment.length < 8) {\n          //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n          path.length -= 1;\n        } else {\n          points += segment.length;\n        }\n      }\n\n      relativeX = startX = x;\n      relativeY = startY = y;\n      segment = [x, y];\n      path.push(segment);\n      i += 2;\n      command = \"L\"; //an \"M\" with more than 2 values gets interpreted as \"lineTo\" commands (\"L\").\n      // \"C\" (cubic bezier)\n    } else if (command === \"C\") {\n      if (!segment) {\n        segment = [0, 0];\n      }\n\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      } //note: \"*1\" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n\n\n      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\n      i += 6; // \"S\" (continuation of cubic bezier)\n    } else if (command === \"S\") {\n      difX = relativeX;\n      difY = relativeY;\n\n      if (prevCommand === \"C\" || prevCommand === \"S\") {\n        difX += relativeX - segment[segment.length - 4];\n        difY += relativeY - segment[segment.length - 3];\n      }\n\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n\n      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\n      i += 4; // \"Q\" (quadratic bezier)\n    } else if (command === \"Q\") {\n      difX = relativeX + (x - relativeX) * twoThirds;\n      difY = relativeY + (y - relativeY) * twoThirds;\n\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n\n      relativeX += a[i + 3] * 1;\n      relativeY += a[i + 4] * 1;\n      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n      i += 4; // \"T\" (continuation of quadratic bezier)\n    } else if (command === \"T\") {\n      difX = relativeX - segment[segment.length - 4];\n      difY = relativeY - segment[segment.length - 3];\n      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\n      i += 2; // \"H\" (horizontal line)\n    } else if (command === \"H\") {\n      line(relativeX, relativeY, relativeX = x, relativeY);\n      i += 1; // \"V\" (vertical line)\n    } else if (command === \"V\") {\n      //adjust values because the first (and only one) isn't x in this case, it's y.\n      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\n      i += 1; // \"L\" (line) or \"Z\" (close)\n    } else if (command === \"L\" || command === \"Z\") {\n      if (command === \"Z\") {\n        x = startX;\n        y = startY;\n        segment.closed = true;\n      }\n\n      if (command === \"L\" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\n        line(relativeX, relativeY, x, y);\n\n        if (command === \"L\") {\n          i += 2;\n        }\n      }\n\n      relativeX = x;\n      relativeY = y; // \"A\" (arc)\n    } else if (command === \"A\") {\n      flag1 = a[i + 4];\n      flag2 = a[i + 5];\n      difX = a[i + 6];\n      difY = a[i + 7];\n      j = 7;\n\n      if (flag1.length > 1) {\n        // for cases when the flags are merged, like \"a8 8 0 018 8\" (the 0 and 1 flags are WITH the x value of 8, but it could also be \"a8 8 0 01-8 8\" so it may include x or not)\n        if (flag1.length < 3) {\n          difY = difX;\n          difX = flag2;\n          j--;\n        } else {\n          difY = flag2;\n          difX = flag1.substr(2);\n          j -= 2;\n        }\n\n        flag2 = flag1.charAt(1);\n        flag1 = flag1.charAt(0);\n      }\n\n      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\n      i += j;\n\n      if (beziers) {\n        for (j = 0; j < beziers.length; j++) {\n          segment.push(beziers[j]);\n        }\n      }\n\n      relativeX = segment[segment.length - 2];\n      relativeY = segment[segment.length - 1];\n    } else {\n      console.log(errorMessage);\n    }\n  }\n\n  i = segment.length;\n\n  if (i < 6) {\n    //in case there's odd SVG like a M0,0 command at the very end.\n    path.pop();\n    i = 0;\n  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\n    segment.closed = true;\n  }\n\n  path.totalPoints = points + i;\n  return path;\n} //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays\n\nfunction bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n  var x12 = (x1 + x2) / 2,\n      y12 = (y1 + y2) / 2,\n      x23 = (x2 + x3) / 2,\n      y23 = (y2 + y3) / 2,\n      x34 = (x3 + x4) / 2,\n      y34 = (y3 + y4) / 2,\n      x123 = (x12 + x23) / 2,\n      y123 = (y12 + y23) / 2,\n      x234 = (x23 + x34) / 2,\n      y234 = (y23 + y34) / 2,\n      x1234 = (x123 + x234) / 2,\n      y1234 = (y123 + y234) / 2,\n      dx = x4 - x1,\n      dy = y4 - y1,\n      d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),\n      d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),\n      length;\n\n  if (!points) {\n    points = [x1, y1, x4, y4];\n    index = 2;\n  }\n\n  points.splice(index || points.length - 2, 0, x1234, y1234);\n\n  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n    length = points.length;\n    bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n    bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));\n  }\n\n  return points;\n}\n/*\nfunction getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians\n\tvar dx1 = x1 - x0,\n\t\tdy1 = y1 - y0,\n\t\tdx2 = x2 - x1,\n\t\tdy2 = y2 - y1,\n\t\tdx3 = x2 - x0,\n\t\tdy3 = y2 - y0,\n\t\ta = dx1 * dx1 + dy1 * dy1,\n\t\tb = dx2 * dx2 + dy2 * dy2,\n\t\tc = dx3 * dx3 + dy3 * dy3;\n\treturn Math.acos( (a + b - c) / _sqrt(4 * a * b) );\n},\n*/\n//pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)\n\nfunction flatPointsToSegment(points, curviness) {\n  if (curviness === void 0) {\n    curviness = 1;\n  }\n\n  var x = points[0],\n      y = 0,\n      segment = [x, y],\n      i = 2;\n\n  for (; i < points.length; i += 2) {\n    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);\n  }\n\n  return segment;\n} //points is an array of x/y points, like [x, y, x, y, x, y]\n\nfunction pointsToSegment(points, curviness) {\n  //points = simplifyPoints(points, tolerance);\n  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.\n\n  var l = points.length - 2,\n      x = +points[0],\n      y = +points[1],\n      nextX = +points[2],\n      nextY = +points[3],\n      segment = [x, y, x, y],\n      dx2 = nextX - x,\n      dy2 = nextY - y,\n      closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001,\n      prevX,\n      prevY,\n      i,\n      dx1,\n      dy1,\n      r1,\n      r2,\n      r3,\n      tl,\n      mx1,\n      mx2,\n      mxm,\n      my1,\n      my2,\n      mym;\n\n  if (closed) {\n    // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)\n    points.push(nextX, nextY);\n    nextX = x;\n    nextY = y;\n    x = points[l - 2];\n    y = points[l - 1];\n    points.unshift(x, y);\n    l += 4;\n  }\n\n  curviness = curviness || curviness === 0 ? +curviness : 1;\n\n  for (i = 2; i < l; i += 2) {\n    prevX = x;\n    prevY = y;\n    x = nextX;\n    y = nextY;\n    nextX = +points[i + 2];\n    nextY = +points[i + 3];\n\n    if (x === nextX && y === nextY) {\n      continue;\n    }\n\n    dx1 = dx2;\n    dy1 = dy2;\n    dx2 = nextX - x;\n    dy2 = nextY - y;\n    r1 = _sqrt(dx1 * dx1 + dy1 * dy1); // r1, r2, and r3 correlate x and y (and z in the future). Basically 2D or 3D hypotenuse\n\n    r2 = _sqrt(dx2 * dx2 + dy2 * dy2);\n    r3 = _sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));\n    tl = (r1 + r2) * curviness * 0.25 / r3;\n    mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);\n    mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);\n    mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n    my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);\n    my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);\n    mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n\n    if (x !== prevX || y !== prevY) {\n      segment.push(_round(mx1 + mxm), // first control point\n      _round(my1 + mym), _round(x), // anchor\n      _round(y), _round(mx2 + mxm), // second control point\n      _round(my2 + mym));\n    }\n  }\n\n  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;\n\n  if (segment.length === 2) {\n    // only one point!\n    segment.push(x, y, x, y, x, y);\n  } else if (closed) {\n    segment.splice(0, 6);\n    segment.length = segment.length - 6;\n  }\n\n  return segment;\n} //returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2\n\nfunction pointToSegDist(x, y, x1, y1, x2, y2) {\n  var dx = x2 - x1,\n      dy = y2 - y1,\n      t;\n\n  if (dx || dy) {\n    t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n\n  return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);\n}\n\nfunction simplifyStep(points, first, last, tolerance, simplified) {\n  var maxSqDist = tolerance,\n      firstX = points[first],\n      firstY = points[first + 1],\n      lastX = points[last],\n      lastY = points[last + 1],\n      index,\n      i,\n      d;\n\n  for (i = first + 2; i < last; i += 2) {\n    d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);\n\n    if (d > maxSqDist) {\n      index = i;\n      maxSqDist = d;\n    }\n  }\n\n  if (maxSqDist > tolerance) {\n    index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);\n    simplified.push(points[index], points[index + 1]);\n    last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);\n  }\n} //points is an array of x/y values like [x, y, x, y, x, y]\n\n\nfunction simplifyPoints(points, tolerance) {\n  var prevX = parseFloat(points[0]),\n      prevY = parseFloat(points[1]),\n      temp = [prevX, prevY],\n      l = points.length - 2,\n      i,\n      x,\n      y,\n      dx,\n      dy,\n      result,\n      last;\n  tolerance = Math.pow(tolerance || 1, 2);\n\n  for (i = 2; i < l; i += 2) {\n    x = parseFloat(points[i]);\n    y = parseFloat(points[i + 1]);\n    dx = prevX - x;\n    dy = prevY - y;\n\n    if (dx * dx + dy * dy > tolerance) {\n      temp.push(x, y);\n      prevX = x;\n      prevY = y;\n    }\n  }\n\n  temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));\n  last = temp.length - 2;\n  result = [temp[0], temp[1]];\n  simplifyStep(temp, 0, last, tolerance, result);\n  result.push(temp[last], temp[last + 1]);\n  return result;\n}\n\nfunction getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {\n  var inc = (end - start) / slices,\n      best = 0,\n      t = start,\n      x,\n      y,\n      d,\n      dx,\n      dy,\n      inv;\n  _bestDistance = _largeNum;\n\n  while (t <= end) {\n    inv = 1 - t;\n    x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;\n    y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;\n    dx = x - px;\n    dy = y - py;\n    d = dx * dx + dy * dy;\n\n    if (d < _bestDistance) {\n      _bestDistance = d;\n      best = t;\n    }\n\n    t += inc;\n  }\n\n  return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;\n}\n\nfunction getClosestData(rawPath, x, y, slices) {\n  //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)\n  var closest = {\n    j: 0,\n    i: 0,\n    t: 0\n  },\n      bestDistance = _largeNum,\n      i,\n      j,\n      t,\n      segment;\n\n  for (j = 0; j < rawPath.length; j++) {\n    segment = rawPath[j];\n\n    for (i = 0; i < segment.length; i += 6) {\n      t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n\n      if (bestDistance > _bestDistance) {\n        bestDistance = _bestDistance;\n        closest.j = j;\n        closest.i = i;\n        closest.t = t;\n      }\n    }\n  }\n\n  return closest;\n} //subdivide a Segment closest to a specific x,y coordinate\n\nfunction subdivideSegmentNear(x, y, segment, slices, iterations) {\n  var l = segment.length,\n      bestDistance = _largeNum,\n      bestT = 0,\n      bestSegmentIndex = 0,\n      t,\n      i;\n  slices = slices || 20;\n  iterations = iterations || 3;\n\n  for (i = 0; i < l; i += 6) {\n    t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n\n    if (bestDistance > _bestDistance) {\n      bestDistance = _bestDistance;\n      bestT = t;\n      bestSegmentIndex = i;\n    }\n  }\n\n  t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);\n  subdivideSegment(segment, bestSegmentIndex, t);\n  return bestSegmentIndex + 6;\n}\n/*\nTakes any of the following and converts it to an all Cubic Bezier SVG data string:\n- A <path> data string like \"M0,0 L2,4 v20,15 H100\"\n- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]\n- A Segment, like [x, y, x, y, x, y, x, y]\n\nNote: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13\n*/\n\nfunction rawPathToString(rawPath) {\n  if (_isNumber(rawPath[0])) {\n    //in case a segment is passed in instead\n    rawPath = [rawPath];\n  }\n\n  var result = \"\",\n      l = rawPath.length,\n      sl,\n      s,\n      i,\n      segment;\n\n  for (s = 0; s < l; s++) {\n    segment = rawPath[s];\n    result += \"M\" + _round(segment[0]) + \",\" + _round(segment[1]) + \" C\";\n    sl = segment.length;\n\n    for (i = 2; i < sl; i++) {\n      result += _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i]) + \" \";\n    }\n\n    if (segment.closed) {\n      result += \"z\";\n    }\n  }\n\n  return result;\n}\n/*\n// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.\nexport function cpCoordsToAngles(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tx, y, i;\n\tfor (i = 0; i < segment.length; i+=6) {\n\t\tx = segment[i+2] - segment[i];\n\t\ty = segment[i+3] - segment[i+1];\n\t\tresult[i+2] = Math.atan2(y, x);\n\t\tresult[i+3] = Math.sqrt(x * x + y * y);\n\t\tx = segment[i+6] - segment[i+4];\n\t\ty = segment[i+7] - segment[i+5];\n\t\tresult[i+4] = Math.atan2(y, x);\n\t\tresult[i+5] = Math.sqrt(x * x + y * y);\n\t}\n\treturn result;\n}\n\n// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.\nexport function cpAnglesToCoords(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tlength = segment.length,\n\t\trnd = 1000,\n\t\tangle, l, i, j;\n\tfor (i = 0; i < length; i+=6) {\n\t\tangle = segment[i+2];\n\t\tl = segment[i+3]; //length\n\t\tresult[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t\tangle = segment[i+4];\n\t\tl = segment[i+5]; //length\n\t\tresult[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t}\n\treturn result;\n}\n\n//adds an \"isSmooth\" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\nexport function populateSmoothData(rawPath) {\n\tlet j = rawPath.length,\n\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\twhile (--j > -1) {\n\t\tsegment = rawPath[j];\n\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\tisSmooth.length = 4;\n\t\tl = segment.length - 2;\n\t\tfor (i = 6; i < l; i += 6) {\n\t\t\tx = segment[i] - segment[i - 2];\n\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tsmooth = (Math.abs(a - a2) < 0.09);\n\t\t\tif (smooth) {\n\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t}\n\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t}\n\t\t//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\tx = segment[0] - segment[l-2];\n\t\t\ty = segment[1] - segment[l-1];\n\t\t\tx2 = segment[2] - segment[0];\n\t\t\ty2 = segment[3] - segment[1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tif (Math.abs(a - a2) < 0.09) {\n\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\tsmoothData[2] = a2;\n\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t}\n\t\t}\n\t}\n\treturn rawPath;\n}\nexport function pointToScreen(svgElement, point) {\n\tif (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point\n\t\tlet rawPath = getRawPath(svgElement);\n\t\tpoint = svgElement.ownerSVGElement.createSVGPoint();\n\t\tpoint.x = rawPath[0][0];\n\t\tpoint.y = rawPath[0][1];\n\t}\n\treturn point.matrixTransform(svgElement.getScreenCTM());\n}\n\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9wYXRocy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrU0FBa1MsTUFBTTtBQUN4UztBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVLO0FBQ1A7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0k7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkVBQTJFO0FBQzNFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUs7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUEsb0NBQW9DLG9CQUFvQjtBQUN4RCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVLO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNCQUFzQjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHSztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsTUFBTTtBQUNOO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxtSEFBbUgsS0FBSyxHQUFHLEtBQUs7O0FBRTNIO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVLO0FBQ1A7QUFDQSwwR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxvQkFBb0I7QUFDbEM7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvcGF0aHMuanM/NzQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHBhdGhzIDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfc3ZnUGF0aEV4cCA9IC9bYWNobG1xc3R2el18KC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG4gICAgX251bWJlcnNFeHAgPSAvKD86KC0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2lnLFxuICAgIF9zY2llbnRpZmljID0gL1tcXCtcXC1dP1xcZCpcXC4/XFxkK2VbXFwrXFwtXT9cXGQrL2lnLFxuICAgIF9zZWxlY3RvckV4cCA9IC8oXlsjXFwuXVthLXpdfFthLXldW2Etel0pL2ksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2NvcyA9IE1hdGguY29zLFxuICAgIF9hYnMgPSBNYXRoLmFicyxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIF9sYXJnZU51bSA9IDFlOCxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdGVtcCA9IHt9LFxuICAgIF90ZW1wMiA9IHt9LFxuICAgIF9yb3VuZGluZ051bSA9IDFlNSxcbiAgICBfd3JhcFByb2dyZXNzID0gZnVuY3Rpb24gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcykge1xuICByZXR1cm4gTWF0aC5yb3VuZCgocHJvZ3Jlc3MgKyBfbGFyZ2VOdW0pICUgMSAqIF9yb3VuZGluZ051bSkgLyBfcm91bmRpbmdOdW0gfHwgKHByb2dyZXNzIDwgMCA/IDAgOiAxKTtcbn0sXG4gICAgLy9pZiBwcm9ncmVzcyBsYW5kcyBvbiAxLCB0aGUgJSB3aWxsIG1ha2UgaXQgMCB3aGljaCBpcyB3aHkgd2UgfHwgMSwgYnV0IG5vdCBpZiBpdCdzIG5lZ2F0aXZlIGJlY2F1c2UgaXQgbWFrZXMgbW9yZSBzZW5zZSBmb3IgbW90aW9uIHRvIGVuZCBhdCAwIGluIHRoYXQgY2FzZS5cbl9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIF9yb3VuZGluZ051bSkgLyBfcm91bmRpbmdOdW0gfHwgMDtcbn0sXG4gICAgX3JvdW5kUHJlY2lzZSA9IGZ1bmN0aW9uIF9yb3VuZFByZWNpc2UodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxZTEwKSAvIDFlMTAgfHwgMDtcbn0sXG4gICAgX3NwbGl0U2VnbWVudCA9IGZ1bmN0aW9uIF9zcGxpdFNlZ21lbnQocmF3UGF0aCwgc2VnSW5kZXgsIGksIHQpIHtcbiAgdmFyIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XSxcbiAgICAgIHNoaWZ0ID0gdCA9PT0gMSA/IDYgOiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpO1xuXG4gIGlmIChzaGlmdCAmJiBzaGlmdCArIGkgKyAyIDwgc2VnbWVudC5sZW5ndGgpIHtcbiAgICByYXdQYXRoLnNwbGljZShzZWdJbmRleCwgMCwgc2VnbWVudC5zbGljZSgwLCBpICsgc2hpZnQgKyAyKSk7XG4gICAgc2VnbWVudC5zcGxpY2UoMCwgaSArIHNoaWZ0KTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfZ2V0U2FtcGxlSW5kZXggPSBmdW5jdGlvbiBfZ2V0U2FtcGxlSW5kZXgoc2FtcGxlcywgbGVuZ3RoLCBwcm9ncmVzcykge1xuICAvLyBzbGlnaHRseSBzbG93ZXIgd2F5IHRoYW4gZG9pbmcgdGhpcyAod2hlbiB0aGVyZSdzIG5vIGxvb2t1cCk6IHNlZ21lbnQubG9va3VwW3Byb2dyZXNzIDwgMSA/IH5+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKSA6IHNlZ21lbnQubG9va3VwLmxlbmd0aCAtIDFdIHx8IDA7XG4gIHZhciBsID0gc2FtcGxlcy5sZW5ndGgsXG4gICAgICBpID0gfn4ocHJvZ3Jlc3MgKiBsKTtcblxuICBpZiAoc2FtcGxlc1tpXSA+IGxlbmd0aCkge1xuICAgIHdoaWxlICgtLWkgJiYgc2FtcGxlc1tpXSA+IGxlbmd0aCkge31cblxuICAgIGkgPCAwICYmIChpID0gMCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHNhbXBsZXNbKytpXSA8IGxlbmd0aCAmJiBpIDwgbCkge31cbiAgfVxuXG4gIHJldHVybiBpIDwgbCA/IGkgOiBsIC0gMTtcbn0sXG4gICAgX3JldmVyc2VSYXdQYXRoID0gZnVuY3Rpb24gX3JldmVyc2VSYXdQYXRoKHJhd1BhdGgsIHNraXBPdXRlcikge1xuICB2YXIgaSA9IHJhd1BhdGgubGVuZ3RoO1xuICBza2lwT3V0ZXIgfHwgcmF3UGF0aC5yZXZlcnNlKCk7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJhd1BhdGhbaV0ucmV2ZXJzZWQgfHwgcmV2ZXJzZVNlZ21lbnQocmF3UGF0aFtpXSk7XG4gIH1cbn0sXG4gICAgX2NvcHlNZXRhRGF0YSA9IGZ1bmN0aW9uIF9jb3B5TWV0YURhdGEoc291cmNlLCBjb3B5KSB7XG4gIGNvcHkudG90YWxMZW5ndGggPSBzb3VyY2UudG90YWxMZW5ndGg7XG5cbiAgaWYgKHNvdXJjZS5zYW1wbGVzKSB7XG4gICAgLy9zZWdtZW50XG4gICAgY29weS5zYW1wbGVzID0gc291cmNlLnNhbXBsZXMuc2xpY2UoMCk7XG4gICAgY29weS5sb29rdXAgPSBzb3VyY2UubG9va3VwLnNsaWNlKDApO1xuICAgIGNvcHkubWluTGVuZ3RoID0gc291cmNlLm1pbkxlbmd0aDtcbiAgICBjb3B5LnJlc29sdXRpb24gPSBzb3VyY2UucmVzb2x1dGlvbjtcbiAgfSBlbHNlIGlmIChzb3VyY2UudG90YWxQb2ludHMpIHtcbiAgICAvL3Jhd1BhdGhcbiAgICBjb3B5LnRvdGFsUG9pbnRzID0gc291cmNlLnRvdGFsUG9pbnRzO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIC8vcHVzaGVzIGEgbmV3IHNlZ21lbnQgaW50byBhIHJhd1BhdGgsIGJ1dCBpZiBpdHMgc3RhcnRpbmcgdmFsdWVzIG1hdGNoIHRoZSBlbmRpbmcgdmFsdWVzIG9mIHRoZSBsYXN0IHNlZ21lbnQsIGl0J2xsIG1lcmdlIGl0IGludG8gdGhhdCBzYW1lIHNlZ21lbnQgKHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzKVxuX2FwcGVuZE9yTWVyZ2UgPSBmdW5jdGlvbiBfYXBwZW5kT3JNZXJnZShyYXdQYXRoLCBzZWdtZW50KSB7XG4gIHZhciBpbmRleCA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgcHJldlNlZyA9IHJhd1BhdGhbaW5kZXggLSAxXSB8fCBbXSxcbiAgICAgIGwgPSBwcmV2U2VnLmxlbmd0aDtcblxuICBpZiAoaW5kZXggJiYgc2VnbWVudFswXSA9PT0gcHJldlNlZ1tsIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gcHJldlNlZ1tsIC0gMV0pIHtcbiAgICBzZWdtZW50ID0gcHJldlNlZy5jb25jYXQoc2VnbWVudC5zbGljZSgyKSk7XG4gICAgaW5kZXgtLTtcbiAgfVxuXG4gIHJhd1BhdGhbaW5kZXhdID0gc2VnbWVudDtcbn0sXG4gICAgX2Jlc3REaXN0YW5jZTtcbi8qIFRFUk1JTk9MT0dZXG4gLSBSYXdQYXRoIC0gYW4gYXJyYXkgb2YgYXJyYXlzLCBvbmUgZm9yIGVhY2ggU2VnbWVudC4gQSBzaW5nbGUgUmF3UGF0aCBjb3VsZCBoYXZlIG11bHRpcGxlIFwiTVwiIGNvbW1hbmRzLCBkZWZpbmluZyBTZWdtZW50cyAocGF0aHMgYXJlbid0IGFsd2F5cyBjb25uZWN0ZWQpLlxuIC0gU2VnbWVudCAtIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBzZXF1ZW5jZSBvZiBDdWJpYyBCZXppZXIgY29vcmRpbmF0ZXMgaW4gYWx0ZXJuYXRpbmcgeCwgeSwgeCwgeSBmb3JtYXQuIFN0YXJ0aW5nIGFuY2hvciwgdGhlbiBjb250cm9sIHBvaW50IDEsIGNvbnRyb2wgcG9pbnQgMiwgYW5kIGVuZGluZyBhbmNob3IsIHRoZW4gdGhlIG5leHQgY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuY2hvciwgZXRjLiBVc2VzIGxlc3MgbWVtb3J5IHRoYW4gYW4gYXJyYXkgd2l0aCBhIGJ1bmNoIG9mIHt4LCB5fSBwb2ludHMuXG4gLSBCZXppZXIgLSBhIHNpbmdsZSBjdWJpYyBCZXppZXIgd2l0aCBhIHN0YXJ0aW5nIGFuY2hvciwgdHdvIGNvbnRyb2wgcG9pbnRzLCBhbmQgYW4gZW5kaW5nIGFuY2hvci5cbiAtIHRoZSB2YXJpYWJsZSBcInRcIiBpcyB0eXBpY2FsbHkgdGhlIHBvc2l0aW9uIGFsb25nIGFuIGluZGl2aWR1YWwgQmV6aWVyIHBhdGggKHRpbWUpIGFuZCBpdCdzIE5PVCBsaW5lYXIsIG1lYW5pbmcgaXQgY291bGQgYWNjZWxlcmF0ZS9kZWNlbGVyYXRlIGJhc2VkIG9uIHRoZSBjb250cm9sIHBvaW50cyB3aGVyZWFzIHRoZSBcInBcIiBvciBcInByb2dyZXNzXCIgdmFsdWUgaXMgbGluZWFybHkgbWFwcGVkIHRvIHRoZSB3aG9sZSBwYXRoLCBzbyBpdCBzaG91bGRuJ3QgcmVhbGx5IGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiBjb250cm9sIHBvaW50cy4gU28gYSBwcm9ncmVzcyBvZiAwLjIgd291bGQgYmUgYWxtb3N0IGV4YWN0bHkgMjAlIGFsb25nIHRoZSBwYXRoLiBcInRcIiBpcyBPTkxZIGluIGFuIGluZGl2aWR1YWwgQmV6aWVyIHBpZWNlLlxuICovXG4vL2FjY2VwdHMgYmFzaWMgc2VsZWN0b3IgdGV4dCwgYSBwYXRoIGluc3RhbmNlLCBhIFJhd1BhdGggaW5zdGFuY2UsIG9yIGEgU2VnbWVudCBhbmQgcmV0dXJucyBhIFJhd1BhdGggKG1ha2VzIGl0IGVhc3kgdG8gaG9tb2dlbml6ZSB0aGluZ3MpLiBJZiBhbiBlbGVtZW50IG9yIHNlbGVjdG9yIHRleHQgaXMgcGFzc2VkIGluLCBpdCdsbCBhbHNvIGNhY2hlIHRoZSB2YWx1ZSBzbyB0aGF0IGlmIGl0J3MgcXVlcmllZCBhZ2FpbiwgaXQnbGwganVzdCB0YWtlIHRoZSBwYXRoIGRhdGEgZnJvbSB0aGVyZSBpbnN0ZWFkIG9mIHBhcnNpbmcgaXQgYWxsIG92ZXIgYWdhaW4gKGFzIGxvbmcgYXMgdGhlIHBhdGggZGF0YSBpdHNlbGYgaGFzbid0IGNoYW5nZWQgLSBpdCdsbCBjaGVjaykuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd1BhdGgodmFsdWUpIHtcbiAgdmFsdWUgPSBfaXNTdHJpbmcodmFsdWUpICYmIF9zZWxlY3RvckV4cC50ZXN0KHZhbHVlKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpIHx8IHZhbHVlIDogdmFsdWU7XG4gIHZhciBlID0gdmFsdWUuZ2V0QXR0cmlidXRlID8gdmFsdWUgOiAwLFxuICAgICAgcmF3UGF0aDtcblxuICBpZiAoZSAmJiAodmFsdWUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoXCJkXCIpKSkge1xuICAgIC8vaW1wbGVtZW50cyBjYWNoaW5nXG4gICAgaWYgKCFlLl9nc1BhdGgpIHtcbiAgICAgIGUuX2dzUGF0aCA9IHt9O1xuICAgIH1cblxuICAgIHJhd1BhdGggPSBlLl9nc1BhdGhbdmFsdWVdO1xuICAgIHJldHVybiByYXdQYXRoICYmICFyYXdQYXRoLl9kaXJ0eSA/IHJhd1BhdGggOiBlLl9nc1BhdGhbdmFsdWVdID0gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAhdmFsdWUgPyBjb25zb2xlLndhcm4oXCJFeHBlY3RpbmcgYSA8cGF0aD4gZWxlbWVudCBvciBhbiBTVkcgcGF0aCBkYXRhIHN0cmluZ1wiKSA6IF9pc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpIDogX2lzTnVtYmVyKHZhbHVlWzBdKSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbn0gLy9jb3BpZXMgYSBSYXdQYXRoIFdJVEhPVVQgdGhlIGxlbmd0aCBtZXRhIGRhdGEgKGZvciBzcGVlZClcblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSYXdQYXRoKHJhd1BhdGgpIHtcbiAgdmFyIGEgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGFbaV0gPSBfY29weU1ldGFEYXRhKHJhd1BhdGhbaV0sIHJhd1BhdGhbaV0uc2xpY2UoMCkpO1xuICB9XG5cbiAgcmV0dXJuIF9jb3B5TWV0YURhdGEocmF3UGF0aCwgYSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVNlZ21lbnQoc2VnbWVudCkge1xuICB2YXIgaSA9IDAsXG4gICAgICB5O1xuICBzZWdtZW50LnJldmVyc2UoKTsgLy90aGlzIHdpbGwgaW52ZXJ0IHRoZSBvcmRlciB5LCB4LCB5LCB4IHNvIHdlIG11c3QgZmxpcCBpdCBiYWNrLlxuXG4gIGZvciAoOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHkgPSBzZWdtZW50W2ldO1xuICAgIHNlZ21lbnRbaV0gPSBzZWdtZW50W2kgKyAxXTtcbiAgICBzZWdtZW50W2kgKyAxXSA9IHk7XG4gIH1cblxuICBzZWdtZW50LnJldmVyc2VkID0gIXNlZ21lbnQucmV2ZXJzZWQ7XG59XG5cbnZhciBfY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIF9jcmVhdGVQYXRoKGUsIGlnbm9yZSkge1xuICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKSxcbiAgICAgIGF0dHIgPSBbXS5zbGljZS5jYWxsKGUuYXR0cmlidXRlcyksXG4gICAgICBpID0gYXR0ci5sZW5ndGgsXG4gICAgICBuYW1lO1xuICBpZ25vcmUgPSBcIixcIiArIGlnbm9yZSArIFwiLFwiO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIG5hbWUgPSBhdHRyW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IC8vaW4gTWljcm9zb2Z0IEVkZ2UsIGlmIHlvdSBkb24ndCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIGEgbG93ZXJjYXNlIG5hbWUsIGl0IGRvZXNuJ3QgcmVuZGVyIGNvcnJlY3RseSEgU3VwZXIgd2VpcmQuXG5cbiAgICBpZiAoaWdub3JlLmluZGV4T2YoXCIsXCIgKyBuYW1lICsgXCIsXCIpIDwgMCkge1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCBhdHRyW2ldLm5vZGVWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59LFxuICAgIF90eXBlQXR0cnMgPSB7XG4gIHJlY3Q6IFwicngscnkseCx5LHdpZHRoLGhlaWdodFwiLFxuICBjaXJjbGU6IFwicixjeCxjeVwiLFxuICBlbGxpcHNlOiBcInJ4LHJ5LGN4LGN5XCIsXG4gIGxpbmU6IFwieDEseDIseTEseTJcIlxufSxcbiAgICBfYXR0clRvT2JqID0gZnVuY3Rpb24gX2F0dHJUb09iaihlLCBhdHRycykge1xuICB2YXIgcHJvcHMgPSBhdHRycyA/IGF0dHJzLnNwbGl0KFwiLFwiKSA6IFtdLFxuICAgICAgb2JqID0ge30sXG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIG9ialtwcm9wc1tpXV0gPSArZS5nZXRBdHRyaWJ1dGUocHJvcHNbaV0pIHx8IDA7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsgLy9jb252ZXJ0cyBhbiBTVkcgc2hhcGUgbGlrZSA8Y2lyY2xlPiwgPHJlY3Q+LCA8cG9seWdvbj4sIDxwb2x5bGluZT4sIDxlbGxpcHNlPiwgZXRjLiB0byBhIDxwYXRoPiwgc3dhcHBpbmcgaXQgaW4gYW5kIGNvcHlpbmcgdGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2guXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgoZWxlbWVudCwgc3dhcCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgY2lyYyA9IDAuNTUyMjg0NzQ5ODMxLFxuICAgICAgZGF0YSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcixcbiAgICAgIHJ5LFxuICAgICAgcGF0aCxcbiAgICAgIHJjaXJjLFxuICAgICAgcnljaXJjLFxuICAgICAgcG9pbnRzLFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgICB4MixcbiAgICAgIHgzLFxuICAgICAgeDQsXG4gICAgICB4NSxcbiAgICAgIHg2LFxuICAgICAgeTIsXG4gICAgICB5MyxcbiAgICAgIHk0LFxuICAgICAgeTUsXG4gICAgICB5NixcbiAgICAgIGF0dHI7XG5cbiAgaWYgKHR5cGUgPT09IFwicGF0aFwiIHx8ICFlbGVtZW50LmdldEJCb3gpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHBhdGggPSBfY3JlYXRlUGF0aChlbGVtZW50LCBcIngseSx3aWR0aCxoZWlnaHQsY3gsY3kscngscnkscix4MSx4Mix5MSx5Mixwb2ludHNcIik7XG4gIGF0dHIgPSBfYXR0clRvT2JqKGVsZW1lbnQsIF90eXBlQXR0cnNbdHlwZV0pO1xuXG4gIGlmICh0eXBlID09PSBcInJlY3RcIikge1xuICAgIHIgPSBhdHRyLnJ4O1xuICAgIHJ5ID0gYXR0ci5yeSB8fCByO1xuICAgIHggPSBhdHRyLng7XG4gICAgeSA9IGF0dHIueTtcbiAgICB3ID0gYXR0ci53aWR0aCAtIHIgKiAyO1xuICAgIGggPSBhdHRyLmhlaWdodCAtIHJ5ICogMjtcblxuICAgIGlmIChyIHx8IHJ5KSB7XG4gICAgICAvL2lmIHRoZXJlIGFyZSByb3VuZGVkIGNvcm5lcnMsIHJlbmRlciBjdWJpYyBiZXppZXJzXG4gICAgICB4MiA9IHggKyByICogKDEgLSBjaXJjKTtcbiAgICAgIHgzID0geCArIHI7XG4gICAgICB4NCA9IHgzICsgdztcbiAgICAgIHg1ID0geDQgKyByICogY2lyYztcbiAgICAgIHg2ID0geDQgKyByO1xuICAgICAgeTIgPSB5ICsgcnkgKiAoMSAtIGNpcmMpO1xuICAgICAgeTMgPSB5ICsgcnk7XG4gICAgICB5NCA9IHkzICsgaDtcbiAgICAgIHk1ID0geTQgKyByeSAqIGNpcmM7XG4gICAgICB5NiA9IHk0ICsgcnk7XG4gICAgICBkYXRhID0gXCJNXCIgKyB4NiArIFwiLFwiICsgeTMgKyBcIiBWXCIgKyB5NCArIFwiIENcIiArIFt4NiwgeTUsIHg1LCB5NiwgeDQsIHk2LCB4NCAtICh4NCAtIHgzKSAvIDMsIHk2LCB4MyArICh4NCAtIHgzKSAvIDMsIHk2LCB4MywgeTYsIHgyLCB5NiwgeCwgeTUsIHgsIHk0LCB4LCB5NCAtICh5NCAtIHkzKSAvIDMsIHgsIHkzICsgKHk0IC0geTMpIC8gMywgeCwgeTMsIHgsIHkyLCB4MiwgeSwgeDMsIHksIHgzICsgKHg0IC0geDMpIC8gMywgeSwgeDQgLSAoeDQgLSB4MykgLyAzLCB5LCB4NCwgeSwgeDUsIHksIHg2LCB5MiwgeDYsIHkzXS5qb2luKFwiLFwiKSArIFwielwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gXCJNXCIgKyAoeCArIHcpICsgXCIsXCIgKyB5ICsgXCIgdlwiICsgaCArIFwiIGhcIiArIC13ICsgXCIgdlwiICsgLWggKyBcIiBoXCIgKyB3ICsgXCJ6XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIgfHwgdHlwZSA9PT0gXCJlbGxpcHNlXCIpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgciA9IHJ5ID0gYXR0ci5yO1xuICAgICAgcnljaXJjID0gciAqIGNpcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBhdHRyLnJ4O1xuICAgICAgcnkgPSBhdHRyLnJ5O1xuICAgICAgcnljaXJjID0gcnkgKiBjaXJjO1xuICAgIH1cblxuICAgIHggPSBhdHRyLmN4O1xuICAgIHkgPSBhdHRyLmN5O1xuICAgIHJjaXJjID0gciAqIGNpcmM7XG4gICAgZGF0YSA9IFwiTVwiICsgKHggKyByKSArIFwiLFwiICsgeSArIFwiIENcIiArIFt4ICsgciwgeSArIHJ5Y2lyYywgeCArIHJjaXJjLCB5ICsgcnksIHgsIHkgKyByeSwgeCAtIHJjaXJjLCB5ICsgcnksIHggLSByLCB5ICsgcnljaXJjLCB4IC0gciwgeSwgeCAtIHIsIHkgLSByeWNpcmMsIHggLSByY2lyYywgeSAtIHJ5LCB4LCB5IC0gcnksIHggKyByY2lyYywgeSAtIHJ5LCB4ICsgciwgeSAtIHJ5Y2lyYywgeCArIHIsIHldLmpvaW4oXCIsXCIpICsgXCJ6XCI7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lXCIpIHtcbiAgICBkYXRhID0gXCJNXCIgKyBhdHRyLngxICsgXCIsXCIgKyBhdHRyLnkxICsgXCIgTFwiICsgYXR0ci54MiArIFwiLFwiICsgYXR0ci55MjsgLy9wcmV2aW91c2x5LCB3ZSBqdXN0IGNvbnZlcnRlZCB0byBcIk14LHkgTHgseVwiIGJ1dCBTYWZhcmkgaGFzIGJ1Z3MgdGhhdCBjYXVzZSB0aGF0IG5vdCB0byByZW5kZXIgcHJvcGVybHkgd2hlbiB1c2luZyBhIHN0cm9rZS1kYXNoYXJyYXkgdGhhdCdzIG5vdCBmdWxseSB2aXNpYmxlISBVc2luZyBhIGN1YmljIGJlemllciBmaXhlcyB0aGF0IGlzc3VlLlxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicG9seWxpbmVcIiB8fCB0eXBlID09PSBcInBvbHlnb25cIikge1xuICAgIHBvaW50cyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShcInBvaW50c1wiKSArIFwiXCIpLm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcbiAgICB4ID0gcG9pbnRzLnNoaWZ0KCk7XG4gICAgeSA9IHBvaW50cy5zaGlmdCgpO1xuICAgIGRhdGEgPSBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyBwb2ludHMuam9pbihcIixcIik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICAgIGRhdGEgKz0gXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCJ6XCI7XG4gICAgfVxuICB9XG5cbiAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHJhd1BhdGhUb1N0cmluZyhwYXRoLl9nc1Jhd1BhdGggPSBzdHJpbmdUb1Jhd1BhdGgoZGF0YSkpKTtcblxuICBpZiAoc3dhcCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBhdGgsIGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufSAvL3JldHVybnMgdGhlIHJvdGF0aW9uIChpbiBkZWdyZWVzKSBhdCBhIHBhcnRpY3VsYXIgcHJvZ3Jlc3Mgb24gYSByYXdQYXRoICh0aGUgc2xvcGUgb2YgdGhlIHRhbmdlbnQpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbkF0UHJvZ3Jlc3MocmF3UGF0aCwgcHJvZ3Jlc3MpIHtcbiAgdmFyIGQgPSBnZXRQcm9ncmVzc0RhdGEocmF3UGF0aCwgcHJvZ3Jlc3MgPj0gMSA/IDEgLSAxZS05IDogcHJvZ3Jlc3MgPyBwcm9ncmVzcyA6IDFlLTkpO1xuICByZXR1cm4gZ2V0Um90YXRpb25BdEJlemllclQoZC5zZWdtZW50LCBkLmksIGQudCk7XG59XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQpIHtcbiAgdmFyIGEgPSBzZWdtZW50W2ldLFxuICAgICAgYiA9IHNlZ21lbnRbaSArIDJdLFxuICAgICAgYyA9IHNlZ21lbnRbaSArIDRdLFxuICAgICAgeDtcbiAgYSArPSAoYiAtIGEpICogdDtcbiAgYiArPSAoYyAtIGIpICogdDtcbiAgYSArPSAoYiAtIGEpICogdDtcbiAgeCA9IGIgKyAoYyArIChzZWdtZW50W2kgKyA2XSAtIGMpICogdCAtIGIpICogdCAtIGE7XG4gIGEgPSBzZWdtZW50W2kgKyAxXTtcbiAgYiA9IHNlZ21lbnRbaSArIDNdO1xuICBjID0gc2VnbWVudFtpICsgNV07XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIGIgKz0gKGMgLSBiKSAqIHQ7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIHJldHVybiBfcm91bmQoX2F0YW4yKGIgKyAoYyArIChzZWdtZW50W2kgKyA3XSAtIGMpICogdCAtIGIpICogdCAtIGEsIHgpICogX1JBRDJERUcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gX2lzVW5kZWZpbmVkKGVuZCkgPyAxIDogX3JvdW5kUHJlY2lzZShlbmQpIHx8IDA7IC8vIHdlIG11c3Qgcm91bmQgdG8gYXZvaWQgaXNzdWVzIGxpa2UgNC4xNSAvIDggPSAwLjgzMDAwMDAwMDAwMDAwMDEgaW5zdGVhZCBvZiAwLjgzIG9yIDIuOCAvIDUgPSAwLjU1OTk5OTk5OTk5OTk5OTkgaW5zdGVhZCBvZiAwLjU2IGFuZCBpZiBzb21lb25lIGlzIGRvaW5nIGEgbG9vcCBsaWtlIHN0YXJ0OiAyLjggLyAwLjUsIGVuZDogMi44IC8gMC41ICsgMS5cblxuICBzdGFydCA9IF9yb3VuZFByZWNpc2Uoc3RhcnQpIHx8IDA7XG4gIHZhciBsb29wcyA9IE1hdGgubWF4KDAsIH5+KF9hYnMoZW5kIC0gc3RhcnQpIC0gMWUtOCkpLFxuICAgICAgcGF0aCA9IGNvcHlSYXdQYXRoKHJhd1BhdGgpO1xuXG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHN0YXJ0ID0gMSAtIHN0YXJ0O1xuICAgIGVuZCA9IDEgLSBlbmQ7XG5cbiAgICBfcmV2ZXJzZVJhd1BhdGgocGF0aCk7XG5cbiAgICBwYXRoLnRvdGFsTGVuZ3RoID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kIDwgMCkge1xuICAgIHZhciBvZmZzZXQgPSBNYXRoLmFicyh+fk1hdGgubWluKHN0YXJ0LCBlbmQpKSArIDE7XG4gICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgIGVuZCArPSBvZmZzZXQ7XG4gIH1cblxuICBwYXRoLnRvdGFsTGVuZ3RoIHx8IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhwYXRoKTtcbiAgdmFyIHdyYXAgPSBlbmQgPiAxLFxuICAgICAgcyA9IGdldFByb2dyZXNzRGF0YShwYXRoLCBzdGFydCwgX3RlbXAsIHRydWUpLFxuICAgICAgZSA9IGdldFByb2dyZXNzRGF0YShwYXRoLCBlbmQsIF90ZW1wMiksXG4gICAgICBlU2VnID0gZS5zZWdtZW50LFxuICAgICAgc1NlZyA9IHMuc2VnbWVudCxcbiAgICAgIGVTZWdJbmRleCA9IGUuc2VnSW5kZXgsXG4gICAgICBzU2VnSW5kZXggPSBzLnNlZ0luZGV4LFxuICAgICAgZWkgPSBlLmksXG4gICAgICBzaSA9IHMuaSxcbiAgICAgIHNhbWVTZWdtZW50ID0gc1NlZ0luZGV4ID09PSBlU2VnSW5kZXgsXG4gICAgICBzYW1lQmV6aWVyID0gZWkgPT09IHNpICYmIHNhbWVTZWdtZW50LFxuICAgICAgd3JhcHNCZWhpbmQsXG4gICAgICBzU2hpZnQsXG4gICAgICBlU2hpZnQsXG4gICAgICBpLFxuICAgICAgY29weSxcbiAgICAgIHRvdGFsU2VnbWVudHMsXG4gICAgICBsLFxuICAgICAgajtcblxuICBpZiAod3JhcCB8fCBsb29wcykge1xuICAgIHdyYXBzQmVoaW5kID0gZVNlZ0luZGV4IDwgc1NlZ0luZGV4IHx8IHNhbWVTZWdtZW50ICYmIGVpIDwgc2kgfHwgc2FtZUJlemllciAmJiBlLnQgPCBzLnQ7XG5cbiAgICBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBzU2VnSW5kZXgsIHNpLCBzLnQpKSB7XG4gICAgICBzU2VnSW5kZXgrKztcblxuICAgICAgaWYgKCF3cmFwc0JlaGluZCkge1xuICAgICAgICBlU2VnSW5kZXgrKztcblxuICAgICAgICBpZiAoc2FtZUJlemllcikge1xuICAgICAgICAgIGUudCA9IChlLnQgLSBzLnQpIC8gKDEgLSBzLnQpO1xuICAgICAgICAgIGVpID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lU2VnbWVudCkge1xuICAgICAgICAgIGVpIC09IHNpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKDEgLSAoZW5kIC0gc3RhcnQpKSA8IDFlLTUpIHtcbiAgICAgIGVTZWdJbmRleCA9IHNTZWdJbmRleCAtIDE7XG4gICAgfSBlbHNlIGlmICghZS50ICYmIGVTZWdJbmRleCkge1xuICAgICAgZVNlZ0luZGV4LS07XG4gICAgfSBlbHNlIGlmIChfc3BsaXRTZWdtZW50KHBhdGgsIGVTZWdJbmRleCwgZWksIGUudCkgJiYgd3JhcHNCZWhpbmQpIHtcbiAgICAgIHNTZWdJbmRleCsrO1xuICAgIH1cblxuICAgIGlmIChzLnQgPT09IDEpIHtcbiAgICAgIHNTZWdJbmRleCA9IChzU2VnSW5kZXggKyAxKSAlIHBhdGgubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvcHkgPSBbXTtcbiAgICB0b3RhbFNlZ21lbnRzID0gcGF0aC5sZW5ndGg7XG4gICAgbCA9IDEgKyB0b3RhbFNlZ21lbnRzICogbG9vcHM7XG4gICAgaiA9IHNTZWdJbmRleDtcbiAgICBsICs9ICh0b3RhbFNlZ21lbnRzIC0gc1NlZ0luZGV4ICsgZVNlZ0luZGV4KSAlIHRvdGFsU2VnbWVudHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBfYXBwZW5kT3JNZXJnZShjb3B5LCBwYXRoW2orKyAlIHRvdGFsU2VnbWVudHNdKTtcbiAgICB9XG5cbiAgICBwYXRoID0gY29weTtcbiAgfSBlbHNlIHtcbiAgICBlU2hpZnQgPSBlLnQgPT09IDEgPyA2IDogc3ViZGl2aWRlU2VnbWVudChlU2VnLCBlaSwgZS50KTtcblxuICAgIGlmIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICBzU2hpZnQgPSBzdWJkaXZpZGVTZWdtZW50KHNTZWcsIHNpLCBzYW1lQmV6aWVyID8gcy50IC8gZS50IDogcy50KTtcbiAgICAgIHNhbWVTZWdtZW50ICYmIChlU2hpZnQgKz0gc1NoaWZ0KTtcbiAgICAgIGVTZWcuc3BsaWNlKGVpICsgZVNoaWZ0ICsgMik7XG4gICAgICAoc1NoaWZ0IHx8IHNpKSAmJiBzU2VnLnNwbGljZSgwLCBzaSArIHNTaGlmdCk7XG4gICAgICBpID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy9jaG9wIG9mZiBhbnkgZXh0cmEgc2VnbWVudHNcbiAgICAgICAgKGkgPCBzU2VnSW5kZXggfHwgaSA+IGVTZWdJbmRleCkgJiYgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVTZWcuYW5nbGUgPSBnZXRSb3RhdGlvbkF0QmV6aWVyVChlU2VnLCBlaSArIGVTaGlmdCwgMCk7IC8vcmVjb3JkIHRoZSB2YWx1ZSBiZWZvcmUgd2UgY2hvcCBiZWNhdXNlIGl0J2xsIGJlIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lIHRoZSBhbmdsZSBhZnRlciBpdHMgbGVuZ3RoIGlzIDAhXG5cbiAgICAgIGVpICs9IGVTaGlmdDtcbiAgICAgIHMgPSBlU2VnW2VpXTtcbiAgICAgIGUgPSBlU2VnW2VpICsgMV07XG4gICAgICBlU2VnLmxlbmd0aCA9IGVTZWcudG90YWxMZW5ndGggPSAwO1xuICAgICAgZVNlZy50b3RhbFBvaW50cyA9IHBhdGgudG90YWxQb2ludHMgPSA4O1xuICAgICAgZVNlZy5wdXNoKHMsIGUsIHMsIGUsIHMsIGUsIHMsIGUpO1xuICAgIH1cbiAgfVxuXG4gIHBhdGgudG90YWxMZW5ndGggPSAwO1xuICByZXR1cm4gcGF0aDtcbn0gLy9tZWFzdXJlcyBhIFNlZ21lbnQgYWNjb3JkaW5nIHRvIGl0cyByZXNvbHV0aW9uIChzbyBpZiBzZWdtZW50LnJlc29sdXRpb24gaXMgNiwgZm9yIGV4YW1wbGUsIGl0J2xsIHRha2UgNiBzYW1wbGVzIGVxdWFsbHkgYWNyb3NzIGVhY2ggQmV6aWVyKSBhbmQgY3JlYXRlL3BvcHVsYXRlIGEgXCJzYW1wbGVzXCIgQXJyYXkgdGhhdCBoYXMgdGhlIGxlbmd0aCB1cCB0byBlYWNoIG9mIHRob3NlIHNhbXBsZSBwb2ludHMgKGFsd2F5cyBpbmNyZWFzaW5nIGZyb20gdGhlIHN0YXJ0KSBhcyB3ZWxsIGFzIGEgXCJsb29rdXBcIiBhcnJheSB0aGF0J3MgYnJva2VuIHVwIGFjY29yZGluZyB0byB0aGUgc21hbGxlc3QgZGlzdGFuY2UgYmV0d2VlbiAyIHNhbXBsZXMuIFRoaXMgZ2l2ZXMgdXMgYSB2ZXJ5IGZhc3Qgd2F5IG9mIGxvb2tpbmcgdXAgYSBwcm9ncmVzcyBwb3NpdGlvbiByYXRoZXIgdGhhbiBsb29waW5nIHRocm91Z2ggYWxsIHRoZSBwb2ludHMvQmV6aWVycy4gWW91IGNhbiBvcHRpb25hbGx5IGhhdmUgaXQgb25seSBtZWFzdXJlIGEgc3Vic2V0LCBzdGFydGluZyBhdCBzdGFydEluZGV4IGFuZCBnb2luZyBmb3IgYSBzcGVjaWZpYyBudW1iZXIgb2YgYmV6aWVycyAocmVtZW1iZXIsIHRoZXJlIGFyZSAzIHgveSBwYWlycyBlYWNoLCBmb3IgYSB0b3RhbCBvZiA2IGVsZW1lbnRzIGZvciBlYWNoIEJlemllcikuIEl0IHdpbGwgYWxzbyBwb3B1bGF0ZSBhIFwidG90YWxMZW5ndGhcIiBwcm9wZXJ0eSwgYnV0IHRoYXQncyBub3QgZ2VuZXJhbGx5IHN1cGVyIGFjY3VyYXRlIGJlY2F1c2UgYnkgZGVmYXVsdCBpdCdsbCBvbmx5IHRha2UgNiBzYW1wbGVzIHBlciBCZXppZXIuIEJ1dCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQncyBwZXJmZWN0bHkgYWRlcXVhdGUgZm9yIG1lYXN1cmluZyBwcm9ncmVzcyB2YWx1ZXMgYWxvbmcgdGhlIHBhdGguIElmIHlvdSBuZWVkIGEgbW9yZSBhY2N1cmF0ZSB0b3RhbExlbmd0aCwgZWl0aGVyIGluY3JlYXNlIHRoZSByZXNvbHV0aW9uIG9yIHVzZSB0aGUgbW9yZSBhZHZhbmNlZCBiZXppZXJUb1BvaW50cygpIG1ldGhvZCB3aGljaCBrZWVwcyBhZGRpbmcgcG9pbnRzIHVudGlsIHRoZXkgZG9uJ3QgZGV2aWF0ZSBieSBtb3JlIHRoYW4gYSBjZXJ0YWluIHByZWNpc2lvbiB2YWx1ZS5cblxuZnVuY3Rpb24gbWVhc3VyZVNlZ21lbnQoc2VnbWVudCwgc3RhcnRJbmRleCwgYmV6aWVyUXR5KSB7XG4gIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG5cbiAgaWYgKCFzZWdtZW50LnNhbXBsZXMpIHtcbiAgICBzZWdtZW50LnNhbXBsZXMgPSBbXTtcbiAgICBzZWdtZW50Lmxvb2t1cCA9IFtdO1xuICB9XG5cbiAgdmFyIHJlc29sdXRpb24gPSB+fnNlZ21lbnQucmVzb2x1dGlvbiB8fCAxMixcbiAgICAgIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuICAgICAgZW5kSW5kZXggPSBiZXppZXJRdHkgPyBzdGFydEluZGV4ICsgYmV6aWVyUXR5ICogNiArIDEgOiBzZWdtZW50Lmxlbmd0aCxcbiAgICAgIHgxID0gc2VnbWVudFtzdGFydEluZGV4XSxcbiAgICAgIHkxID0gc2VnbWVudFtzdGFydEluZGV4ICsgMV0sXG4gICAgICBzYW1wbGVzSW5kZXggPSBzdGFydEluZGV4ID8gc3RhcnRJbmRleCAvIDYgKiByZXNvbHV0aW9uIDogMCxcbiAgICAgIHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXMsXG4gICAgICBsb29rdXAgPSBzZWdtZW50Lmxvb2t1cCxcbiAgICAgIG1pbiA9IChzdGFydEluZGV4ID8gc2VnbWVudC5taW5MZW5ndGggOiBfbGFyZ2VOdW0pIHx8IF9sYXJnZU51bSxcbiAgICAgIHByZXZMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXNJbmRleCArIGJlemllclF0eSAqIHJlc29sdXRpb24gLSAxXSxcbiAgICAgIGxlbmd0aCA9IHN0YXJ0SW5kZXggPyBzYW1wbGVzW3NhbXBsZXNJbmRleCAtIDFdIDogMCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgeDQsXG4gICAgICB4MyxcbiAgICAgIHgyLFxuICAgICAgeGQsXG4gICAgICB4ZDEsXG4gICAgICB5NCxcbiAgICAgIHkzLFxuICAgICAgeTIsXG4gICAgICB5ZCxcbiAgICAgIHlkMSxcbiAgICAgIGludixcbiAgICAgIHQsXG4gICAgICBsZW5ndGhJbmRleCxcbiAgICAgIGwsXG4gICAgICBzZWdMZW5ndGg7XG4gIHNhbXBsZXMubGVuZ3RoID0gbG9va3VwLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChqID0gc3RhcnRJbmRleCArIDI7IGogPCBlbmRJbmRleDsgaiArPSA2KSB7XG4gICAgeDQgPSBzZWdtZW50W2ogKyA0XSAtIHgxO1xuICAgIHgzID0gc2VnbWVudFtqICsgMl0gLSB4MTtcbiAgICB4MiA9IHNlZ21lbnRbal0gLSB4MTtcbiAgICB5NCA9IHNlZ21lbnRbaiArIDVdIC0geTE7XG4gICAgeTMgPSBzZWdtZW50W2ogKyAzXSAtIHkxO1xuICAgIHkyID0gc2VnbWVudFtqICsgMV0gLSB5MTtcbiAgICB4ZCA9IHhkMSA9IHlkID0geWQxID0gMDtcblxuICAgIGlmIChfYWJzKHg0KSA8IC4wMSAmJiBfYWJzKHk0KSA8IC4wMSAmJiBfYWJzKHgyKSArIF9hYnMoeTIpIDwgLjAxKSB7XG4gICAgICAvL2R1bXAgcG9pbnRzIHRoYXQgYXJlIHN1ZmZpY2llbnRseSBjbG9zZSAoYmFzaWNhbGx5IHJpZ2h0IG9uIHRvcCBvZiBlYWNoIG90aGVyLCBtYWtpbmcgYSBiZXppZXIgc3VwZXIgdGlueSBvciAwIGxlbmd0aClcbiAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDgpIHtcbiAgICAgICAgc2VnbWVudC5zcGxpY2UoaiwgNik7XG4gICAgICAgIGogLT0gNjtcbiAgICAgICAgZW5kSW5kZXggLT0gNjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMTsgaSA8PSByZXNvbHV0aW9uOyBpKyspIHtcbiAgICAgICAgdCA9IGluYyAqIGk7XG4gICAgICAgIGludiA9IDEgLSB0O1xuICAgICAgICB4ZCA9IHhkMSAtICh4ZDEgPSAodCAqIHQgKiB4NCArIDMgKiBpbnYgKiAodCAqIHgzICsgaW52ICogeDIpKSAqIHQpO1xuICAgICAgICB5ZCA9IHlkMSAtICh5ZDEgPSAodCAqIHQgKiB5NCArIDMgKiBpbnYgKiAodCAqIHkzICsgaW52ICogeTIpKSAqIHQpO1xuICAgICAgICBsID0gX3NxcnQoeWQgKiB5ZCArIHhkICogeGQpO1xuXG4gICAgICAgIGlmIChsIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCArPSBsO1xuICAgICAgICBzYW1wbGVzW3NhbXBsZXNJbmRleCsrXSA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4MSArPSB4NDtcbiAgICB5MSArPSB5NDtcbiAgfVxuXG4gIGlmIChwcmV2TGVuZ3RoKSB7XG4gICAgcHJldkxlbmd0aCAtPSBsZW5ndGg7XG5cbiAgICBmb3IgKDsgc2FtcGxlc0luZGV4IDwgc2FtcGxlcy5sZW5ndGg7IHNhbXBsZXNJbmRleCsrKSB7XG4gICAgICBzYW1wbGVzW3NhbXBsZXNJbmRleF0gKz0gcHJldkxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoc2FtcGxlcy5sZW5ndGggJiYgbWluKSB7XG4gICAgc2VnbWVudC50b3RhbExlbmd0aCA9IHNlZ0xlbmd0aCA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXSB8fCAwO1xuICAgIHNlZ21lbnQubWluTGVuZ3RoID0gbWluO1xuXG4gICAgaWYgKHNlZ0xlbmd0aCAvIG1pbiA8IDk5OTkpIHtcbiAgICAgIC8vIGlmIHRoZSBsb29rdXAgd291bGQgcmVxdWlyZSB0b28gbWFueSB2YWx1ZXMgKG1lbW9yeSBwcm9ibGVtKSwgd2Ugc2tpcCB0aGlzIGFuZCBpbnN0ZWFkIHdlIHVzZSBhIGxvb3AgdG8gbG9va3VwIHZhbHVlcyBkaXJlY3RseSBpbiB0aGUgc2FtcGxlcyBBcnJheVxuICAgICAgbCA9IGxlbmd0aEluZGV4ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ0xlbmd0aDsgaSArPSBtaW4pIHtcbiAgICAgICAgbG9va3VwW2wrK10gPSBzYW1wbGVzW2xlbmd0aEluZGV4XSA8IGkgPyArK2xlbmd0aEluZGV4IDogbGVuZ3RoSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlZ21lbnQudG90YWxMZW5ndGggPSBzYW1wbGVzWzBdID0gMDtcbiAgfVxuXG4gIHJldHVybiBzdGFydEluZGV4ID8gbGVuZ3RoIC0gc2FtcGxlc1tzdGFydEluZGV4IC8gMiAtIDFdIDogbGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgsIHJlc29sdXRpb24pIHtcbiAgdmFyIHBhdGhMZW5ndGgsIHBvaW50cywgaTtcblxuICBmb3IgKGkgPSBwYXRoTGVuZ3RoID0gcG9pbnRzID0gMDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcbiAgICByYXdQYXRoW2ldLnJlc29sdXRpb24gPSB+fnJlc29sdXRpb24gfHwgMTI7IC8vc3RlcHMgcGVyIEJlemllciBjdXJ2ZSAoYW5jaG9yLCAyIGNvbnRyb2wgcG9pbnRzLCB0byBhbmNob3IpXG5cbiAgICBwb2ludHMgKz0gcmF3UGF0aFtpXS5sZW5ndGg7XG4gICAgcGF0aExlbmd0aCArPSBtZWFzdXJlU2VnbWVudChyYXdQYXRoW2ldKTtcbiAgfVxuXG4gIHJhd1BhdGgudG90YWxQb2ludHMgPSBwb2ludHM7XG4gIHJhd1BhdGgudG90YWxMZW5ndGggPSBwYXRoTGVuZ3RoO1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy9kaXZpZGUgc2VnbWVudFtpXSBhdCBwb3NpdGlvbiB0ICh2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHByb2dyZXNzIGFsb25nIHRoYXQgcGFydGljdWxhciBjdWJpYyBiZXppZXIgc2VnbWVudCB0aGF0IHN0YXJ0cyBhdCBzZWdtZW50W2ldKS4gUmV0dXJucyBob3cgbWFueSBlbGVtZW50cyB3ZXJlIHNwbGljZWQgaW50byB0aGUgc2VnbWVudCBhcnJheSAoZWl0aGVyIDAgb3IgNilcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCkge1xuICBpZiAodCA8PSAwIHx8IHQgPj0gMSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGF4ID0gc2VnbWVudFtpXSxcbiAgICAgIGF5ID0gc2VnbWVudFtpICsgMV0sXG4gICAgICBjcDF4ID0gc2VnbWVudFtpICsgMl0sXG4gICAgICBjcDF5ID0gc2VnbWVudFtpICsgM10sXG4gICAgICBjcDJ4ID0gc2VnbWVudFtpICsgNF0sXG4gICAgICBjcDJ5ID0gc2VnbWVudFtpICsgNV0sXG4gICAgICBieCA9IHNlZ21lbnRbaSArIDZdLFxuICAgICAgYnkgPSBzZWdtZW50W2kgKyA3XSxcbiAgICAgIHgxYSA9IGF4ICsgKGNwMXggLSBheCkgKiB0LFxuICAgICAgeDIgPSBjcDF4ICsgKGNwMnggLSBjcDF4KSAqIHQsXG4gICAgICB5MWEgPSBheSArIChjcDF5IC0gYXkpICogdCxcbiAgICAgIHkyID0gY3AxeSArIChjcDJ5IC0gY3AxeSkgKiB0LFxuICAgICAgeDEgPSB4MWEgKyAoeDIgLSB4MWEpICogdCxcbiAgICAgIHkxID0geTFhICsgKHkyIC0geTFhKSAqIHQsXG4gICAgICB4MmEgPSBjcDJ4ICsgKGJ4IC0gY3AyeCkgKiB0LFxuICAgICAgeTJhID0gY3AyeSArIChieSAtIGNwMnkpICogdDtcbiAgeDIgKz0gKHgyYSAtIHgyKSAqIHQ7XG4gIHkyICs9ICh5MmEgLSB5MikgKiB0O1xuICBzZWdtZW50LnNwbGljZShpICsgMiwgNCwgX3JvdW5kKHgxYSksIC8vZmlyc3QgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTFhKSwgX3JvdW5kKHgxKSwgLy9zZWNvbmQgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTEpLCBfcm91bmQoeDEgKyAoeDIgLSB4MSkgKiB0KSwgLy9uZXcgZmFicmljYXRlZCBhbmNob3Igb24gbGluZVxuICBfcm91bmQoeTEgKyAoeTIgLSB5MSkgKiB0KSwgX3JvdW5kKHgyKSwgLy90aGlyZCBjb250cm9sIHBvaW50XG4gIF9yb3VuZCh5MiksIF9yb3VuZCh4MmEpLCAvL2ZvdXJ0aCBjb250cm9sIHBvaW50XG4gIF9yb3VuZCh5MmEpKTtcbiAgc2VnbWVudC5zYW1wbGVzICYmIHNlZ21lbnQuc2FtcGxlcy5zcGxpY2UoaSAvIDYgKiBzZWdtZW50LnJlc29sdXRpb24gfCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIDY7XG59IC8vIHJldHVybnMgYW4gb2JqZWN0IHtwYXRoLCBzZWdtZW50LCBzZWdJbmRleCwgaSwgdH1cblxuZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzLCBkZWNvcmF0ZWUsIHB1c2hUb05leHRJZkF0RW5kKSB7XG4gIGRlY29yYXRlZSA9IGRlY29yYXRlZSB8fCB7fTtcbiAgcmF3UGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCk7XG5cbiAgaWYgKHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA+IDEpIHtcbiAgICBwcm9ncmVzcyA9IF93cmFwUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIHNlZ0luZGV4ID0gMCxcbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBsZW5ndGgsXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICBpLFxuICAgICAgdDtcblxuICBpZiAoIXByb2dyZXNzKSB7XG4gICAgdCA9IGkgPSBzZWdJbmRleCA9IDA7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbMF07XG4gIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPT09IDEpIHtcbiAgICB0ID0gMTtcbiAgICBzZWdJbmRleCA9IHJhd1BhdGgubGVuZ3RoIC0gMTtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtzZWdJbmRleF07XG4gICAgaSA9IHNlZ21lbnQubGVuZ3RoIC0gODtcbiAgfSBlbHNlIHtcbiAgICBpZiAocmF3UGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAvL3NwZWVkIG9wdGltaXphdGlvbjogbW9zdCBvZiB0aGUgdGltZSwgdGhlcmUncyBvbmx5IG9uZSBzZWdtZW50IHNvIHNraXAgdGhlIHJlY3Vyc2lvbi5cbiAgICAgIGxlbmd0aCA9IHJhd1BhdGgudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICAgIG1heCA9IGkgPSAwO1xuXG4gICAgICB3aGlsZSAoKG1heCArPSByYXdQYXRoW2krK10udG90YWxMZW5ndGgpIDwgbGVuZ3RoKSB7XG4gICAgICAgIHNlZ0luZGV4ID0gaTtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuICAgICAgbWluID0gbWF4IC0gc2VnbWVudC50b3RhbExlbmd0aDtcbiAgICAgIHByb2dyZXNzID0gKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSB8fCAwO1xuICAgIH1cblxuICAgIHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXM7XG4gICAgcmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjsgLy9ob3cgbWFueSBzYW1wbGVzIHBlciBjdWJpYyBiZXppZXIgY2h1bmtcblxuICAgIGxlbmd0aCA9IHNlZ21lbnQudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICBpID0gc2VnbWVudC5sb29rdXAubGVuZ3RoID8gc2VnbWVudC5sb29rdXBbfn4obGVuZ3RoIC8gc2VnbWVudC5taW5MZW5ndGgpXSB8fCAwIDogX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpO1xuICAgIG1pbiA9IGkgPyBzYW1wbGVzW2kgLSAxXSA6IDA7XG4gICAgbWF4ID0gc2FtcGxlc1tpXTtcblxuICAgIGlmIChtYXggPCBsZW5ndGgpIHtcbiAgICAgIG1pbiA9IG1heDtcbiAgICAgIG1heCA9IHNhbXBsZXNbKytpXTtcbiAgICB9XG5cbiAgICB0ID0gMSAvIHJlc29sdXRpb24gKiAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSArIGkgJSByZXNvbHV0aW9uKTtcbiAgICBpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcblxuICAgIGlmIChwdXNoVG9OZXh0SWZBdEVuZCAmJiB0ID09PSAxKSB7XG4gICAgICBpZiAoaSArIDYgPCBzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICBpICs9IDY7XG4gICAgICAgIHQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzZWdJbmRleCArIDEgPCByYXdQYXRoLmxlbmd0aCkge1xuICAgICAgICBpID0gdCA9IDA7XG4gICAgICAgIHNlZ21lbnQgPSByYXdQYXRoWysrc2VnSW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY29yYXRlZS50ID0gdDtcbiAgZGVjb3JhdGVlLmkgPSBpO1xuICBkZWNvcmF0ZWUucGF0aCA9IHJhd1BhdGg7XG4gIGRlY29yYXRlZS5zZWdtZW50ID0gc2VnbWVudDtcbiAgZGVjb3JhdGVlLnNlZ0luZGV4ID0gc2VnSW5kZXg7XG4gIHJldHVybiBkZWNvcmF0ZWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbk9uUGF0aChyYXdQYXRoLCBwcm9ncmVzcywgaW5jbHVkZUFuZ2xlLCBwb2ludCkge1xuICB2YXIgc2VnbWVudCA9IHJhd1BhdGhbMF0sXG4gICAgICByZXN1bHQgPSBwb2ludCB8fCB7fSxcbiAgICAgIHNhbXBsZXMsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgbGVuZ3RoLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgaSxcbiAgICAgIHQsXG4gICAgICBhLFxuICAgICAgaW52O1xuXG4gIGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG4gICAgcHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcbiAgfVxuXG4gIGlmIChyYXdQYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAvL3NwZWVkIG9wdGltaXphdGlvbjogbW9zdCBvZiB0aGUgdGltZSwgdGhlcmUncyBvbmx5IG9uZSBzZWdtZW50IHNvIHNraXAgdGhlIHJlY3Vyc2lvbi5cbiAgICBsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgbWF4ID0gaSA9IDA7XG5cbiAgICB3aGlsZSAoKG1heCArPSByYXdQYXRoW2krK10udG90YWxMZW5ndGgpIDwgbGVuZ3RoKSB7XG4gICAgICBzZWdtZW50ID0gcmF3UGF0aFtpXTtcbiAgICB9XG5cbiAgICBtaW4gPSBtYXggLSBzZWdtZW50LnRvdGFsTGVuZ3RoO1xuICAgIHByb2dyZXNzID0gKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSB8fCAwO1xuICB9XG5cbiAgc2FtcGxlcyA9IHNlZ21lbnQuc2FtcGxlcztcbiAgcmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjtcbiAgbGVuZ3RoID0gc2VnbWVudC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuICBpID0gc2VnbWVudC5sb29rdXAubGVuZ3RoID8gc2VnbWVudC5sb29rdXBbcHJvZ3Jlc3MgPCAxID8gfn4obGVuZ3RoIC8gc2VnbWVudC5taW5MZW5ndGgpIDogc2VnbWVudC5sb29rdXAubGVuZ3RoIC0gMV0gfHwgMCA6IF9nZXRTYW1wbGVJbmRleChzYW1wbGVzLCBsZW5ndGgsIHByb2dyZXNzKTtcbiAgbWluID0gaSA/IHNhbXBsZXNbaSAtIDFdIDogMDtcbiAgbWF4ID0gc2FtcGxlc1tpXTtcblxuICBpZiAobWF4IDwgbGVuZ3RoKSB7XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHNhbXBsZXNbKytpXTtcbiAgfVxuXG4gIHQgPSAxIC8gcmVzb2x1dGlvbiAqICgobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pICsgaSAlIHJlc29sdXRpb24pIHx8IDA7XG4gIGludiA9IDEgLSB0O1xuICBpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcbiAgYSA9IHNlZ21lbnRbaV07XG4gIHJlc3VsdC54ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA2XSAtIGEpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDRdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgMl0gLSBhKSkpICogdCArIGEpO1xuICByZXN1bHQueSA9IF9yb3VuZCgodCAqIHQgKiAoc2VnbWVudFtpICsgN10gLSAoYSA9IHNlZ21lbnRbaSArIDFdKSkgKyAzICogaW52ICogKHQgKiAoc2VnbWVudFtpICsgNV0gLSBhKSArIGludiAqIChzZWdtZW50W2kgKyAzXSAtIGEpKSkgKiB0ICsgYSk7XG5cbiAgaWYgKGluY2x1ZGVBbmdsZSkge1xuICAgIHJlc3VsdC5hbmdsZSA9IHNlZ21lbnQudG90YWxMZW5ndGggPyBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0ID49IDEgPyAxIC0gMWUtOSA6IHQgPyB0IDogMWUtOSkgOiBzZWdtZW50LmFuZ2xlIHx8IDA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvL2FwcGxpZXMgYSBtYXRyaXggdHJhbnNmb3JtIHRvIFJhd1BhdGggKG9yIGEgc2VnbWVudCBpbiBhIFJhd1BhdGgpIGFuZCByZXR1cm5zIHdoYXRldmVyIHdhcyBwYXNzZWQgaW4gKGl0IHRyYW5zZm9ybXMgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkocyksIG5vdCBhIGNvcHkpLlxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgdmFyIGogPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBsLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5O1xuXG4gIHdoaWxlICgtLWogPiAtMSkge1xuICAgIHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuICAgIGwgPSBzZWdtZW50Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHggPSBzZWdtZW50W2ldO1xuICAgICAgeSA9IHNlZ21lbnRbaSArIDFdO1xuICAgICAgc2VnbWVudFtpXSA9IHggKiBhICsgeSAqIGMgKyB0eDtcbiAgICAgIHNlZ21lbnRbaSArIDFdID0geCAqIGIgKyB5ICogZCArIHR5O1xuICAgIH1cbiAgfVxuXG4gIHJhd1BhdGguX2RpcnR5ID0gMTtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vIHRyYW5zbGF0ZXMgU1ZHIGFyYyBkYXRhIGludG8gYSBzZWdtZW50IChjdWJpYyBiZXppZXJzKS4gQW5nbGUgaXMgaW4gZGVncmVlcy5cblxuZnVuY3Rpb24gYXJjVG9TZWdtZW50KGxhc3RYLCBsYXN0WSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcbiAgaWYgKGxhc3RYID09PSB4ICYmIGxhc3RZID09PSB5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcnggPSBfYWJzKHJ4KTtcbiAgcnkgPSBfYWJzKHJ5KTtcblxuICB2YXIgYW5nbGVSYWQgPSBhbmdsZSAlIDM2MCAqIF9ERUcyUkFELFxuICAgICAgY29zQW5nbGUgPSBfY29zKGFuZ2xlUmFkKSxcbiAgICAgIHNpbkFuZ2xlID0gX3NpbihhbmdsZVJhZCksXG4gICAgICBQSSA9IE1hdGguUEksXG4gICAgICBUV09QSSA9IFBJICogMixcbiAgICAgIGR4MiA9IChsYXN0WCAtIHgpIC8gMixcbiAgICAgIGR5MiA9IChsYXN0WSAtIHkpIC8gMixcbiAgICAgIHgxID0gY29zQW5nbGUgKiBkeDIgKyBzaW5BbmdsZSAqIGR5MixcbiAgICAgIHkxID0gLXNpbkFuZ2xlICogZHgyICsgY29zQW5nbGUgKiBkeTIsXG4gICAgICB4MV9zcSA9IHgxICogeDEsXG4gICAgICB5MV9zcSA9IHkxICogeTEsXG4gICAgICByYWRpaUNoZWNrID0geDFfc3EgLyAocnggKiByeCkgKyB5MV9zcSAvIChyeSAqIHJ5KTtcblxuICBpZiAocmFkaWlDaGVjayA+IDEpIHtcbiAgICByeCA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcng7XG4gICAgcnkgPSBfc3FydChyYWRpaUNoZWNrKSAqIHJ5O1xuICB9XG5cbiAgdmFyIHJ4X3NxID0gcnggKiByeCxcbiAgICAgIHJ5X3NxID0gcnkgKiByeSxcbiAgICAgIHNxID0gKHJ4X3NxICogcnlfc3EgLSByeF9zcSAqIHkxX3NxIC0gcnlfc3EgKiB4MV9zcSkgLyAocnhfc3EgKiB5MV9zcSArIHJ5X3NxICogeDFfc3EpO1xuXG4gIGlmIChzcSA8IDApIHtcbiAgICBzcSA9IDA7XG4gIH1cblxuICB2YXIgY29lZiA9IChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBfc3FydChzcSksXG4gICAgICBjeDEgPSBjb2VmICogKHJ4ICogeTEgLyByeSksXG4gICAgICBjeTEgPSBjb2VmICogLShyeSAqIHgxIC8gcngpLFxuICAgICAgc3gyID0gKGxhc3RYICsgeCkgLyAyLFxuICAgICAgc3kyID0gKGxhc3RZICsgeSkgLyAyLFxuICAgICAgY3ggPSBzeDIgKyAoY29zQW5nbGUgKiBjeDEgLSBzaW5BbmdsZSAqIGN5MSksXG4gICAgICBjeSA9IHN5MiArIChzaW5BbmdsZSAqIGN4MSArIGNvc0FuZ2xlICogY3kxKSxcbiAgICAgIHV4ID0gKHgxIC0gY3gxKSAvIHJ4LFxuICAgICAgdXkgPSAoeTEgLSBjeTEpIC8gcnksXG4gICAgICB2eCA9ICgteDEgLSBjeDEpIC8gcngsXG4gICAgICB2eSA9ICgteTEgLSBjeTEpIC8gcnksXG4gICAgICB0ZW1wID0gdXggKiB1eCArIHV5ICogdXksXG4gICAgICBhbmdsZVN0YXJ0ID0gKHV5IDwgMCA/IC0xIDogMSkgKiBNYXRoLmFjb3ModXggLyBfc3FydCh0ZW1wKSksXG4gICAgICBhbmdsZUV4dGVudCA9ICh1eCAqIHZ5IC0gdXkgKiB2eCA8IDAgPyAtMSA6IDEpICogTWF0aC5hY29zKCh1eCAqIHZ4ICsgdXkgKiB2eSkgLyBfc3FydCh0ZW1wICogKHZ4ICogdnggKyB2eSAqIHZ5KSkpO1xuXG4gIGlzTmFOKGFuZ2xlRXh0ZW50KSAmJiAoYW5nbGVFeHRlbnQgPSBQSSk7IC8vcmFyZSBlZGdlIGNhc2UuIE1hdGguY29zKC0xKSBpcyBOYU4uXG5cbiAgaWYgKCFzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPiAwKSB7XG4gICAgYW5nbGVFeHRlbnQgLT0gVFdPUEk7XG4gIH0gZWxzZSBpZiAoc3dlZXBGbGFnICYmIGFuZ2xlRXh0ZW50IDwgMCkge1xuICAgIGFuZ2xlRXh0ZW50ICs9IFRXT1BJO1xuICB9XG5cbiAgYW5nbGVTdGFydCAlPSBUV09QSTtcbiAgYW5nbGVFeHRlbnQgJT0gVFdPUEk7XG5cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKF9hYnMoYW5nbGVFeHRlbnQpIC8gKFRXT1BJIC8gNCkpLFxuICAgICAgcmF3UGF0aCA9IFtdLFxuICAgICAgYW5nbGVJbmNyZW1lbnQgPSBhbmdsZUV4dGVudCAvIHNlZ21lbnRzLFxuICAgICAgY29udHJvbExlbmd0aCA9IDQgLyAzICogX3NpbihhbmdsZUluY3JlbWVudCAvIDIpIC8gKDEgKyBfY29zKGFuZ2xlSW5jcmVtZW50IC8gMikpLFxuICAgICAgbWEgPSBjb3NBbmdsZSAqIHJ4LFxuICAgICAgbWIgPSBzaW5BbmdsZSAqIHJ4LFxuICAgICAgbWMgPSBzaW5BbmdsZSAqIC1yeSxcbiAgICAgIG1kID0gY29zQW5nbGUgKiByeSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICBhbmdsZSA9IGFuZ2xlU3RhcnQgKyBpICogYW5nbGVJbmNyZW1lbnQ7XG4gICAgeDEgPSBfY29zKGFuZ2xlKTtcbiAgICB5MSA9IF9zaW4oYW5nbGUpO1xuICAgIHV4ID0gX2NvcyhhbmdsZSArPSBhbmdsZUluY3JlbWVudCk7XG4gICAgdXkgPSBfc2luKGFuZ2xlKTtcbiAgICByYXdQYXRoLnB1c2goeDEgLSBjb250cm9sTGVuZ3RoICogeTEsIHkxICsgY29udHJvbExlbmd0aCAqIHgxLCB1eCArIGNvbnRyb2xMZW5ndGggKiB1eSwgdXkgLSBjb250cm9sTGVuZ3RoICogdXgsIHV4LCB1eSk7XG4gIH0gLy9ub3cgdHJhbnNmb3JtIGFjY29yZGluZyB0byB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGVsbGlwc2UvYXJjICh0aGUgYmV6aWVycyB3ZXJlIG5vcmFtbGl6ZWQsIGJldHdlZW4gMCBhbmQgMSBvbiBhIGNpcmNsZSkuXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHgxID0gcmF3UGF0aFtpXTtcbiAgICB5MSA9IHJhd1BhdGhbaSArIDFdO1xuICAgIHJhd1BhdGhbaV0gPSB4MSAqIG1hICsgeTEgKiBtYyArIGN4O1xuICAgIHJhd1BhdGhbaSArIDFdID0geDEgKiBtYiArIHkxICogbWQgKyBjeTtcbiAgfVxuXG4gIHJhd1BhdGhbaSAtIDJdID0geDsgLy9hbHdheXMgc2V0IHRoZSBlbmQgdG8gZXhhY3RseSB3aGVyZSBpdCdzIHN1cHBvc2VkIHRvIGJlXG5cbiAgcmF3UGF0aFtpIC0gMV0gPSB5O1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy9TcGl0cyBiYWNrIGEgUmF3UGF0aCB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzLiBFYWNoIHNlZ21lbnQgc3RhcnRzIHdpdGggYSBcIm1vdmVUb1wiIGNvbW1hbmQgKHggY29vcmRpbmF0ZSwgdGhlbiB5KSBhbmQgdGhlbiAyIGNvbnRyb2wgcG9pbnRzICh4LCB5LCB4LCB5KSwgdGhlbiBhbmNob3IuIFRoZSBnb2FsIGlzIHRvIG1pbmltaXplIG1lbW9yeSBhbmQgbWF4aW1pemUgc3BlZWQuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvUmF3UGF0aChkKSB7XG4gIHZhciBhID0gKGQgKyBcIlwiKS5yZXBsYWNlKF9zY2llbnRpZmljLCBmdW5jdGlvbiAobSkge1xuICAgIHZhciBuID0gK207XG4gICAgcmV0dXJuIG4gPCAwLjAwMDEgJiYgbiA+IC0wLjAwMDEgPyAwIDogbjtcbiAgfSkubWF0Y2goX3N2Z1BhdGhFeHApIHx8IFtdLFxuICAgICAgLy9zb21lIGF1dGhvcmluZyBwcm9ncmFtcyBzcGl0IG91dCB2ZXJ5IHNtYWxsIG51bWJlcnMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIFwiMWUtNVwiLCBzbyBtYWtlIHN1cmUgd2Ugcm91bmQgdGhhdCBkb3duIHRvIDAgZmlyc3QuXG4gIHBhdGggPSBbXSxcbiAgICAgIHJlbGF0aXZlWCA9IDAsXG4gICAgICByZWxhdGl2ZVkgPSAwLFxuICAgICAgdHdvVGhpcmRzID0gMiAvIDMsXG4gICAgICBlbGVtZW50cyA9IGEubGVuZ3RoLFxuICAgICAgcG9pbnRzID0gMCxcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiRVJST1I6IG1hbGZvcm1lZCBwYXRoOiBcIiArIGQsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY29tbWFuZCxcbiAgICAgIGlzUmVsYXRpdmUsXG4gICAgICBzZWdtZW50LFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgZGlmWCxcbiAgICAgIGRpZlksXG4gICAgICBiZXppZXJzLFxuICAgICAgcHJldkNvbW1hbmQsXG4gICAgICBmbGFnMSxcbiAgICAgIGZsYWcyLFxuICAgICAgbGluZSA9IGZ1bmN0aW9uIGxpbmUoc3gsIHN5LCBleCwgZXkpIHtcbiAgICBkaWZYID0gKGV4IC0gc3gpIC8gMztcbiAgICBkaWZZID0gKGV5IC0gc3kpIC8gMztcbiAgICBzZWdtZW50LnB1c2goc3ggKyBkaWZYLCBzeSArIGRpZlksIGV4IC0gZGlmWCwgZXkgLSBkaWZZLCBleCwgZXkpO1xuICB9O1xuXG4gIGlmICghZCB8fCAhaXNOYU4oYVswXSkgfHwgaXNOYU4oYVsxXSkpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzOyBpKyspIHtcbiAgICBwcmV2Q29tbWFuZCA9IGNvbW1hbmQ7XG5cbiAgICBpZiAoaXNOYU4oYVtpXSkpIHtcbiAgICAgIGNvbW1hbmQgPSBhW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpc1JlbGF0aXZlID0gY29tbWFuZCAhPT0gYVtpXTsgLy9sb3dlciBjYXNlIG1lYW5zIHJlbGF0aXZlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29tbWFuZHMgbGlrZSBcIkNcIiBjYW4gYmUgc3RydW5nIHRvZ2V0aGVyIHdpdGhvdXQgYW55IG5ldyBjb21tYW5kIGNoYXJhY3RlcnMgYmV0d2Vlbi5cbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICB4ID0gK2FbaSArIDFdO1xuICAgIHkgPSArYVtpICsgMl07XG5cbiAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgeCArPSByZWxhdGl2ZVg7XG4gICAgICB5ICs9IHJlbGF0aXZlWTtcbiAgICB9XG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICBzdGFydFkgPSB5O1xuICAgIH0gLy8gXCJNXCIgKG1vdmUpXG5cblxuICAgIGlmIChjb21tYW5kID09PSBcIk1cIikge1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIC8vaWYgdGhlIHBhdGggZGF0YSB3YXMgZnVua3kgYW5kIGp1c3QgaGFkIGEgTSB3aXRoIG5vIGFjdHVhbCBkcmF3aW5nIGFueXdoZXJlLCBza2lwIGl0LlxuICAgICAgICAgIHBhdGgubGVuZ3RoIC09IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRzICs9IHNlZ21lbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCA9IHN0YXJ0WCA9IHg7XG4gICAgICByZWxhdGl2ZVkgPSBzdGFydFkgPSB5O1xuICAgICAgc2VnbWVudCA9IFt4LCB5XTtcbiAgICAgIHBhdGgucHVzaChzZWdtZW50KTtcbiAgICAgIGkgKz0gMjtcbiAgICAgIGNvbW1hbmQgPSBcIkxcIjsgLy9hbiBcIk1cIiB3aXRoIG1vcmUgdGhhbiAyIHZhbHVlcyBnZXRzIGludGVycHJldGVkIGFzIFwibGluZVRvXCIgY29tbWFuZHMgKFwiTFwiKS5cbiAgICAgIC8vIFwiQ1wiIChjdWJpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkNcIikge1xuICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHNlZ21lbnQgPSBbMCwgMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfSAvL25vdGU6IFwiKjFcIiBpcyBqdXN0IGEgZmFzdC9zaG9ydCB3YXkgdG8gY2FzdCB0aGUgdmFsdWUgYXMgYSBOdW1iZXIuIFdBQUFZIGZhc3RlciBpbiBDaHJvbWUsIHNsaWdodGx5IHNsb3dlciBpbiBGaXJlZm94LlxuXG5cbiAgICAgIHNlZ21lbnQucHVzaCh4LCB5LCByZWxhdGl2ZVggKyBhW2kgKyAzXSAqIDEsIHJlbGF0aXZlWSArIGFbaSArIDRdICogMSwgcmVsYXRpdmVYICs9IGFbaSArIDVdICogMSwgcmVsYXRpdmVZICs9IGFbaSArIDZdICogMSk7XG4gICAgICBpICs9IDY7IC8vIFwiU1wiIChjb250aW51YXRpb24gb2YgY3ViaWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJTXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVg7XG4gICAgICBkaWZZID0gcmVsYXRpdmVZO1xuXG4gICAgICBpZiAocHJldkNvbW1hbmQgPT09IFwiQ1wiIHx8IHByZXZDb21tYW5kID09PSBcIlNcIikge1xuICAgICAgICBkaWZYICs9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcbiAgICAgICAgZGlmWSArPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgeCwgeSwgcmVsYXRpdmVYICs9IGFbaSArIDNdICogMSwgcmVsYXRpdmVZICs9IGFbaSArIDRdICogMSk7XG4gICAgICBpICs9IDQ7IC8vIFwiUVwiIChxdWFkcmF0aWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJRXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHM7XG4gICAgICBkaWZZID0gcmVsYXRpdmVZICsgKHkgLSByZWxhdGl2ZVkpICogdHdvVGhpcmRzO1xuXG4gICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcbiAgICAgICAgcmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYICs9IGFbaSArIDNdICogMTtcbiAgICAgIHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDE7XG4gICAgICBzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgcmVsYXRpdmVYICsgKHggLSByZWxhdGl2ZVgpICogdHdvVGhpcmRzLCByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWCwgcmVsYXRpdmVZKTtcbiAgICAgIGkgKz0gNDsgLy8gXCJUXCIgKGNvbnRpbnVhdGlvbiBvZiBxdWFkcmF0aWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJUXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG4gICAgICBkaWZZID0gcmVsYXRpdmVZIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDNdO1xuICAgICAgc2VnbWVudC5wdXNoKHJlbGF0aXZlWCArIGRpZlgsIHJlbGF0aXZlWSArIGRpZlksIHggKyAocmVsYXRpdmVYICsgZGlmWCAqIDEuNSAtIHgpICogdHdvVGhpcmRzLCB5ICsgKHJlbGF0aXZlWSArIGRpZlkgKiAxLjUgLSB5KSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYID0geCwgcmVsYXRpdmVZID0geSk7XG4gICAgICBpICs9IDI7IC8vIFwiSFwiIChob3Jpem9udGFsIGxpbmUpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkhcIikge1xuICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgcmVsYXRpdmVYID0geCwgcmVsYXRpdmVZKTtcbiAgICAgIGkgKz0gMTsgLy8gXCJWXCIgKHZlcnRpY2FsIGxpbmUpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlZcIikge1xuICAgICAgLy9hZGp1c3QgdmFsdWVzIGJlY2F1c2UgdGhlIGZpcnN0IChhbmQgb25seSBvbmUpIGlzbid0IHggaW4gdGhpcyBjYXNlLCBpdCdzIHkuXG4gICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCByZWxhdGl2ZVgsIHJlbGF0aXZlWSA9IHggKyAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWSAtIHJlbGF0aXZlWCA6IDApKTtcbiAgICAgIGkgKz0gMTsgLy8gXCJMXCIgKGxpbmUpIG9yIFwiWlwiIChjbG9zZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiTFwiIHx8IGNvbW1hbmQgPT09IFwiWlwiKSB7XG4gICAgICBpZiAoY29tbWFuZCA9PT0gXCJaXCIpIHtcbiAgICAgICAgeCA9IHN0YXJ0WDtcbiAgICAgICAgeSA9IHN0YXJ0WTtcbiAgICAgICAgc2VnbWVudC5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgX2FicyhyZWxhdGl2ZVggLSB4KSA+IDAuNSB8fCBfYWJzKHJlbGF0aXZlWSAtIHkpID4gMC41KSB7XG4gICAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHgsIHkpO1xuXG4gICAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIikge1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggPSB4O1xuICAgICAgcmVsYXRpdmVZID0geTsgLy8gXCJBXCIgKGFyYylcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQVwiKSB7XG4gICAgICBmbGFnMSA9IGFbaSArIDRdO1xuICAgICAgZmxhZzIgPSBhW2kgKyA1XTtcbiAgICAgIGRpZlggPSBhW2kgKyA2XTtcbiAgICAgIGRpZlkgPSBhW2kgKyA3XTtcbiAgICAgIGogPSA3O1xuXG4gICAgICBpZiAoZmxhZzEubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBmb3IgY2FzZXMgd2hlbiB0aGUgZmxhZ3MgYXJlIG1lcmdlZCwgbGlrZSBcImE4IDggMCAwMTggOFwiICh0aGUgMCBhbmQgMSBmbGFncyBhcmUgV0lUSCB0aGUgeCB2YWx1ZSBvZiA4LCBidXQgaXQgY291bGQgYWxzbyBiZSBcImE4IDggMCAwMS04IDhcIiBzbyBpdCBtYXkgaW5jbHVkZSB4IG9yIG5vdClcbiAgICAgICAgaWYgKGZsYWcxLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICBkaWZZID0gZGlmWDtcbiAgICAgICAgICBkaWZYID0gZmxhZzI7XG4gICAgICAgICAgai0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZlkgPSBmbGFnMjtcbiAgICAgICAgICBkaWZYID0gZmxhZzEuc3Vic3RyKDIpO1xuICAgICAgICAgIGogLT0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYWcyID0gZmxhZzEuY2hhckF0KDEpO1xuICAgICAgICBmbGFnMSA9IGZsYWcxLmNoYXJBdCgwKTtcbiAgICAgIH1cblxuICAgICAgYmV6aWVycyA9IGFyY1RvU2VnbWVudChyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgK2FbaSArIDFdLCArYVtpICsgMl0sICthW2kgKyAzXSwgK2ZsYWcxLCArZmxhZzIsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVYIDogMCkgKyBkaWZYICogMSwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgOiAwKSArIGRpZlkgKiAxKTtcbiAgICAgIGkgKz0gajtcblxuICAgICAgaWYgKGJlemllcnMpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGJlemllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50LnB1c2goYmV6aWVyc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDJdO1xuICAgICAgcmVsYXRpdmVZID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGkgPSBzZWdtZW50Lmxlbmd0aDtcblxuICBpZiAoaSA8IDYpIHtcbiAgICAvL2luIGNhc2UgdGhlcmUncyBvZGQgU1ZHIGxpa2UgYSBNMCwwIGNvbW1hbmQgYXQgdGhlIHZlcnkgZW5kLlxuICAgIHBhdGgucG9wKCk7XG4gICAgaSA9IDA7XG4gIH0gZWxzZSBpZiAoc2VnbWVudFswXSA9PT0gc2VnbWVudFtpIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gc2VnbWVudFtpIC0gMV0pIHtcbiAgICBzZWdtZW50LmNsb3NlZCA9IHRydWU7XG4gIH1cblxuICBwYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzICsgaTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vcG9wdWxhdGVzIHRoZSBwb2ludHMgYXJyYXkgaW4gYWx0ZXJuYXRpbmcgeC95IHZhbHVlcyAobGlrZSBbeCwgeSwgeCwgeS4uLl0gaW5zdGVhZCBvZiBpbmRpdmlkdWFsIHBvaW50IG9iamVjdHMgW3t4LCB5fSwge3gsIHl9Li4uXSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIHN0YXkgaW4gbGluZSB3aXRoIGhvdyB3ZSdyZSBoYW5kbGluZyBzZWdtZW50IGFycmF5c1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIHgxMiA9ICh4MSArIHgyKSAvIDIsXG4gICAgICB5MTIgPSAoeTEgKyB5MikgLyAyLFxuICAgICAgeDIzID0gKHgyICsgeDMpIC8gMixcbiAgICAgIHkyMyA9ICh5MiArIHkzKSAvIDIsXG4gICAgICB4MzQgPSAoeDMgKyB4NCkgLyAyLFxuICAgICAgeTM0ID0gKHkzICsgeTQpIC8gMixcbiAgICAgIHgxMjMgPSAoeDEyICsgeDIzKSAvIDIsXG4gICAgICB5MTIzID0gKHkxMiArIHkyMykgLyAyLFxuICAgICAgeDIzNCA9ICh4MjMgKyB4MzQpIC8gMixcbiAgICAgIHkyMzQgPSAoeTIzICsgeTM0KSAvIDIsXG4gICAgICB4MTIzNCA9ICh4MTIzICsgeDIzNCkgLyAyLFxuICAgICAgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMixcbiAgICAgIGR4ID0geDQgLSB4MSxcbiAgICAgIGR5ID0geTQgLSB5MSxcbiAgICAgIGQyID0gX2FicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KSxcbiAgICAgIGQzID0gX2FicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KSxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAoIXBvaW50cykge1xuICAgIHBvaW50cyA9IFt4MSwgeTEsIHg0LCB5NF07XG4gICAgaW5kZXggPSAyO1xuICB9XG5cbiAgcG9pbnRzLnNwbGljZShpbmRleCB8fCBwb2ludHMubGVuZ3RoIC0gMiwgMCwgeDEyMzQsIHkxMjM0KTtcblxuICBpZiAoKGQyICsgZDMpICogKGQyICsgZDMpID4gdGhyZXNob2xkICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG4gICAgYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MTIsIHkxMiwgeDEyMywgeTEyMywgeDEyMzQsIHkxMjM0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpO1xuICAgIGJlemllclRvUG9pbnRzKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4ICsgMiArIChwb2ludHMubGVuZ3RoIC0gbGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuLypcbmZ1bmN0aW9uIGdldEFuZ2xlQmV0d2VlblBvaW50cyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7IC8vYW5nbGUgYmV0d2VlbiAzIHBvaW50cyBpbiByYWRpYW5zXG5cdHZhciBkeDEgPSB4MSAtIHgwLFxuXHRcdGR5MSA9IHkxIC0geTAsXG5cdFx0ZHgyID0geDIgLSB4MSxcblx0XHRkeTIgPSB5MiAtIHkxLFxuXHRcdGR4MyA9IHgyIC0geDAsXG5cdFx0ZHkzID0geTIgLSB5MCxcblx0XHRhID0gZHgxICogZHgxICsgZHkxICogZHkxLFxuXHRcdGIgPSBkeDIgKiBkeDIgKyBkeTIgKiBkeTIsXG5cdFx0YyA9IGR4MyAqIGR4MyArIGR5MyAqIGR5Mztcblx0cmV0dXJuIE1hdGguYWNvcyggKGEgKyBiIC0gYykgLyBfc3FydCg0ICogYSAqIGIpICk7XG59LFxuKi9cbi8vcG9pbnRzVG9TZWdtZW50KCkgZG9lc24ndCBoYW5kbGUgZmxhdCBjb29yZGluYXRlcyAod2hlcmUgeSBpcyBhbHdheXMgMCkgdGhlIHdheSB3ZSBuZWVkICh0aGUgcmVzdWx0aW5nIGNvbnRyb2wgcG9pbnRzIGFyZSBhbHdheXMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzKSwgc28gdGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgbWFrZXMgdGhlIGNvbnRyb2wgcG9pbnRzIGdvIGRpcmVjdGx5IHVwIGFuZCBkb3duLCB2YXJ5aW5nIGluIGxlbmd0aCBiYXNlZCBvbiB0aGUgY3VydmluZXNzIChtb3JlIGN1cnZ5LCBmdXJ0aGVyIGNvbnRyb2wgcG9pbnRzKVxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdFBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcykge1xuICBpZiAoY3VydmluZXNzID09PSB2b2lkIDApIHtcbiAgICBjdXJ2aW5lc3MgPSAxO1xuICB9XG5cbiAgdmFyIHggPSBwb2ludHNbMF0sXG4gICAgICB5ID0gMCxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeV0sXG4gICAgICBpID0gMjtcblxuICBmb3IgKDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHNlZ21lbnQucHVzaCh4LCB5LCBwb2ludHNbaV0sIHkgPSAocG9pbnRzW2ldIC0geCkgKiBjdXJ2aW5lc3MgLyAyLCB4ID0gcG9pbnRzW2ldLCAteSk7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudDtcbn0gLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHBvaW50cywgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeV1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcykge1xuICAvL3BvaW50cyA9IHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKTtcbiAgX2Ficyhwb2ludHNbMF0gLSBwb2ludHNbMl0pIDwgMWUtNCAmJiBfYWJzKHBvaW50c1sxXSAtIHBvaW50c1szXSkgPCAxZS00ICYmIChwb2ludHMgPSBwb2ludHMuc2xpY2UoMikpOyAvLyBpZiB0aGUgZmlyc3QgdHdvIHBvaW50cyBhcmUgc3VwZXIgY2xvc2UsIGR1bXAgdGhlIGZpcnN0IG9uZS5cblxuICB2YXIgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgeCA9ICtwb2ludHNbMF0sXG4gICAgICB5ID0gK3BvaW50c1sxXSxcbiAgICAgIG5leHRYID0gK3BvaW50c1syXSxcbiAgICAgIG5leHRZID0gK3BvaW50c1szXSxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeSwgeCwgeV0sXG4gICAgICBkeDIgPSBuZXh0WCAtIHgsXG4gICAgICBkeTIgPSBuZXh0WSAtIHksXG4gICAgICBjbG9zZWQgPSBNYXRoLmFicyhwb2ludHNbbF0gLSB4KSA8IDAuMDAxICYmIE1hdGguYWJzKHBvaW50c1tsICsgMV0gLSB5KSA8IDAuMDAxLFxuICAgICAgcHJldlgsXG4gICAgICBwcmV2WSxcbiAgICAgIGksXG4gICAgICBkeDEsXG4gICAgICBkeTEsXG4gICAgICByMSxcbiAgICAgIHIyLFxuICAgICAgcjMsXG4gICAgICB0bCxcbiAgICAgIG14MSxcbiAgICAgIG14MixcbiAgICAgIG14bSxcbiAgICAgIG15MSxcbiAgICAgIG15MixcbiAgICAgIG15bTtcblxuICBpZiAoY2xvc2VkKSB7XG4gICAgLy8gaWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBiYXNpY2FsbHkgb24gdG9wIG9mIGVhY2ggb3RoZXIsIGNsb3NlIHRoZSBzZWdtZW50IGJ5IGFkZGluZyB0aGUgMm5kIHBvaW50IHRvIHRoZSBlbmQsIGFuZCB0aGUgMm5kLXRvLWxhc3QgcG9pbnQgdG8gdGhlIGJlZ2lubmluZyAod2UnbGwgcmVtb3ZlIHRoZW0gYXQgdGhlIGVuZCwgYnV0IHRoaXMgYWxsb3dzIHRoZSBjdXJ2YXR1cmUgdG8gbG9vayBwZXJmZWN0KVxuICAgIHBvaW50cy5wdXNoKG5leHRYLCBuZXh0WSk7XG4gICAgbmV4dFggPSB4O1xuICAgIG5leHRZID0geTtcbiAgICB4ID0gcG9pbnRzW2wgLSAyXTtcbiAgICB5ID0gcG9pbnRzW2wgLSAxXTtcbiAgICBwb2ludHMudW5zaGlmdCh4LCB5KTtcbiAgICBsICs9IDQ7XG4gIH1cblxuICBjdXJ2aW5lc3MgPSBjdXJ2aW5lc3MgfHwgY3VydmluZXNzID09PSAwID8gK2N1cnZpbmVzcyA6IDE7XG5cbiAgZm9yIChpID0gMjsgaSA8IGw7IGkgKz0gMikge1xuICAgIHByZXZYID0geDtcbiAgICBwcmV2WSA9IHk7XG4gICAgeCA9IG5leHRYO1xuICAgIHkgPSBuZXh0WTtcbiAgICBuZXh0WCA9ICtwb2ludHNbaSArIDJdO1xuICAgIG5leHRZID0gK3BvaW50c1tpICsgM107XG5cbiAgICBpZiAoeCA9PT0gbmV4dFggJiYgeSA9PT0gbmV4dFkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGR4MSA9IGR4MjtcbiAgICBkeTEgPSBkeTI7XG4gICAgZHgyID0gbmV4dFggLSB4O1xuICAgIGR5MiA9IG5leHRZIC0geTtcbiAgICByMSA9IF9zcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7IC8vIHIxLCByMiwgYW5kIHIzIGNvcnJlbGF0ZSB4IGFuZCB5IChhbmQgeiBpbiB0aGUgZnV0dXJlKS4gQmFzaWNhbGx5IDJEIG9yIDNEIGh5cG90ZW51c2VcblxuICAgIHIyID0gX3NxcnQoZHgyICogZHgyICsgZHkyICogZHkyKTtcbiAgICByMyA9IF9zcXJ0KE1hdGgucG93KGR4MiAvIHIyICsgZHgxIC8gcjEsIDIpICsgTWF0aC5wb3coZHkyIC8gcjIgKyBkeTEgLyByMSwgMikpO1xuICAgIHRsID0gKHIxICsgcjIpICogY3VydmluZXNzICogMC4yNSAvIHIzO1xuICAgIG14MSA9IHggLSAoeCAtIHByZXZYKSAqIChyMSA/IHRsIC8gcjEgOiAwKTtcbiAgICBteDIgPSB4ICsgKG5leHRYIC0geCkgKiAocjIgPyB0bCAvIHIyIDogMCk7XG4gICAgbXhtID0geCAtIChteDEgKyAoKG14MiAtIG14MSkgKiAocjEgKiAzIC8gKHIxICsgcjIpICsgMC41KSAvIDQgfHwgMCkpO1xuICAgIG15MSA9IHkgLSAoeSAtIHByZXZZKSAqIChyMSA/IHRsIC8gcjEgOiAwKTtcbiAgICBteTIgPSB5ICsgKG5leHRZIC0geSkgKiAocjIgPyB0bCAvIHIyIDogMCk7XG4gICAgbXltID0geSAtIChteTEgKyAoKG15MiAtIG15MSkgKiAocjEgKiAzIC8gKHIxICsgcjIpICsgMC41KSAvIDQgfHwgMCkpO1xuXG4gICAgaWYgKHggIT09IHByZXZYIHx8IHkgIT09IHByZXZZKSB7XG4gICAgICBzZWdtZW50LnB1c2goX3JvdW5kKG14MSArIG14bSksIC8vIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgIF9yb3VuZChteTEgKyBteW0pLCBfcm91bmQoeCksIC8vIGFuY2hvclxuICAgICAgX3JvdW5kKHkpLCBfcm91bmQobXgyICsgbXhtKSwgLy8gc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgICAgIF9yb3VuZChteTIgKyBteW0pKTtcbiAgICB9XG4gIH1cblxuICB4ICE9PSBuZXh0WCB8fCB5ICE9PSBuZXh0WSB8fCBzZWdtZW50Lmxlbmd0aCA8IDQgPyBzZWdtZW50LnB1c2goX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSwgX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSkgOiBzZWdtZW50Lmxlbmd0aCAtPSAyO1xuXG4gIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgIC8vIG9ubHkgb25lIHBvaW50IVxuICAgIHNlZ21lbnQucHVzaCh4LCB5LCB4LCB5LCB4LCB5KTtcbiAgfSBlbHNlIGlmIChjbG9zZWQpIHtcbiAgICBzZWdtZW50LnNwbGljZSgwLCA2KTtcbiAgICBzZWdtZW50Lmxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoIC0gNjtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufSAvL3JldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhbiB4L3kgY29vcmRpbmF0ZSBhbmQgYSBzZWdtZW50IGJldHdlZW4geDEveTEgYW5kIHgyL3kyXG5cbmZ1bmN0aW9uIHBvaW50VG9TZWdEaXN0KHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBkeCA9IHgyIC0geDEsXG4gICAgICBkeSA9IHkyIC0geTEsXG4gICAgICB0O1xuXG4gIGlmIChkeCB8fCBkeSkge1xuICAgIHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgIGlmICh0ID4gMSkge1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgeDEgKz0gZHggKiB0O1xuICAgICAgeTEgKz0gZHkgKiB0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLnBvdyh4IC0geDEsIDIpICsgTWF0aC5wb3coeSAtIHkxLCAyKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICB2YXIgbWF4U3FEaXN0ID0gdG9sZXJhbmNlLFxuICAgICAgZmlyc3RYID0gcG9pbnRzW2ZpcnN0XSxcbiAgICAgIGZpcnN0WSA9IHBvaW50c1tmaXJzdCArIDFdLFxuICAgICAgbGFzdFggPSBwb2ludHNbbGFzdF0sXG4gICAgICBsYXN0WSA9IHBvaW50c1tsYXN0ICsgMV0sXG4gICAgICBpbmRleCxcbiAgICAgIGksXG4gICAgICBkO1xuXG4gIGZvciAoaSA9IGZpcnN0ICsgMjsgaSA8IGxhc3Q7IGkgKz0gMikge1xuICAgIGQgPSBwb2ludFRvU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIGZpcnN0WCwgZmlyc3RZLCBsYXN0WCwgbGFzdFkpO1xuXG4gICAgaWYgKGQgPiBtYXhTcURpc3QpIHtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIG1heFNxRGlzdCA9IGQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heFNxRGlzdCA+IHRvbGVyYW5jZSkge1xuICAgIGluZGV4IC0gZmlyc3QgPiAyICYmIHNpbXBsaWZ5U3RlcChwb2ludHMsIGZpcnN0LCBpbmRleCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2luZGV4XSwgcG9pbnRzW2luZGV4ICsgMV0pO1xuICAgIGxhc3QgLSBpbmRleCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gIH1cbn0gLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHZhbHVlcyBsaWtlIFt4LCB5LCB4LCB5LCB4LCB5XVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeVBvaW50cyhwb2ludHMsIHRvbGVyYW5jZSkge1xuICB2YXIgcHJldlggPSBwYXJzZUZsb2F0KHBvaW50c1swXSksXG4gICAgICBwcmV2WSA9IHBhcnNlRmxvYXQocG9pbnRzWzFdKSxcbiAgICAgIHRlbXAgPSBbcHJldlgsIHByZXZZXSxcbiAgICAgIGwgPSBwb2ludHMubGVuZ3RoIC0gMixcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICByZXN1bHQsXG4gICAgICBsYXN0O1xuICB0b2xlcmFuY2UgPSBNYXRoLnBvdyh0b2xlcmFuY2UgfHwgMSwgMik7XG5cbiAgZm9yIChpID0gMjsgaSA8IGw7IGkgKz0gMikge1xuICAgIHggPSBwYXJzZUZsb2F0KHBvaW50c1tpXSk7XG4gICAgeSA9IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSk7XG4gICAgZHggPSBwcmV2WCAtIHg7XG4gICAgZHkgPSBwcmV2WSAtIHk7XG5cbiAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPiB0b2xlcmFuY2UpIHtcbiAgICAgIHRlbXAucHVzaCh4LCB5KTtcbiAgICAgIHByZXZYID0geDtcbiAgICAgIHByZXZZID0geTtcbiAgICB9XG4gIH1cblxuICB0ZW1wLnB1c2gocGFyc2VGbG9hdChwb2ludHNbbF0pLCBwYXJzZUZsb2F0KHBvaW50c1tsICsgMV0pKTtcbiAgbGFzdCA9IHRlbXAubGVuZ3RoIC0gMjtcbiAgcmVzdWx0ID0gW3RlbXBbMF0sIHRlbXBbMV1dO1xuICBzaW1wbGlmeVN0ZXAodGVtcCwgMCwgbGFzdCwgdG9sZXJhbmNlLCByZXN1bHQpO1xuICByZXN1bHQucHVzaCh0ZW1wW2xhc3RdLCB0ZW1wW2xhc3QgKyAxXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKGl0ZXJhdGlvbnMsIHB4LCBweSwgc3RhcnQsIGVuZCwgc2xpY2VzLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIGluYyA9IChlbmQgLSBzdGFydCkgLyBzbGljZXMsXG4gICAgICBiZXN0ID0gMCxcbiAgICAgIHQgPSBzdGFydCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZCxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICBpbnY7XG4gIF9iZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW07XG5cbiAgd2hpbGUgKHQgPD0gZW5kKSB7XG4gICAgaW52ID0gMSAtIHQ7XG4gICAgeCA9IGludiAqIGludiAqIGludiAqIHgwICsgMyAqIGludiAqIGludiAqIHQgKiB4MSArIDMgKiBpbnYgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgeSA9IGludiAqIGludiAqIGludiAqIHkwICsgMyAqIGludiAqIGludiAqIHQgKiB5MSArIDMgKiBpbnYgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gICAgZHggPSB4IC0gcHg7XG4gICAgZHkgPSB5IC0gcHk7XG4gICAgZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuXG4gICAgaWYgKGQgPCBfYmVzdERpc3RhbmNlKSB7XG4gICAgICBfYmVzdERpc3RhbmNlID0gZDtcbiAgICAgIGJlc3QgPSB0O1xuICAgIH1cblxuICAgIHQgKz0gaW5jO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdGlvbnMgPiAxID8gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucyAtIDEsIHB4LCBweSwgTWF0aC5tYXgoYmVzdCAtIGluYywgMCksIE1hdGgubWluKGJlc3QgKyBpbmMsIDEpLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiBiZXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdERhdGEocmF3UGF0aCwgeCwgeSwgc2xpY2VzKSB7XG4gIC8vcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgY2xvc2VzdCBqLCBpLCBhbmQgdCAoaiBpcyB0aGUgc2VnbWVudCBpbmRleCwgaSBpcyB0aGUgaW5kZXggb2YgdGhlIHBvaW50IGluIHRoYXQgc2VnbWVudCwgYW5kIHQgaXMgdGhlIHRpbWUvcHJvZ3Jlc3MgYWxvbmcgdGhhdCBiZXppZXIpXG4gIHZhciBjbG9zZXN0ID0ge1xuICAgIGo6IDAsXG4gICAgaTogMCxcbiAgICB0OiAwXG4gIH0sXG4gICAgICBiZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW0sXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHQsXG4gICAgICBzZWdtZW50O1xuXG4gIGZvciAoaiA9IDA7IGogPCByYXdQYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbal07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgdCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKDEsIHgsIHksIDAsIDEsIHNsaWNlcyB8fCAyMCwgc2VnbWVudFtpXSwgc2VnbWVudFtpICsgMV0sIHNlZ21lbnRbaSArIDJdLCBzZWdtZW50W2kgKyAzXSwgc2VnbWVudFtpICsgNF0sIHNlZ21lbnRbaSArIDVdLCBzZWdtZW50W2kgKyA2XSwgc2VnbWVudFtpICsgN10pO1xuXG4gICAgICBpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuICAgICAgICBiZXN0RGlzdGFuY2UgPSBfYmVzdERpc3RhbmNlO1xuICAgICAgICBjbG9zZXN0LmogPSBqO1xuICAgICAgICBjbG9zZXN0LmkgPSBpO1xuICAgICAgICBjbG9zZXN0LnQgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufSAvL3N1YmRpdmlkZSBhIFNlZ21lbnQgY2xvc2VzdCB0byBhIHNwZWNpZmljIHgseSBjb29yZGluYXRlXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50TmVhcih4LCB5LCBzZWdtZW50LCBzbGljZXMsIGl0ZXJhdGlvbnMpIHtcbiAgdmFyIGwgPSBzZWdtZW50Lmxlbmd0aCxcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcbiAgICAgIGJlc3RUID0gMCxcbiAgICAgIGJlc3RTZWdtZW50SW5kZXggPSAwLFxuICAgICAgdCxcbiAgICAgIGk7XG4gIHNsaWNlcyA9IHNsaWNlcyB8fCAyMDtcbiAgaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnMgfHwgMztcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA2KSB7XG4gICAgdCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKDEsIHgsIHksIDAsIDEsIHNsaWNlcywgc2VnbWVudFtpXSwgc2VnbWVudFtpICsgMV0sIHNlZ21lbnRbaSArIDJdLCBzZWdtZW50W2kgKyAzXSwgc2VnbWVudFtpICsgNF0sIHNlZ21lbnRbaSArIDVdLCBzZWdtZW50W2kgKyA2XSwgc2VnbWVudFtpICsgN10pO1xuXG4gICAgaWYgKGJlc3REaXN0YW5jZSA+IF9iZXN0RGlzdGFuY2UpIHtcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9iZXN0RGlzdGFuY2U7XG4gICAgICBiZXN0VCA9IHQ7XG4gICAgICBiZXN0U2VnbWVudEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgeCwgeSwgYmVzdFQgLSAwLjA1LCBiZXN0VCArIDAuMDUsIHNsaWNlcywgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgMV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDJdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyAzXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgNF0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDVdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA2XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgN10pO1xuICBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGJlc3RTZWdtZW50SW5kZXgsIHQpO1xuICByZXR1cm4gYmVzdFNlZ21lbnRJbmRleCArIDY7XG59XG4vKlxuVGFrZXMgYW55IG9mIHRoZSBmb2xsb3dpbmcgYW5kIGNvbnZlcnRzIGl0IHRvIGFuIGFsbCBDdWJpYyBCZXppZXIgU1ZHIGRhdGEgc3RyaW5nOlxuLSBBIDxwYXRoPiBkYXRhIHN0cmluZyBsaWtlIFwiTTAsMCBMMiw0IHYyMCwxNSBIMTAwXCJcbi0gQSBSYXdQYXRoLCBsaWtlIFtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1bW3gsIHksIHgsIHksIHgsIHksIHgsIHldXVxuLSBBIFNlZ21lbnQsIGxpa2UgW3gsIHksIHgsIHksIHgsIHksIHgsIHldXG5cbk5vdGU6IGFsbCBudW1iZXJzIGFyZSByb3VuZGVkIGRvd24gdG8gdGhlIGNsb3Nlc3QgMC4wMDEgdG8gbWluaW1pemUgbWVtb3J5LCBtYXhpbWl6ZSBzcGVlZCwgYW5kIGF2b2lkIG9kZCBudW1iZXJzIGxpa2UgMWUtMTNcbiovXG5cbmV4cG9ydCBmdW5jdGlvbiByYXdQYXRoVG9TdHJpbmcocmF3UGF0aCkge1xuICBpZiAoX2lzTnVtYmVyKHJhd1BhdGhbMF0pKSB7XG4gICAgLy9pbiBjYXNlIGEgc2VnbWVudCBpcyBwYXNzZWQgaW4gaW5zdGVhZFxuICAgIHJhd1BhdGggPSBbcmF3UGF0aF07XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgIGwgPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHNsLFxuICAgICAgcyxcbiAgICAgIGksXG4gICAgICBzZWdtZW50O1xuXG4gIGZvciAocyA9IDA7IHMgPCBsOyBzKyspIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtzXTtcbiAgICByZXN1bHQgKz0gXCJNXCIgKyBfcm91bmQoc2VnbWVudFswXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50WzFdKSArIFwiIENcIjtcbiAgICBzbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMjsgaSA8IHNsOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIiBcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2ldKSArIFwiIFwiO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50LmNsb3NlZCkge1xuICAgICAgcmVzdWx0ICs9IFwielwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKlxuLy8gdGFrZXMgYSBzZWdtZW50IHdpdGggY29vcmRpbmF0ZXMgW3gsIHksIHgsIHksIC4uLl0gYW5kIGNvbnZlcnRzIHRoZSBjb250cm9sIHBvaW50cyBpbnRvIGFuZ2xlcyBhbmQgbGVuZ3RocyBbeCwgeSwgYW5nbGUsIGxlbmd0aCwgYW5nbGUsIGxlbmd0aCwgeCwgeSwgYW5nbGUsIGxlbmd0aCwgLi4uXSBzbyB0aGF0IGl0IGFuaW1hdGVzIG1vcmUgY2xlYW5seSBhbmQgYXZvaWRzIG9kZCBicmVha3Mva2lua3MuIEZvciBleGFtcGxlLCBpZiB5b3UgYW5pbWF0ZSBmcm9tIDEgbydjbG9jayB0byA2IG8nY2xvY2ssIGl0J2QganVzdCBnbyBkaXJlY3RseS9saW5lYXJseSByYXRoZXIgdGhhbiBhcm91bmQuIFNvIHRoZSBsZW5ndGggd291bGQgYmUgdmVyeSBzaG9ydCBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0d2Vlbi5cbmV4cG9ydCBmdW5jdGlvbiBjcENvb3Jkc1RvQW5nbGVzKHNlZ21lbnQsIGNvcHkpIHtcblx0dmFyIHJlc3VsdCA9IGNvcHkgPyBzZWdtZW50LnNsaWNlKDApIDogc2VnbWVudCxcblx0XHR4LCB5LCBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkrPTYpIHtcblx0XHR4ID0gc2VnbWVudFtpKzJdIC0gc2VnbWVudFtpXTtcblx0XHR5ID0gc2VnbWVudFtpKzNdIC0gc2VnbWVudFtpKzFdO1xuXHRcdHJlc3VsdFtpKzJdID0gTWF0aC5hdGFuMih5LCB4KTtcblx0XHRyZXN1bHRbaSszXSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHR4ID0gc2VnbWVudFtpKzZdIC0gc2VnbWVudFtpKzRdO1xuXHRcdHkgPSBzZWdtZW50W2krN10gLSBzZWdtZW50W2krNV07XG5cdFx0cmVzdWx0W2krNF0gPSBNYXRoLmF0YW4yKHksIHgpO1xuXHRcdHJlc3VsdFtpKzVdID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHRha2VzIGEgc2VnbWVudCB0aGF0IHdhcyBjb252ZXJ0ZWQgd2l0aCBjcENvb3Jkc1RvQW5nbGVzKCkgdG8gaGF2ZSBhbmdsZXMgYW5kIGxlbmd0aHMgaW5zdGVhZCBvZiBjb29yZGluYXRlcyBmb3IgdGhlIGNvbnRyb2wgcG9pbnRzLCBhbmQgY29udmVydHMgaXQgQkFDSyBpbnRvIGNvb3JkaW5hdGVzLlxuZXhwb3J0IGZ1bmN0aW9uIGNwQW5nbGVzVG9Db29yZHMoc2VnbWVudCwgY29weSkge1xuXHR2YXIgcmVzdWx0ID0gY29weSA/IHNlZ21lbnQuc2xpY2UoMCkgOiBzZWdtZW50LFxuXHRcdGxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoLFxuXHRcdHJuZCA9IDEwMDAsXG5cdFx0YW5nbGUsIGwsIGksIGo7XG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrPTYpIHtcblx0XHRhbmdsZSA9IHNlZ21lbnRbaSsyXTtcblx0XHRsID0gc2VnbWVudFtpKzNdOyAvL2xlbmd0aFxuXHRcdHJlc3VsdFtpKzJdID0gKCgoc2VnbWVudFtpXSArIE1hdGguY29zKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHRcdHJlc3VsdFtpKzNdID0gKCgoc2VnbWVudFtpKzFdICsgTWF0aC5zaW4oYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0YW5nbGUgPSBzZWdtZW50W2krNF07XG5cdFx0bCA9IHNlZ21lbnRbaSs1XTsgLy9sZW5ndGhcblx0XHRyZXN1bHRbaSs0XSA9ICgoKHNlZ21lbnRbaSs2XSAtIE1hdGguY29zKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHRcdHJlc3VsdFtpKzVdID0gKCgoc2VnbWVudFtpKzddIC0gTWF0aC5zaW4oYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy9hZGRzIGFuIFwiaXNTbW9vdGhcIiBhcnJheSB0byBlYWNoIHNlZ21lbnQgYW5kIHBvcHVsYXRlcyBpdCB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGl0J3Mgc21vb3RoICh0aGUgY29udHJvbCBwb2ludHMgaGF2ZSBiYXNpY2FsbHkgdGhlIHNhbWUgc2xvcGUpLiBGb3IgYW55IHNtb290aCBjb250cm9sIHBvaW50cywgaXQgY29udmVydHMgdGhlIGNvb3JkaW5hdGVzIGludG8gYW5nbGUgKHgsIGluIHJhZGlhbnMpIGFuZCBsZW5ndGggKHkpIGFuZCBwdXRzIHRoZW0gaW50byB0aGUgc2FtZSBpbmRleCB2YWx1ZSBpbiBhIHNtb290aERhdGEgYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gcG9wdWxhdGVTbW9vdGhEYXRhKHJhd1BhdGgpIHtcblx0bGV0IGogPSByYXdQYXRoLmxlbmd0aCxcblx0XHRzbW9vdGgsIHNlZ21lbnQsIHgsIHksIHgyLCB5MiwgaSwgbCwgYSwgYTIsIGlzU21vb3RoLCBzbW9vdGhEYXRhO1xuXHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRzZWdtZW50ID0gcmF3UGF0aFtqXTtcblx0XHRpc1Ntb290aCA9IHNlZ21lbnQuaXNTbW9vdGggPSBzZWdtZW50LmlzU21vb3RoIHx8IFswLCAwLCAwLCAwXTtcblx0XHRzbW9vdGhEYXRhID0gc2VnbWVudC5zbW9vdGhEYXRhID0gc2VnbWVudC5zbW9vdGhEYXRhIHx8IFswLCAwLCAwLCAwXTtcblx0XHRpc1Ntb290aC5sZW5ndGggPSA0O1xuXHRcdGwgPSBzZWdtZW50Lmxlbmd0aCAtIDI7XG5cdFx0Zm9yIChpID0gNjsgaSA8IGw7IGkgKz0gNikge1xuXHRcdFx0eCA9IHNlZ21lbnRbaV0gLSBzZWdtZW50W2kgLSAyXTtcblx0XHRcdHkgPSBzZWdtZW50W2kgKyAxXSAtIHNlZ21lbnRbaSAtIDFdO1xuXHRcdFx0eDIgPSBzZWdtZW50W2kgKyAyXSAtIHNlZ21lbnRbaV07XG5cdFx0XHR5MiA9IHNlZ21lbnRbaSArIDNdIC0gc2VnbWVudFtpICsgMV07XG5cdFx0XHRhID0gX2F0YW4yKHksIHgpO1xuXHRcdFx0YTIgPSBfYXRhbjIoeTIsIHgyKTtcblx0XHRcdHNtb290aCA9IChNYXRoLmFicyhhIC0gYTIpIDwgMC4wOSk7XG5cdFx0XHRpZiAoc21vb3RoKSB7XG5cdFx0XHRcdHNtb290aERhdGFbaSAtIDJdID0gYTtcblx0XHRcdFx0c21vb3RoRGF0YVtpICsgMl0gPSBhMjtcblx0XHRcdFx0c21vb3RoRGF0YVtpIC0gMV0gPSBfc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0c21vb3RoRGF0YVtpICsgM10gPSBfc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cdFx0XHR9XG5cdFx0XHRpc1Ntb290aC5wdXNoKHNtb290aCwgc21vb3RoLCAwLCAwLCBzbW9vdGgsIHNtb290aCk7XG5cdFx0fVxuXHRcdC8vaWYgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgaWRlbnRpY2FsLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIHNtb290aCB0cmFuc2l0aW9uLiBXZSBtdXN0IGhhbmRsZSB0aGlzIGEgYml0IGRpZmZlcmVudGx5IGR1ZSB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGFycmF5LlxuXHRcdGlmIChzZWdtZW50W2xdID09PSBzZWdtZW50WzBdICYmIHNlZ21lbnRbbCsxXSA9PT0gc2VnbWVudFsxXSkge1xuXHRcdFx0eCA9IHNlZ21lbnRbMF0gLSBzZWdtZW50W2wtMl07XG5cdFx0XHR5ID0gc2VnbWVudFsxXSAtIHNlZ21lbnRbbC0xXTtcblx0XHRcdHgyID0gc2VnbWVudFsyXSAtIHNlZ21lbnRbMF07XG5cdFx0XHR5MiA9IHNlZ21lbnRbM10gLSBzZWdtZW50WzFdO1xuXHRcdFx0YSA9IF9hdGFuMih5LCB4KTtcblx0XHRcdGEyID0gX2F0YW4yKHkyLCB4Mik7XG5cdFx0XHRpZiAoTWF0aC5hYnMoYSAtIGEyKSA8IDAuMDkpIHtcblx0XHRcdFx0c21vb3RoRGF0YVtsLTJdID0gYTtcblx0XHRcdFx0c21vb3RoRGF0YVsyXSA9IGEyO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2wtMV0gPSBfc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0c21vb3RoRGF0YVszXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblx0XHRcdFx0aXNTbW9vdGhbbC0yXSA9IGlzU21vb3RoW2wtMV0gPSB0cnVlOyAvL2Rvbid0IGNoYW5nZSBpbmRleGVzIDIgYW5kIDMgYmVjYXVzZSB3ZSdsbCB0cmlnZ2VyIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgRU5ELCBhbmQgdGhpcyB3aWxsIG9wdGltaXplIGZpbGUgc2l6ZSBhIGJpdC5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHJhd1BhdGg7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NjcmVlbihzdmdFbGVtZW50LCBwb2ludCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHsgLy9ieSBkZWZhdWx0LCB0YWtlIHRoZSBmaXJzdCBzZXQgb2YgY29vcmRpbmF0ZXMgaW4gdGhlIHBhdGggYXMgdGhlIHBvaW50XG5cdFx0bGV0IHJhd1BhdGggPSBnZXRSYXdQYXRoKHN2Z0VsZW1lbnQpO1xuXHRcdHBvaW50ID0gc3ZnRWxlbWVudC5vd25lclNWR0VsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcblx0XHRwb2ludC54ID0gcmF3UGF0aFswXVswXTtcblx0XHRwb2ludC55ID0gcmF3UGF0aFswXVsxXTtcblx0fVxuXHRyZXR1cm4gcG9pbnQubWF0cml4VHJhbnNmb3JtKHN2Z0VsZW1lbnQuZ2V0U2NyZWVuQ1RNKCkpO1xufVxuXG4qLyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/utils/paths.js\n"));

/***/ }),

/***/ "./node_modules/gsap/utils/strings.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/utils/strings.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"emojiExp\": function() { return /* binding */ emojiExp; },\n/* harmony export */   \"emojiSafeSplit\": function() { return /* binding */ emojiSafeSplit; },\n/* harmony export */   \"getText\": function() { return /* binding */ getText; },\n/* harmony export */   \"splitInnerHTML\": function() { return /* binding */ splitInnerHTML; }\n/* harmony export */ });\n/*!\n * strings: 3.11.2\n * https://greensock.com\n *\n * Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _trimExp = /(?:^\\s+|\\s+$)/g;\nvar emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nfunction getText(e) {\n  var type = e.nodeType,\n      result = \"\";\n\n  if (type === 1 || type === 9 || type === 11) {\n    if (typeof e.textContent === \"string\") {\n      return e.textContent;\n    } else {\n      for (e = e.firstChild; e; e = e.nextSibling) {\n        result += getText(e);\n      }\n    }\n  } else if (type === 3 || type === 4) {\n    return e.nodeValue;\n  }\n\n  return result;\n}\nfunction splitInnerHTML(element, delimiter, trim, preserveSpaces) {\n  var node = element.firstChild,\n      result = [],\n      s;\n\n  while (node) {\n    if (node.nodeType === 3) {\n      s = (node.nodeValue + \"\").replace(/^\\n+/g, \"\");\n\n      if (!preserveSpaces) {\n        s = s.replace(/\\s+/g, \" \");\n      }\n\n      result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces));\n    } else if ((node.nodeName + \"\").toLowerCase() === \"br\") {\n      result[result.length - 1] += \"<br>\";\n    } else {\n      result.push(node.outerHTML);\n    }\n\n    node = node.nextSibling;\n  }\n\n  s = result.length;\n\n  while (s--) {\n    result[s] === \"&\" && result.splice(s, 1, \"&amp;\");\n  }\n\n  return result;\n}\n/*\n//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.\n\nlet _emoji = \"[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + \"|.\", \"g\"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, \"\");\n\t\t}\n\t\treturn ((delimiter === \"\" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || \"\");\n\t};\n */\n\nfunction emojiSafeSplit(text, delimiter, trim, preserveSpaces) {\n  text += \"\"; // make sure it's cast as a string. Someone may pass in a number.\n\n  trim && (text = text.trim ? text.trim() : text.replace(_trimExp, \"\")); // IE9 and earlier compatibility\n\n  if (delimiter && delimiter !== \"\") {\n    return text.replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").split(delimiter);\n  }\n\n  var result = [],\n      l = text.length,\n      i = 0,\n      j,\n      character;\n\n  for (; i < l; i++) {\n    character = text.charAt(i);\n\n    if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n      //special emoji characters use 2 or 4 unicode characters that we must keep together.\n      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || \"\").length || 2;\n      character = text.substr(i, j);\n      result.emoji = 1;\n      i += j - 1;\n    }\n\n    result.push(character === \">\" ? \"&gt;\" : character === \"<\" ? \"&lt;\" : preserveSpaces && character === \" \" && (text.charAt(i - 1) === \" \" || text.charAt(i + 1) === \" \") ? \"&nbsp;\" : character);\n  }\n\n  return result;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9zdHJpbmdzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLGdHQUFnRyxHQUFHO0FBQ25HO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkJBQTZCLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsY0FBYzs7QUFFZCx5RUFBeUU7O0FBRXpFO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsNkJBQTZCLCtHQUErRztBQUNyTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3V0aWxzL3N0cmluZ3MuanM/MmZiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHN0cmluZ3M6IDMuMTEuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfdHJpbUV4cCA9IC8oPzpeXFxzK3xcXHMrJCkvZztcbmV4cG9ydCB2YXIgZW1vamlFeHAgPSAvKFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0oPzpbXFx1MjAwRFxcdUZFMEZdW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl7Mix9fFxcdUQ4M0RcXHVEQzY5KD86XFx1MjAwRCg/Oig/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjd8KD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2Nil8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NcXHVERkYzXFx1RkUwRlxcdTIwMERcXHVEODNDXFx1REYwOHwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNkZcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzQy1cXHVERDNFXFx1RERENi1cXHVERERGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEZ8XFx1RDgzQ1xcdURERkRcXHVEODNDXFx1RERGMHxcXHVEODNDXFx1RERGNlxcdUQ4M0NcXHVEREU2fFxcdUQ4M0NcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RDgzQ1xcdURERTkoPzpcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdKXxcXHVEODNDXFx1RERGNyg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdKXxcXHVEODNDXFx1RERFOCg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RkUwRlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXSlcXHVGRTBGfCg/OlxcdUQ4M0RcXHVEQzQxXFx1RkUwRlxcdTIwMERcXHVEODNEXFx1RERFOHxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzRFxcdURDNjlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzRFxcdURDNjgoPzooPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSkpXFx1RkUwRnxcXHVEODNDXFx1RERGMig/OlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpfFxcdUQ4M0NcXHVEREYxKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdKXxcXHVEODNDXFx1RERFRig/OlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV0pfFxcdUQ4M0NcXHVEREVEKD86XFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdKXxcXHVEODNDXFx1RERFQig/OlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XSl8WyNcXCowLTldXFx1RkUwRlxcdTIwRTN8XFx1RDgzQ1xcdURERTcoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU2KD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXSl8XFx1RDgzQ1xcdURERkYoPzpcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ10pfFxcdUQ4M0NcXHVEREY1KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGQig/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV0pfFxcdUQ4M0NcXHVEREYzKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdKXxcXHVEODNDXFx1REZGNFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjIoPzpcXHVEQjQwXFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzN8XFx1REI0MFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURCNDBcXHVEQzY1XFx1REI0MFxcdURDNkVcXHVEQjQwXFx1REM2NylcXHVEQjQwXFx1REM3RnxcXHVEODNEXFx1REM2OCg/OlxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY4fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXSl8KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXSkpfFxcdUQ4M0NcXHVEREY4KD86XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjAoPzpcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERkUoPzpcXHVEODNDW1xcdURERUFcXHVEREY5XSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREY5KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERURcXHVEREVGLVxcdURERjRcXHVEREY3XFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVDKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRVxcdURERjEtXFx1RERGM1xcdURERjUtXFx1RERGQVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkEoPzpcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdKXxcXHVEODNDXFx1RERGQyg/OlxcdUQ4M0NbXFx1RERFQlxcdURERjhdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNzBcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDQUFcXHVERDc0XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzZcXHVEREQxLVxcdURERDVdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHUyMDBEKD86KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjd8KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjYpfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNkY5XFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyLVxcdURGQzRcXHVERkM3XFx1REZDQS1cXHVERkNDXXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2Ni1cXHVEQzY5XFx1REM2RVxcdURDNzAtXFx1REM3OFxcdURDN0NcXHVEQzgxLVxcdURDODNcXHVEQzg1LVxcdURDODdcXHVEQ0FBXFx1REQ3NFxcdURENzVcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0NS1cXHVERTQ3XFx1REU0Qi1cXHVERTRGXFx1REVBM1xcdURFQjQtXFx1REVCNlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQyNlxcdUREMzAtXFx1REQzOVxcdUREM0RcXHVERDNFXFx1REREMS1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3woPzpbXFx1MjMxQVxcdTIzMUJcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNUZFXFx1MjYxNFxcdTI2MTVcXHUyNjQ4LVxcdTI2NTNcXHUyNjdGXFx1MjY5M1xcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkYyXFx1MjZGM1xcdTI2RjVcXHUyNkZBXFx1MjZGRFxcdTI3MDVcXHUyNzBBXFx1MjcwQlxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGOTNcXHVERkEwLVxcdURGQ0FcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY0XFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMzRVxcdURDNDBcXHVEQzQyLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERGQi1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQ1xcdURFRDAtXFx1REVEMlxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUY4XXxcXHVEODNFW1xcdUREMTAtXFx1REQzQVxcdUREM0MtXFx1REQzRVxcdURENDAtXFx1REQ0NVxcdURENDctXFx1REQ0Q1xcdURENTAtXFx1REQ2QlxcdUREODAtXFx1REQ5N1xcdUREQzBcXHVEREQwLVxcdURERTZdKXwoPzpbI1xcKjAtOVxceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MURcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdGXFx1MjY5Mi1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2QzhcXHUyNkNFXFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZENFxcdTI2RTlcXHUyNkVBXFx1MjZGMC1cXHUyNkY1XFx1MjZGNy1cXHUyNkZBXFx1MjZGRFxcdTI3MDJcXHUyNzA1XFx1MjcwOC1cXHUyNzBEXFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzXFx1Mjc2NFxcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMVxcdURGMjQtXFx1REY5M1xcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RS1cXHVERkYwXFx1REZGMy1cXHVERkY1XFx1REZGNy1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1RENGRFxcdURDRkYtXFx1REQzRFxcdURENDktXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdURENkZcXHVERDcwXFx1REQ3My1cXHVERDdBXFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREOTBcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQS1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQi1cXHVERUQyXFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRUJcXHVERUVDXFx1REVGMFxcdURFRjMtXFx1REVGOF18XFx1RDgzRVtcXHVERDEwLVxcdUREM0FcXHVERDNDLVxcdUREM0VcXHVERDQwLVxcdURENDVcXHVERDQ3LVxcdURENENcXHVERDUwLVxcdURENkJcXHVERDgwLVxcdUREOTdcXHVEREMwXFx1REREMC1cXHVEREU2XSlcXHVGRTBGKS87XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dChlKSB7XG4gIHZhciB0eXBlID0gZS5ub2RlVHlwZSxcbiAgICAgIHJlc3VsdCA9IFwiXCI7XG5cbiAgaWYgKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gOSB8fCB0eXBlID09PSAxMSkge1xuICAgIGlmICh0eXBlb2YgZS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGUudGV4dENvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZSA9IGUuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgcmVzdWx0ICs9IGdldFRleHQoZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgfHwgdHlwZSA9PT0gNCkge1xuICAgIHJldHVybiBlLm5vZGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRJbm5lckhUTUwoZWxlbWVudCwgZGVsaW1pdGVyLCB0cmltLCBwcmVzZXJ2ZVNwYWNlcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgcztcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBzID0gKG5vZGUubm9kZVZhbHVlICsgXCJcIikucmVwbGFjZSgvXlxcbisvZywgXCJcIik7XG5cbiAgICAgIGlmICghcHJlc2VydmVTcGFjZXMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgZW1vamlTYWZlU3BsaXQocywgZGVsaW1pdGVyLCB0cmltLCBwcmVzZXJ2ZVNwYWNlcykpO1xuICAgIH0gZWxzZSBpZiAoKG5vZGUubm9kZU5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImJyXCIpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gKz0gXCI8YnI+XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUub3V0ZXJIVE1MKTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgfVxuXG4gIHMgPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChzLS0pIHtcbiAgICByZXN1bHRbc10gPT09IFwiJlwiICYmIHJlc3VsdC5zcGxpY2UocywgMSwgXCImYW1wO1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKlxuLy9zbWFsbGVyIGtiIHZlcnNpb24gdGhhdCBvbmx5IGhhbmRsZXMgdGhlIHNpbXBsZXIgZW1vamkncywgd2hpY2ggaXMgb2Z0ZW4gcGVyZmVjdGx5IGFkZXF1YXRlLlxuXG5sZXQgX2Vtb2ppID0gXCJbXFx1RTAwMC1cXHVGOEZGXXxcXHVEODNDW1xcdURDMDAtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURGRkZdfFtcXHUyNjk0LVxcdTI2OTddfFxcdUQ4M0VbXFx1REQxMC1cXHVERDVEXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdXCIsXG5cdF9lbW9qaUV4cCA9IG5ldyBSZWdFeHAoX2Vtb2ppKSxcblx0X2Vtb2ppQW5kQ2hhcnNFeHAgPSBuZXcgUmVnRXhwKF9lbW9qaSArIFwifC5cIiwgXCJnXCIpLFxuXHRfZW1vamlTYWZlU3BsaXQgPSAodGV4dCwgZGVsaW1pdGVyLCB0cmltKSA9PiB7XG5cdFx0aWYgKHRyaW0pIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoX3RyaW1FeHAsIFwiXCIpO1xuXHRcdH1cblx0XHRyZXR1cm4gKChkZWxpbWl0ZXIgPT09IFwiXCIgfHwgIWRlbGltaXRlcikgJiYgX2Vtb2ppRXhwLnRlc3QodGV4dCkpID8gdGV4dC5tYXRjaChfZW1vamlBbmRDaGFyc0V4cCkgOiB0ZXh0LnNwbGl0KGRlbGltaXRlciB8fCBcIlwiKTtcblx0fTtcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1vamlTYWZlU3BsaXQodGV4dCwgZGVsaW1pdGVyLCB0cmltLCBwcmVzZXJ2ZVNwYWNlcykge1xuICB0ZXh0ICs9IFwiXCI7IC8vIG1ha2Ugc3VyZSBpdCdzIGNhc3QgYXMgYSBzdHJpbmcuIFNvbWVvbmUgbWF5IHBhc3MgaW4gYSBudW1iZXIuXG5cbiAgdHJpbSAmJiAodGV4dCA9IHRleHQudHJpbSA/IHRleHQudHJpbSgpIDogdGV4dC5yZXBsYWNlKF90cmltRXhwLCBcIlwiKSk7IC8vIElFOSBhbmQgZWFybGllciBjb21wYXRpYmlsaXR5XG5cbiAgaWYgKGRlbGltaXRlciAmJiBkZWxpbWl0ZXIgIT09IFwiXCIpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5zcGxpdChkZWxpbWl0ZXIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgbCA9IHRleHQubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBqLFxuICAgICAgY2hhcmFjdGVyO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2hhcmFjdGVyID0gdGV4dC5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPj0gMHhEODAwICYmIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDB4REJGRiB8fCB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID49IDB4RkUwMCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpIDw9IDB4RkUwRikge1xuICAgICAgLy9zcGVjaWFsIGVtb2ppIGNoYXJhY3RlcnMgdXNlIDIgb3IgNCB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCB3ZSBtdXN0IGtlZXAgdG9nZXRoZXIuXG4gICAgICBqID0gKCh0ZXh0LnN1YnN0cihpLCAxMikuc3BsaXQoZW1vamlFeHApIHx8IFtdKVsxXSB8fCBcIlwiKS5sZW5ndGggfHwgMjtcbiAgICAgIGNoYXJhY3RlciA9IHRleHQuc3Vic3RyKGksIGopO1xuICAgICAgcmVzdWx0LmVtb2ppID0gMTtcbiAgICAgIGkgKz0gaiAtIDE7XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goY2hhcmFjdGVyID09PSBcIj5cIiA/IFwiJmd0O1wiIDogY2hhcmFjdGVyID09PSBcIjxcIiA/IFwiJmx0O1wiIDogcHJlc2VydmVTcGFjZXMgJiYgY2hhcmFjdGVyID09PSBcIiBcIiAmJiAodGV4dC5jaGFyQXQoaSAtIDEpID09PSBcIiBcIiB8fCB0ZXh0LmNoYXJBdChpICsgMSkgPT09IFwiIFwiKSA/IFwiJm5ic3A7XCIgOiBjaGFyYWN0ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/utils/strings.js\n"));

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ index; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/index.js\");\n/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap/all */ \"./node_modules/gsap/all.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_common_Header__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/common/Header */ \"./components/common/Header.jsx\");\n/* harmony import */ var _components_index_Top__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/index/Top */ \"./components/index/Top.jsx\");\n/* harmony import */ var _components_index_Icons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/index/Icons */ \"./components/index/Icons.jsx\");\n/* harmony import */ var _components_index_About__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/index/About */ \"./components/index/About.jsx\");\n/* harmony import */ var _components_index_Newses__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/index/Newses */ \"./components/index/Newses.jsx\");\n/* harmony import */ var _components_index_Projects__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/index/Projects */ \"./components/index/Projects.jsx\");\n/* harmony import */ var _components_common_Footer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/common/Footer */ \"./components/common/Footer.jsx\");\n/* harmony import */ var _components_common_Arrow__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/common/Arrow */ \"./components/common/Arrow.jsx\");\n/* harmony import */ var _components_common_Nav__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/common/Nav */ \"./components/common/Nav.jsx\");\n\nvar _s = $RefreshSig$();\n\n\n\ngsap__WEBPACK_IMPORTED_MODULE_2__[\"default\"].registerPlugin(gsap_all__WEBPACK_IMPORTED_MODULE_3__.ScrollToPlugin);\n\n\n\n\n\n\n\n\n\n\nfunction index() {\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false), show = ref[0], setShow = ref[1];\n    // const modal = useRef()\n    // const window = useRef()\n    var Open = function() {\n        if (show == false) {\n            setShow(true);\n        } else if (show == true) {\n            setShow(false);\n        } else {\n            return null;\n        }\n    };\n    var scrollTop = function() {\n        // window.scrollTo(0, 100)\n        // gsap.to(window, {\n        //    duration: 2, \n        //    y:0 \n        // });\n        // var window_obj = window;\n        gsap__WEBPACK_IMPORTED_MODULE_2__[\"default\"].to(window_obj, {\n            duration: 2,\n            scrollTo: {\n                y: 10\n            }\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        charset: \"UTF-8\"\n                    }, void 0, false, {\n                        fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                        lineNumber: 48,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Generated by create next app\"\n                    }, void 0, false, {\n                        fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                        lineNumber: 49,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 47,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_common_Nav__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                show: show\n            }, void 0, false, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 51,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_common_Header__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                Open: Open,\n                show: show\n            }, void 0, false, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 52,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_index_Top__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 53,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_index_Top__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 54,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_index_Top__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 55,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_common_Arrow__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                scrollTop: scrollTop\n            }, void 0, false, {\n                fileName: \"/Users/starrygeust2/Desktop/site/pages/index.js\",\n                lineNumber: 61,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n};\n_s(index, \"Hdw5EO+DplCNBEJcNuH8tsP7WZ4=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFBNEI7QUFFTDtBQUNrQjtBQUN6Q0MsMkRBQW1CLENBQUNDLG9EQUFjLENBQUM7QUFDWTtBQUNDO0FBQ1A7QUFDSTtBQUNBO0FBQ0U7QUFDSTtBQUNIO0FBQ0Y7QUFDSjtBQUUzQixTQUFTYyxLQUFLLEdBQUc7O0lBQzlCLElBQXdCWCxHQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBQWhDWSxJQUFJLEdBQWFaLEdBQWUsR0FBNUIsRUFBRWEsT0FBTyxHQUFJYixHQUFlLEdBQW5CO0lBQ3BCLHlCQUF5QjtJQUN6QiwwQkFBMEI7SUFDMUIsSUFBTWMsSUFBSSxHQUFHLFdBQU07UUFDakIsSUFBR0YsSUFBSSxJQUFFLEtBQUssRUFBQztZQUNYQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ2pCLE9BQ0ssSUFBR0QsSUFBSSxJQUFFLElBQUksRUFBQztZQUNmQyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQ2xCLE9BQ0k7WUFDQSxPQUFPLElBQUksQ0FBQztRQUNoQixDQUFDO0lBQ0gsQ0FBQztJQUNELElBQU1FLFNBQVMsR0FBRyxXQUFNO1FBQ3RCLDBCQUEwQjtRQUMxQixvQkFBb0I7UUFDcEIsbUJBQW1CO1FBQ25CLFVBQVU7UUFDVixNQUFNO1FBRU4sMkJBQTJCO1FBQzNCbkIsK0NBQU8sQ0FBQ3FCLFVBQVUsRUFBRTtZQUNsQkMsUUFBUSxFQUFFLENBQUM7WUFDWEMsUUFBUSxFQUFFO2dCQUFDQyxDQUFDLEVBQUUsRUFBRTthQUFDO1NBQ2xCLENBQUM7SUFDSixDQUFDO0lBQ0QscUJBQ0U7OzBCQUNFLDhEQUFDekIsa0RBQUk7O2tDQUNILDhEQUFDMEIsTUFBSTt3QkFBQ0MsT0FBTyxFQUFDLE9BQU87Ozs7OzRCQUFFO2tDQUN2Qiw4REFBQ0QsTUFBSTt3QkFBQ0UsSUFBSSxFQUFDLGFBQWE7d0JBQUNDLE9BQU8sRUFBQyw4QkFBOEI7Ozs7OzRCQUFHOzs7Ozs7b0JBQzdEOzBCQUNQLDhEQUFDZCwrREFBRztnQkFBQ0UsSUFBSSxFQUFFQSxJQUFJOzs7OztvQkFBRzswQkFDbEIsOERBQUNWLGlFQUFNO2dCQUFDWSxJQUFJLEVBQUVBLElBQUk7Z0JBQUVGLElBQUksRUFBRUEsSUFBSTs7Ozs7b0JBQUc7MEJBQ2pDLDhEQUFDVCw2REFBRzs7OztvQkFBRTswQkFDTiw4REFBQ0EsNkRBQUc7Ozs7b0JBQUU7MEJBQ04sOERBQUNBLDZEQUFHOzs7O29CQUFFOzBCQU1OLDhEQUFDTSxpRUFBSztnQkFBQ00sU0FBUyxFQUFFQSxTQUFTOzs7OztvQkFBRzs7b0JBQzdCLENBQ0o7QUFDSCxDQUFDO0dBL0N1QkosS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC5qcz9iZWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCdcblxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCdcbmltcG9ydCB7IFNjcm9sbFRvUGx1Z2luIH0gZnJvbSAnZ3NhcC9hbGwnXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRvUGx1Z2luKVxuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZVJlZn0gIGZyb20gJ3JlYWN0JztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9jb21tb24vSGVhZGVyJ1xuaW1wb3J0IFRvcCBmcm9tICcuLi9jb21wb25lbnRzL2luZGV4L1RvcCdcbmltcG9ydCBJY29ucyBmcm9tICcuLi9jb21wb25lbnRzL2luZGV4L0ljb25zJ1xuaW1wb3J0IEFib3V0IGZyb20gJy4uL2NvbXBvbmVudHMvaW5kZXgvQWJvdXQnXG5pbXBvcnQgTmV3c2VzIGZyb20gJy4uL2NvbXBvbmVudHMvaW5kZXgvTmV3c2VzJ1xuaW1wb3J0IFByb2plY3RzIGZyb20gJy4uL2NvbXBvbmVudHMvaW5kZXgvUHJvamVjdHMnXG5pbXBvcnQgRm9vdGVyIGZyb20gJy4uL2NvbXBvbmVudHMvY29tbW9uL0Zvb3RlcidcbmltcG9ydCBBcnJvdyBmcm9tICcuLi9jb21wb25lbnRzL2NvbW1vbi9BcnJvdydcbmltcG9ydCBOYXYgZnJvbSAnLi4vY29tcG9uZW50cy9jb21tb24vTmF2J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmRleCgpIHtcbiAgY29uc3QgW3Nob3csIHNldFNob3ddID0gdXNlU3RhdGUoZmFsc2UpXG4gIC8vIGNvbnN0IG1vZGFsID0gdXNlUmVmKClcbiAgLy8gY29uc3Qgd2luZG93ID0gdXNlUmVmKClcbiAgY29uc3QgT3BlbiA9ICgpID0+IHtcbiAgICBpZihzaG93PT1mYWxzZSl7XG4gICAgICAgIHNldFNob3codHJ1ZSlcbiAgICB9XG4gICAgZWxzZSBpZihzaG93PT10cnVlKXtcbiAgICAgICAgc2V0U2hvdyhmYWxzZSlcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNjcm9sbFRvcCA9ICgpID0+IHtcbiAgICAvLyB3aW5kb3cuc2Nyb2xsVG8oMCwgMTAwKVxuICAgIC8vIGdzYXAudG8od2luZG93LCB7XG4gICAgLy8gICAgZHVyYXRpb246IDIsIFxuICAgIC8vICAgIHk6MCBcbiAgICAvLyB9KTtcblxuICAgIC8vIHZhciB3aW5kb3dfb2JqID0gd2luZG93O1xuICAgIGdzYXAudG8od2luZG93X29iaiwge1xuICAgICAgZHVyYXRpb246IDIsXG4gICAgICBzY3JvbGxUbzoge3k6IDEwfSxcbiAgICB9KVxuICB9XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8bWV0YSBjaGFyc2V0PSdVVEYtOCcvPlxuICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PVwiR2VuZXJhdGVkIGJ5IGNyZWF0ZSBuZXh0IGFwcFwiIC8+XG4gICAgICA8L0hlYWQ+XG4gICAgICA8TmF2IHNob3c9e3Nob3d9Lz5cbiAgICAgIDxIZWFkZXIgT3Blbj17T3Blbn0gc2hvdz17c2hvd30vPlxuICAgICAgPFRvcC8+XG4gICAgICA8VG9wLz5cbiAgICAgIDxUb3AvPlxuICAgICAgey8qIDxJY29ucy8+XG4gICAgICA8QWJvdXQvPlxuICAgICAgPE5ld3Nlcy8+XG4gICAgICA8UHJvamVjdHMvPlxuICAgICAgPEZvb3Rlci8+ICovfVxuICAgICAgPEFycm93IHNjcm9sbFRvcD17c2Nyb2xsVG9wfS8+XG4gICAgPC8+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJIZWFkIiwiZ3NhcCIsIlNjcm9sbFRvUGx1Z2luIiwicmVnaXN0ZXJQbHVnaW4iLCJSZWFjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiSGVhZGVyIiwiVG9wIiwiSWNvbnMiLCJBYm91dCIsIk5ld3NlcyIsIlByb2plY3RzIiwiRm9vdGVyIiwiQXJyb3ciLCJOYXYiLCJpbmRleCIsInNob3ciLCJzZXRTaG93IiwiT3BlbiIsInNjcm9sbFRvcCIsInRvIiwid2luZG93X29iaiIsImR1cmF0aW9uIiwic2Nyb2xsVG8iLCJ5IiwibWV0YSIsImNoYXJzZXQiLCJuYW1lIiwiY29udGVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ })

});